/* tslint:disable */
/* eslint-disable */
/**
 * Core API
 * Marqeta\'s Core API endpoints, conveniently annotated to enable code generation (including SDKs), test cases, and documentation. Currently in beta.
 *
 * The version of the OpenAPI document: 3.0.35
 * Contact: support@marqeta.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base';
import { DUMMY_BASE_URL, assertParamExists, createRequestFunction, serializeDataIfNeeded, setBasicAuthToObject, setSearchParams, toPathString } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ACHListResponse {
    'count'?: number;
    'data'?: Array<BaseAchResponseModel>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface ATCInformationModel {
    'atc_discrepancy_indicator'?: string;
    'atc_discrepancy_value'?: number;
    'atc_value'?: number;
}
export interface AcceptedCountriesListResponse {
    'count'?: number;
    'data'?: Array<AcceptedCountriesModel>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface AcceptedCountriesModel {
    'country_codes': Array<string>;
    'created_time'?: string;
    'is_whitelist': boolean;
    'last_modified_time'?: string;
    'name': string;
    'token'?: string;
}
/**
 * Contains a cardholder\'s login access information.
 */
export interface AccessTokenResponse {
    'accesstoken_id'?: string;
    'application'?: Application;
    /**
     * Date and time when the access token expires.
     */
    'expires': string;
    /**
     * Array of master roles.
     */
    'master_roles'?: Array<string>;
    /**
     * Indicates whether the access token is a single-use token.
     */
    'one_time'?: boolean;
    /**
     * Unique identifier of the access token.
     */
    'token'?: string;
    /**
     * Specifies the type of access token.
     */
    'token_type'?: string;
    /**
     * Unique identifier of the user resource.
     */
    'user_token'?: string;
}
/**
 * Contains information related to the cardholder and provided by the digital wallet provider.
 */
export interface Account {
    /**
     * Digital wallet provider\'s email address for the cardholder.
     */
    'email_address'?: string;
    /**
     * Digital wallet provider\'s identity number for the cardholder.
     */
    'id'?: string;
    /**
     * Score from the digital wallet provider.
     */
    'score'?: string;
}
/**
 * Returns paginated account adjustments.
 */
export interface AccountAdjustmentPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more account adjustments.
     */
    'data': Array<AccountAdjustmentResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information relevant to creating an account adjustment.
 */
export interface AccountAdjustmentReq {
    /**
     * Amount of the adjustment.  Value must be negative if `original_ledger_entry_token` is not passed.
     */
    'amount': number;
    'currency_code': CurrencyCode;
    /**
     * Description of the adjustment.
     */
    'description': string;
    /**
     * Unique identifier you provide of an associated external adjustment that exists outside Marqeta\'s credit platform.
     */
    'external_adjustment_id'?: string;
    /**
     * Additional information on the adjustment.
     */
    'note'?: string;
    /**
     * Unique identifier of the original journal entry needing the adjustment.  Required when adjusting an existing journal entry.
     */
    'original_ledger_entry_token'?: string;
    /**
     * Reason for the adjustment.  * `DISPUTE` - The adjustment occurred because a dispute was initiated. * `DISPUTE_RESOLUTION` - The adjustment occurred because of the result of a dispute resolution. * `RETURNED_OR_CANCELED_PAYMENT` - The adjustment occurred because a payment was returned or canceled. * `OTHER` - Any other reason the adjustment occurred. For example, a waived fee or account write-off.
     */
    'reason'?: AccountAdjustmentReqReasonEnum;
    /**
     * Unique identifier of the adjustment.
     */
    'token'?: string;
}

export const AccountAdjustmentReqReasonEnum = {
    Dispute: 'DISPUTE',
    DisputeResolution: 'DISPUTE_RESOLUTION',
    ReturnedOrCanceledPayment: 'RETURNED_OR_CANCELED_PAYMENT',
    Other: 'OTHER'
} as const;

export type AccountAdjustmentReqReasonEnum = typeof AccountAdjustmentReqReasonEnum[keyof typeof AccountAdjustmentReqReasonEnum];

/**
 * Contains information returned for account adjustment.
 */
export interface AccountAdjustmentResponse {
    /**
     * Unique identifier of the credit account on which the adjustment was made.
     */
    'account_token': string;
    /**
     * Contains the adjustment\'s full details.  The fields returned in this object depend on the adjustment type.  Interest returns interest details. For the specific fields returned, see the `detail_object` fields marked \"Returned for interest journal entries\" in the <</core-api/credit-account-journal-entries#getAccountJournalEntry, account journal entry response fields>>.  Disputes return dispute details. For the specific fields returned, see the <</core-api/credit-account-disputes#retrieveDispute, dispute response fields>>.
     */
    'adjustment_detail_object'?: object | null;
    /**
     * Amount of the adjustment.
     */
    'amount': number;
    /**
     * Date and time when the account adjustment was applied, in UTC.
     */
    'created_time'?: string;
    'currency_code': CurrencyCode;
    /**
     * Description of the adjustment.
     */
    'description': string;
    /**
     * Unique identifier of the adjustment detail. For example, the token of the dispute, the interest charge, or the returned payment that prompted the adjustment.  Returned when the system automatically applies an adjustment.
     */
    'detail_token'?: string | null;
    /**
     * Unique identifier you provide of an associated external adjustment that exists outside Marqeta\'s credit platform.
     */
    'external_adjustment_id'?: string | null;
    /**
     * Additional information on the adjustment.
     */
    'note'?: string | null;
    /**
     * Unique identifier of the original journal entry needing the adjustment.
     */
    'original_ledger_entry_token'?: string;
    /**
     * Reason for the adjustment.  * `DISPUTE` - The adjustment occurred because a dispute was initiated. * `DISPUTE_RESOLUTION` - The adjustment occurred because of the result of a dispute resolution. * `RETURNED_OR_CANCELED_PAYMENT` - The adjustment occurred because a payment was returned or canceled. * `OTHER` - Any other reason the adjustment occurred. For example, a waived fee.
     */
    'reason': AccountAdjustmentResponseReasonEnum;
    /**
     * Contains full details of the related dispute or returned payment.  The fields returned in this object depend on whether a dispute or returned payment led to the interest adjustment. A dispute returns dispute details; a returned payment returns payment details.  For more on the dispute details returned, see the <</core-api/credit-account-disputes#retrieveDispute, dispute response fields>>.  For more on the returned payment details returned, see the <</core-api/credit-account-payments#retrievePayment, payment response fields>>.  This field is returned for interest adjustments only.
     */
    'related_detail_object'?: object | null;
    /**
     * Unique identifier of the dispute or returned payment that prompted the interest adjustment.  This field is returned for interest adjustments only.
     */
    'related_detail_token'?: string | null;
    /**
     * Unique identifier of the adjustment.  If in the `detail_object`, unique identifier of the detail object.
     */
    'token': string;
    /**
     * Type of adjustment.  The adjustment is made on its correlating amount (for example, purchase adjustments are made on purchase amounts). You can use general adjustments for standalone adjustments made on the credit account balance itself, which includes account write-offs, credits, and more.
     */
    'type': AccountAdjustmentResponseTypeEnum;
}

export const AccountAdjustmentResponseReasonEnum = {
    Dispute: 'DISPUTE',
    DisputeResolution: 'DISPUTE_RESOLUTION',
    ReturnedOrCanceledPayment: 'RETURNED_OR_CANCELED_PAYMENT',
    Other: 'OTHER'
} as const;

export type AccountAdjustmentResponseReasonEnum = typeof AccountAdjustmentResponseReasonEnum[keyof typeof AccountAdjustmentResponseReasonEnum];
export const AccountAdjustmentResponseTypeEnum = {
    Purchase: 'PURCHASE',
    Fee: 'FEE',
    Reward: 'REWARD',
    Interest: 'INTEREST',
    General: 'GENERAL'
} as const;

export type AccountAdjustmentResponseTypeEnum = typeof AccountAdjustmentResponseTypeEnum[keyof typeof AccountAdjustmentResponseTypeEnum];

/**
 * Type of document.
 */

export const AccountAndDocumentAssetType = {
    TermsSchedule: 'TERMS_SCHEDULE',
    AccountStatement: 'ACCOUNT_STATEMENT',
    SummaryOfCreditTerms: 'SUMMARY_OF_CREDIT_TERMS',
    RewardsDisclosure: 'REWARDS_DISCLOSURE',
    PrivacyPolicy: 'PRIVACY_POLICY',
    EDisclosure: 'E_DISCLOSURE',
    BenefitsDisclosure: 'BENEFITS_DISCLOSURE',
    CardMemberAgreement: 'CARD_MEMBER_AGREEMENT'
} as const;

export type AccountAndDocumentAssetType = typeof AccountAndDocumentAssetType[keyof typeof AccountAndDocumentAssetType];


/**
 * Type of APR.  * `GO_TO` - Default APR rate that is applicable when any promotional periods expire. * `PROMOTIONAL` - A temporary rate that is applicable for a specified period of time.
 */

export const AccountAprType = {
    GoTo: 'GO_TO',
    Promotional: 'PROMOTIONAL'
} as const;

export type AccountAprType = typeof AccountAprType[keyof typeof AccountAprType];


export interface AccountBalance {
    'balances'?: { [key: string]: CurrencyBalance; };
    'default_currency_code'?: string;
    'description'?: string;
    'impacted_amount'?: number;
    'last_updated_time'?: string;
    'token'?: string;
    'type'?: string;
}
export interface AccountBalanceResponse {
    'account_balance'?: AccountBalance;
}
/**
 * Details of a billing cycle.
 */
export interface AccountBillingCycleResponse {
    /**
     * Token of the associated account.
     */
    'account_token': string;
    /**
     * Date and time when the Billing Cycle was created on Marqeta\'s credit platform
     */
    'created_time': string;
    /**
     * End time of the current billing cycle.
     */
    'current_end_time': string;
    /**
     * Payment due date for the current billing cycle.
     */
    'current_payment_due_date': string;
    /**
     * Start time of the current billing cycle.
     */
    'current_start_time': string;
    /**
     * End time of the next billing cycle.
     */
    'next_end_time': string;
    /**
     * Payment due date for the next billing cycle.
     */
    'next_payment_due_date': string;
    /**
     * Start time of the next billing cycle.
     */
    'next_start_time': string;
    /**
     * Unique identifier of the billing cycle\'s short code.
     */
    'short_code': string;
    /**
     * Date and time when the BillingCycle was last updated on Marqeta\'s credit platform
     */
    'updated_time': string;
}
/**
 * Returns paginated account cards.
 */
export interface AccountCardsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more credit cards.
     */
    'data': Array<CardResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains configurations for a minimum payment override on a credit account, which overrides the minimum payment configurations on the associated credit product.
 */
export interface AccountConfigMinPayment {
    /**
     * Whether the minimum payment override is currently active.
     */
    'active'?: boolean;
    /**
     * Flat amount of the minimum payment override.
     */
    'min_payment_flat_amount'?: number;
    /**
     * Percentage of the total statement balance used to calculate the minimum payment override amount.
     */
    'min_payment_percentage'?: number;
    /**
     * Date and time when the minimum payment override ends, in UTC.
     */
    'override_end_time'?: string;
    /**
     * Date and time when the minimum payment override starts, in UTC.
     */
    'override_start_time'?: string;
}
/**
 * Contains configurations for a payment hold.
 */
export interface AccountConfigPaymentHolds {
    /**
     * Number of days to hold an ACH payment.
     */
    'ach_hold_days'?: number;
    /**
     * Number of days to hold a check payment.
     */
    'check_hold_days'?: number;
}
/**
 * Contains information returned when configuring an account\'s billing cycle day, payment due day, fees, and more.
 */
export interface AccountConfigResponse {
    /**
     * Day of the month when the billing cycle starts. If an override value is not provided, the default value is derived from the bundle.
     */
    'billing_cycle_day': number;
    /**
     * Level of the credit card.
     */
    'card_level': AccountConfigResponseCardLevelEnum;
    /**
     * A value of `true` indicates that the account holder consents to receiving disclosures and statements electronically.
     */
    'e_disclosure_active': boolean;
    /**
     * Contains one or more fees associated with the credit account.
     */
    'fees'?: Array<ConfigFeeScheduleResponse>;
    'min_payment'?: AccountConfigMinPayment;
    /**
     * Day of the month when the payment for the previous billing cycle is due.
     * @deprecated
     */
    'payment_due_day'?: number;
    /**
     * Specifies the payment due interval that is used to determine the payment due date for a billing cycle. A value of -1 indicates one day prior to the next billing cycle date.
     */
    'payment_due_interval'?: number;
    'payment_holds': AccountConfigPaymentHolds;
    /**
     * Contains one or more rewards associated with the credit account.
     */
    'rewards'?: Array<AccountReward>;
}

export const AccountConfigResponseCardLevelEnum = {
    Premium: 'PREMIUM',
    Traditional: 'TRADITIONAL',
    Na: 'NA'
} as const;

export type AccountConfigResponseCardLevelEnum = typeof AccountConfigResponseCardLevelEnum[keyof typeof AccountConfigResponseCardLevelEnum];

/**
 * Contains information relevant for updating configurations for electronic disclosures, fees, payment holds, and minimum payment.
 */
export interface AccountConfigUpdateReq {
    /**
     * A value of `true` indicates that the account holder consents to receiving disclosures and statements electronically.
     */
    'e_disclosure_active'?: boolean;
    /**
     * Contains one or more fees associated with the credit account.
     */
    'fees'?: Array<ConfigFeeScheduleReq>;
    'min_payment'?: AccountConfigMinPayment;
    /**
     * Specifies the payment due interval that is used to determine the payment due date for a billing cycle. A value of -1 indicates one day prior to the next billing cycle date.  For consumer programs, a minimum gap of 21 days is required between when a statement is delivered and the payment due date.
     */
    'payment_due_interval'?: number;
    'payment_holds'?: AccountConfigPaymentHolds;
}
/**
 * Contains details on a credit balance refund.
 */
export interface AccountCreditBalanceRefundReq {
    /**
     * Amount of the credit balance refund.  The maximum refund amount is the amount that brings the account balance to $0. For example, $4000 is the maximum refund amount for a -$4000 account balance.
     */
    'amount': number;
    'currency_code': CurrencyCode;
    /**
     * Description for the credit balance refund.
     */
    'description': string;
    'method': RefundMethod;
    /**
     * Unique identifier of the credit balance refund.
     */
    'token'?: string;
}


/**
 * Contains details on a credit balance refund.
 */
export interface AccountCreditBalanceRefundResponse {
    /**
     * Unique identifier of the credit account that needs the credit balance refund.
     */
    'account_token': string;
    /**
     * Amount of the credit balance refund.  The maximum refund amount is the amount that brings the account balance to $0. For example, $4000 is the maximum refund amount for a -$4000 account balance.
     */
    'amount': number;
    /**
     * Date and time when the credit balance refund was created.
     */
    'created_time': string;
    /**
     * Description for the credit credit balance refund.
     */
    'description': string;
    'method': RefundMethod;
    'status': PaymentStatus;
    /**
     * Unique identifier of the credit balance refund.  If in the `detail_object`, unique identifier of the detail object.
     */
    'token': string;
    /**
     * Date and time when the credit balance refund was last updated.
     */
    'updated_time': string;
}


/**
 * Account document response.
 */
export interface AccountDocumentResponse {
    /**
     * Date and time when the user accepted the document on Marqeta\'s credit platform, in UTC.
     */
    'accepted_at'?: string;
    /**
     * Unique identifier of the document on a credit account.
     */
    'asset_token'?: string;
    'asset_urls'?: PolicyDocumentAssetURLs;
    /**
     * Date and time when the document goes into effect on Marqeta\'s credit platform, in UTC.
     */
    'effective_from'?: string;
}
/**
 * Account document response.
 */
export interface AccountDocumentsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Array of documents on the credit account.
     */
    'data': Array<AccountDocumentResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Account documents response.
 */
export interface AccountDocumentsResponse {
    'account_statement'?: AccountDocumentResponse;
    'benefits_disclosure'?: AccountDocumentResponse;
    'card_member_agreement'?: AccountDocumentResponse;
    'e_disclosure'?: AccountDocumentResponse;
    'privacy_policy'?: AccountDocumentResponse;
    'rewards_disclosure'?: AccountDocumentResponse;
    'summary_of_credit_terms'?: AccountDocumentResponse;
    'terms_schedule'?: AccountDocumentResponse;
}
/**
 * Contains fee configurations on a credit account.
 */
export interface AccountFee {
    'method': Method;
    'type': FeeType;
    /**
     * Value of the fee, either a flat fee amount or percentage value.
     */
    'value'?: number;
}


/**
 * Returns paginated account fees.
 */
export interface AccountFeePage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more account fees.
     */
    'data': Array<AccountFeeResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information relevant to creating an account fee.
 */
export interface AccountFeeReq {
    /**
     * Amount of the fee.  Value must be positive.
     */
    'amount': number;
    'currency_code': CurrencyCode;
    /**
     * Description of the fee.
     */
    'description'?: string;
    /**
     * Subtype of the fee. Required if fee type is ACCOUNT_FEE that can have ACCOUNT_OPENING_FEE or UPGRADE_FEE subtypes.
     */
    'subtype'?: AccountFeeReqSubtypeEnum;
    /**
     * Unique identifier of the fee.
     */
    'token'?: string;
    /**
     * Type of the fee.
     */
    'type': AccountFeeReqTypeEnum;
}

export const AccountFeeReqSubtypeEnum = {
    AccountOpeningFee: 'ACCOUNT_OPENING_FEE',
    UpgradeFee: 'UPGRADE_FEE',
    CashFee: 'CASH_FEE'
} as const;

export type AccountFeeReqSubtypeEnum = typeof AccountFeeReqSubtypeEnum[keyof typeof AccountFeeReqSubtypeEnum];
export const AccountFeeReqTypeEnum = {
    AccountFee: 'ACCOUNT_FEE',
    ReturnedPaymentFee: 'RETURNED_PAYMENT_FEE'
} as const;

export type AccountFeeReqTypeEnum = typeof AccountFeeReqTypeEnum[keyof typeof AccountFeeReqTypeEnum];

/**
 * Contains information returned for account fee.
 */
export interface AccountFeeResponse {
    /**
     * Unique identifier of the credit account on which the fee was made.
     */
    'account_token': string;
    /**
     * Amount of the fee.
     */
    'amount': number;
    /**
     * The amount to which the fee was applied (applicable only for certain fees).
     */
    'applied_to_amount'?: number | null;
    /**
     * Indicates how the fee was created.
     */
    'channel': AccountFeeResponseChannelEnum;
    /**
     * Date and time when the account fee was applied, in UTC.
     */
    'created_time'?: string;
    'currency_code': CurrencyCode;
    /**
     * Description of the fee.
     */
    'description': string;
    'journal_tokens': Array<string>;
    /**
     * The way fee is calculated.
     */
    'method': AccountFeeResponseMethodEnum;
    /**
     * Status of the fee.
     */
    'status': AccountFeeResponseStatusEnum;
    /**
     * Subtype of fee.
     */
    'subtype': AccountFeeResponseSubtypeEnum;
    /**
     * Unique identifier of the fee.
     */
    'token': string;
    /**
     * Type of fee.
     */
    'type': AccountFeeResponseTypeEnum;
    /**
     * Value of the fee.
     */
    'value': number;
}

export const AccountFeeResponseChannelEnum = {
    Api: 'API',
    System: 'SYSTEM'
} as const;

export type AccountFeeResponseChannelEnum = typeof AccountFeeResponseChannelEnum[keyof typeof AccountFeeResponseChannelEnum];
export const AccountFeeResponseMethodEnum = {
    Percentage: 'PERCENTAGE',
    Flat: 'FLAT'
} as const;

export type AccountFeeResponseMethodEnum = typeof AccountFeeResponseMethodEnum[keyof typeof AccountFeeResponseMethodEnum];
export const AccountFeeResponseStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED',
    Reversed: 'REVERSED'
} as const;

export type AccountFeeResponseStatusEnum = typeof AccountFeeResponseStatusEnum[keyof typeof AccountFeeResponseStatusEnum];
export const AccountFeeResponseSubtypeEnum = {
    AccountOpeningFee: 'ACCOUNT_OPENING_FEE',
    UpgradeFee: 'UPGRADE_FEE',
    CashFee: 'CASH_FEE'
} as const;

export type AccountFeeResponseSubtypeEnum = typeof AccountFeeResponseSubtypeEnum[keyof typeof AccountFeeResponseSubtypeEnum];
export const AccountFeeResponseTypeEnum = {
    AccountFee: 'ACCOUNT_FEE',
    ReturnedPaymentFee: 'RETURNED_PAYMENT_FEE',
    ForeignTransactionFee: 'FOREIGN_TRANSACTION_FEE',
    OverLimitFee: 'OVER_LIMIT_FEE',
    LatePaymentFee: 'LATE_PAYMENT_FEE',
    CardReplacementFee: 'CARD_REPLACEMENT_FEE',
    MinimumInterestFee: 'MINIMUM_INTEREST_FEE',
    AnnualFee: 'ANNUAL_FEE',
    MonthlyFee: 'MONTHLY_FEE',
    MinimumInterestFeeReversal: 'MINIMUM_INTEREST_FEE_REVERSAL'
} as const;

export type AccountFeeResponseTypeEnum = typeof AccountFeeResponseTypeEnum[keyof typeof AccountFeeResponseTypeEnum];

/**
 * Contains details about account funding transactions. Account funding transactions move money into a cardholder\'s general purpose account (GPA).
 */
export interface AccountFunding {
    'entry_device_type'?: AccountFundingEntryDeviceTypeEnum;
    /**
     * Specifies the type of account from which the transaction was funded.
     */
    'funding_source'?: AccountFundingFundingSourceEnum;
    /**
     * Specifies the type of account receiving the funding.
     */
    'receiver_account_type'?: AccountFundingReceiverAccountTypeEnum;
    /**
     * Specifies the name of the account holder receiving the funding.
     */
    'receiver_name'?: string;
    'reference_id'?: string;
    /**
     * Sanctions screening score to assist with meeting Anti-Money Laundering (AML) obligations.  Higher scores indicate that the sender\'s data more closely resembles an entry on the regulatory watchlist.  A value of 999 means no score was available.
     */
    'screening_score'?: string;
    /**
     * Account number of the sender funding the transaction.
     */
    'sender_account_number'?: string;
    /**
     * Street address of the sender funding the transaction.
     */
    'sender_address'?: string;
    /**
     * City of the sender funding the transaction.
     */
    'sender_city'?: string;
    /**
     * Country of the sender funding the transaction.
     */
    'sender_country'?: string;
    'sender_date_of_birth'?: string;
    /**
     * Name of the sender funding the transaction.
     */
    'sender_name'?: string;
    'sender_postal_code'?: string;
    /**
     * State or province of the sender funding the transaction.
     */
    'sender_state'?: string;
    /**
     * Describes the purpose of the account funding transaction.
     */
    'transaction_purpose'?: string;
    /**
     * Specifies the account funding transaction type.
     */
    'transaction_type'?: AccountFundingTransactionTypeEnum;
}

export const AccountFundingEntryDeviceTypeEnum = {
    OffTheShelfMobileConsumer: 'OFF_THE_SHELF_MOBILE_CONSUMER'
} as const;

export type AccountFundingEntryDeviceTypeEnum = typeof AccountFundingEntryDeviceTypeEnum[keyof typeof AccountFundingEntryDeviceTypeEnum];
export const AccountFundingFundingSourceEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Prepaid: 'PREPAID',
    DepositAccount: 'DEPOSIT_ACCOUNT',
    Cash: 'CASH',
    MobileMoneyAccount: 'MOBILE_MONEY_ACCOUNT',
    NonVisaCredit: 'NON_VISA_CREDIT',
    Check: 'CHECK',
    Ach: 'ACH'
} as const;

export type AccountFundingFundingSourceEnum = typeof AccountFundingFundingSourceEnum[keyof typeof AccountFundingFundingSourceEnum];
export const AccountFundingReceiverAccountTypeEnum = {
    Other: 'OTHER',
    RtnBankAccount: 'RTN_BANK_ACCOUNT',
    Iban: 'IBAN',
    CardAccount: 'CARD_ACCOUNT',
    Email: 'EMAIL',
    PhoneNumber: 'PHONE_NUMBER',
    BankAccountNumberAndBankIdentificationCode: 'BANK_ACCOUNT_NUMBER_AND_BANK_IDENTIFICATION_CODE',
    WalletId: 'WALLET_ID',
    SocialNetworkId: 'SOCIAL_NETWORK_ID'
} as const;

export type AccountFundingReceiverAccountTypeEnum = typeof AccountFundingReceiverAccountTypeEnum[keyof typeof AccountFundingReceiverAccountTypeEnum];
export const AccountFundingTransactionTypeEnum = {
    AccountToAccount: 'ACCOUNT_TO_ACCOUNT',
    PersonToPerson: 'PERSON_TO_PERSON',
    WalletTransfer: 'WALLET_TRANSFER',
    MoneyTransferByBank: 'MONEY_TRANSFER_BY_BANK',
    BusinessToBusiness: 'BUSINESS_TO_BUSINESS',
    Disbursement: 'DISBURSEMENT',
    GovernmentDisbursement: 'GOVERNMENT_DISBURSEMENT',
    GamblingPayout: 'GAMBLING_PAYOUT',
    Loyalty: 'LOYALTY',
    MerchantDisbursement: 'MERCHANT_DISBURSEMENT',
    OnlineGamblingPayout: 'ONLINE_GAMBLING_PAYOUT',
    PensionDisbursement: 'PENSION_DISBURSEMENT',
    PrepaidLoads: 'PREPAID_LOADS',
    CardBillPayment: 'CARD_BILL_PAYMENT',
    BillPayment: 'BILL_PAYMENT',
    CashClaim: 'CASH_CLAIM',
    CashIn: 'CASH_IN',
    CashOut: 'CASH_OUT',
    MobileAirTimePayment: 'MOBILE_AIR_TIME_PAYMENT',
    MoneyTransferByMerchant: 'MONEY_TRANSFER_BY_MERCHANT',
    FaceToFaceMerchantPayment: 'FACE_TO_FACE_MERCHANT_PAYMENT',
    GovernmentPayment: 'GOVERNMENT_PAYMENT',
    PaymentsGoodsServices: 'PAYMENTS_GOODS_SERVICES',
    FundsTransfer: 'FUNDS_TRANSFER',
    VisaAccept: 'VISA_ACCEPT',
    GeneralBusinessToBusinessTransfer: 'GENERAL_BUSINESS_TO_BUSINESS_TRANSFER',
    BusinessToBusinessTransfer: 'BUSINESS_TO_BUSINESS_TRANSFER',
    CashDeposit: 'CASH_DEPOSIT',
    PurchaseRepayment: 'PURCHASE_REPAYMENT',
    AftOrOctEligibility: 'AFT_OR_OCT_ELIGIBILITY',
    ConsumerBillPayment: 'CONSUMER_BILL_PAYMENT',
    RequestToPay: 'REQUEST_TO_PAY',
    LiquidAsset: 'LIQUID_ASSET',
    FastRefund: 'FAST_REFUND',
    GamingPayment: 'GAMING_PAYMENT'
} as const;

export type AccountFundingTransactionTypeEnum = typeof AccountFundingTransactionTypeEnum[keyof typeof AccountFundingTransactionTypeEnum];

export interface AccountHolderGroupConfig {
    'is_reloadable'?: boolean;
    'kyc_required'?: AccountHolderGroupConfigKycRequiredEnum;
    'pre_kyc_controls'?: PreKycControls;
    'real_time_fee_group_token'?: string;
}

export const AccountHolderGroupConfigKycRequiredEnum = {
    Always: 'ALWAYS',
    Conditional: 'CONDITIONAL',
    Never: 'NEVER'
} as const;

export type AccountHolderGroupConfigKycRequiredEnum = typeof AccountHolderGroupConfigKycRequiredEnum[keyof typeof AccountHolderGroupConfigKycRequiredEnum];

export interface AccountHolderGroupListResponse {
    'count'?: number;
    'data'?: Array<AccountHolderGroupResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface AccountHolderGroupRequest {
    'config'?: AccountHolderGroupConfig;
    'name'?: string;
    'token'?: string;
}
export interface AccountHolderGroupResponse {
    'config'?: AccountHolderGroupConfig;
    /**
     * 40 char max
     */
    'name'?: string;
    /**
     * 36 char max
     */
    'token'?: string;
}
export interface AccountHolderGroupUpdateRequest {
    'config'?: AccountHolderGroupConfig;
    'name'?: string;
}
/**
 * Contains name verification data: the full name entered by the cardholder, name data held by the Marqeta platform, and an assertion by the Marqeta platform as to whether the two sets of data match.
 */
export interface AccountNameVerificationModel {
    'on_file'?: AniInformation;
    'request'?: AniInformation;
    'request_type'?: AccountNameVerificationModelRequestTypeEnum;
    'response'?: Response;
}

export const AccountNameVerificationModelRequestTypeEnum = {
    Sender: 'SENDER',
    Receiver: 'RECEIVER'
} as const;

export type AccountNameVerificationModelRequestTypeEnum = typeof AccountNameVerificationModelRequestTypeEnum[keyof typeof AccountNameVerificationModelRequestTypeEnum];

/**
 * Contains account name verification data used to make JIT Funding decisions.
 */
export interface AccountNameVerificationSource {
    /**
     * First or given name of the cardholder.
     */
    'first_name'?: string;
    /**
     * Last or family name of the cardholder.
     */
    'last_name'?: string;
    /**
     * Middle name of the cardholder.
     */
    'middle_name'?: string;
    'on_file'?: AniInformation;
    'response'?: Response;
}
/**
 * Information about the owner of an account participating in an account funding or original credit transaction.
 */
export interface AccountOwnerModel {
    /**
     * Account owner\'s country of birth.
     */
    'country_of_birth'?: string;
    /**
     * Account owner\'s date of birth.
     */
    'dob'?: string;
    /**
     * Account owner\'s email address.
     */
    'email_address'?: string;
    /**
     * Account owner\'s nationality.
     */
    'nationality'?: string;
    /**
     * Account owner\'s occupation.
     */
    'occupation'?: string;
}
/**
 * Type of fee.
 */

export const AccountProductFeeType = {
    LatePaymentFee: 'LATE_PAYMENT_FEE',
    ReturnedPaymentFee: 'RETURNED_PAYMENT_FEE',
    MonthlyFee: 'MONTHLY_FEE',
    AnnualFee: 'ANNUAL_FEE',
    ForeignTransactionFee: 'FOREIGN_TRANSACTION_FEE'
} as const;

export type AccountProductFeeType = typeof AccountProductFeeType[keyof typeof AccountProductFeeType];


/**
 * Contains information on a credit account.
 */
export interface AccountResponse {
    /**
     * Date and time when the credit account was activated on Marqeta\'s credit platform, in UTC.
     */
    'activation_time'?: string;
    /**
     * Amount of credit available for use on the credit account.
     */
    'available_credit': number;
    /**
     * Unique identifier of the associated bundle product.
     */
    'bundle_token'?: string;
    /**
     * Substatuses of the business under the credit account.
     */
    'business_substatuses'?: Array<string>;
    /**
     * Unique identifier of the parent business program.  Either a `user_token` or `business_token` is returned, not both.
     */
    'business_token'?: string;
    'config': AccountConfigResponse;
    /**
     * Date and time when the credit account was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    /**
     * Maximum balance the credit account can carry.
     */
    'credit_limit': number;
    /**
     * Unique identifier of the associated credit product.
     */
    'credit_product_token'?: string;
    'currency_code': CurrencyCode;
    /**
     * Current purchase balance on the credit account.
     */
    'current_balance': number;
    /**
     * Description for the credit account.
     */
    'description'?: string;
    /**
     * Unique identifier you provide of the associated external credit offer.
     */
    'external_offer_id'?: string;
    'latest_statement_cycle_type'?: CycleType;
    /**
     * Contains `max_apr_schedule` objects, which provide information about any temporary overrides of the APRs on the credit account. This could include special APR rates due to account/user sub status changes.
     */
    'max_apr_schedules'?: Array<MaxAPRSchedulesResponse>;
    /**
     * Name of the credit account.
     */
    'name'?: string;
    /**
     * Amount remaining on the latest statement\'s minimum payment, after it\'s adjusted for payments, returned payments, and applicable credits that occurred after the latest statement\'s closing date.
     */
    'remaining_min_payment_due': number;
    /**
     * Amount remaining on the latest statement\'s balance, after it\'s adjusted for payments, returned payments, and applicable credits that occurred after the latest statement\'s closing date.
     */
    'remaining_statement_balance': number;
    /**
     * Unique identifier of the secured account.
     */
    'secured_account_token'?: string;
    'status': AccountStatusEnum;
    /**
     * Substatuses of the credit account.
     */
    'substatuses'?: Array<string>;
    /**
     * Unique identifier of the credit account.
     */
    'token': string;
    'type': AccountType;
    /**
     * Date and time when the credit account was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time': string;
    /**
     * Contains one or more `usages` objects that contain information on how a credit account is used and what types of balances are permitted on the account.
     */
    'usages': Array<AccountUsageResponse>;
    /**
     * Substatuses of the users under the credit account.
     */
    'user_substatuses'?: Array<string>;
    /**
     * Unique identifier of the primary account holder or an administrative user of a business account.  Either a `user_token` or `business_token` is returned, not both.
     */
    'user_token'?: string;
}


/**
 * TODO Add description here
 */
export interface AccountReward {
    'method': Method;
    'type': RewardType;
    /**
     * Value of the reward, either a flat reward amount or percentage value.
     */
    'value'?: number;
}


export interface AccountSignupBonusProgressResponse {
    /**
     * Date and time when the account started tracking spend accrued towards the signup bonus on Marqeta\'s credit platform, in UTC.
     */
    'accrual_start_time': string;
    /**
     * Date and time when transactions must be posted by to be eligible towards signup bonus on Marqeta\'s credit platform, in UTC.
     */
    'maturity_time': string;
    /**
     * Date and time when the account signup bonus progress was retrieved from Marqeta\'s credit platform, in UTC.
     */
    'retrieval_time'?: string;
    /**
     * Minimum spend required to earn the signup bonus on Marqeta\'s credit platform within the given timeframe.
     */
    'target_spend': number;
    /**
     * Total eligible spend accrued towards the signup bonus on Marqeta\'s credit platform at the time of retrieval if the signup bonus is still active.
     */
    'total_spend': number;
}
/**
 * Status of the credit account.  *NOTE* `CHARGE_OFF` is not an allowable value for `original_status`.
 */

export const AccountStatusEnum = {
    Unactivated: 'UNACTIVATED',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Terminated: 'TERMINATED',
    ChargeOff: 'CHARGE_OFF'
} as const;

export type AccountStatusEnum = typeof AccountStatusEnum[keyof typeof AccountStatusEnum];


/**
 * Information on the credit account transition.
 */
export interface AccountTransitionReq {
    'status': AccountStatusEnum;
    /**
     * Unique identifier of the credit account transition.
     */
    'token'?: string;
}


/**
 * Information on the credit account transition.
 */
export interface AccountTransitionResponse {
    /**
     * Unique identifier of the credit account for which to transition a status.
     */
    'account_token': string;
    /**
     * Date and time when the transition record was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    'original_status': AccountStatusEnum;
    'status': AccountStatusEnum;
    /**
     * Unique identifier of the credit account transition.
     */
    'token': string;
}


/**
 * Return paginated account transitions.
 */
export interface AccountTransitionsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more account transitions.
     */
    'data': Array<AccountTransitionResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Type of credit account.
 */

export const AccountType = {
    Consumer: 'CONSUMER',
    Business: 'BUSINESS'
} as const;

export type AccountType = typeof AccountType[keyof typeof AccountType];


export interface AccountUpdateReq {
    'config'?: AccountConfigUpdateReq;
    'credit_limit'?: AccountUpdateReqCreditLimit;
    'latest_statement_cycle_type'?: CycleType;
    /**
     * Contains one or more `usages` objects that contain information on how a credit account is used and what types of balances are permitted on the account.  You can pass only one `usages` object per `usages.type`.
     */
    'usages'?: Array<AccountUsageUpdateReq>;
    /**
     * User token tied to the credit account. You can only update the value of the user token for business accounts.
     */
    'user_token'?: string;
}


/**
 * Contains information on the credit limit.
 */
export interface AccountUpdateReqCreditLimit {
    /**
     * Maximum balance the credit account can carry.
     */
    'value': number;
}
/**
 * Contains information on how a credit account is used and what types of balances are permitted on the account.
 */
export interface AccountUsageResponse {
    /**
     * Contains one or more APRs associated with the type of balance on the credit account.
     */
    'aprs': Array<AprScheduleResponse>;
    /**
     * Contains one or more fees associated with the usage type.
     */
    'fees'?: Array<AccountFee>;
    'type': BalanceType;
}


/**
 * Contains information on how a credit account is used and what types of balances are permitted on the account.
 */
export interface AccountUsageUpdateReq {
    /**
     * Contains one or more annual percentage rates (APRs) associated with the credit account.
     */
    'aprs'?: Array<AprScheduleUpdateReq>;
    'type': BalanceType;
}


/**
 * Return paginated accounts.
 */
export interface AccountsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more credit accounts.
     */
    'data': Array<AccountResponse>;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
export interface AchModel {
    'account_number': string;
    'account_type': AchModelAccountTypeEnum;
    'bank_name'?: string;
    /**
     * Required if \'user_token\' is null
     */
    'business_token'?: string;
    'is_default_account'?: boolean;
    'name_on_account': string;
    'routing_number': string;
    'token'?: string;
    /**
     * Required if \'business_token\' is null
     */
    'user_token'?: string;
    'verification_notes'?: string;
    'verification_override'?: boolean;
}

export const AchModelAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    Corporate: 'corporate',
    Loan: 'loan'
} as const;

export type AchModelAccountTypeEnum = typeof AchModelAccountTypeEnum[keyof typeof AchModelAccountTypeEnum];

export interface AchPartnerRequestModel {
    /**
     * Required if \'user_token\' is null
     */
    'business_token'?: string;
    'idempotentHash'?: string;
    'is_default_account'?: boolean;
    'partner': AchPartnerRequestModelPartnerEnum;
    'partner_account_link_reference_token': string;
    'token'?: string;
    /**
     * Required if \'business_token\' is null
     */
    'user_token'?: string;
}

export const AchPartnerRequestModelPartnerEnum = {
    Plaid: 'PLAID'
} as const;

export type AchPartnerRequestModelPartnerEnum = typeof AchPartnerRequestModelPartnerEnum[keyof typeof AchPartnerRequestModelPartnerEnum];

export interface AchResponseModel {
    'account_suffix': string;
    'account_type': string;
    'active': boolean;
    'bank_name'?: string;
    'business_token'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'date_sent_for_verification'?: string;
    'date_verified'?: string;
    'is_default_account'?: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'name_on_account': string;
    'partner'?: string;
    'partner_account_link_reference_token'?: string;
    'token': string;
    'user_token'?: string;
    'verification_notes'?: string;
    'verification_override'?: boolean;
    'verification_status'?: string;
}
export interface AchVerificationModel {
    'active'?: boolean;
    'verify_amount1'?: number;
    'verify_amount2'?: number;
}
/**
 * Contains information about the merchant\'s financial institution.
 */
export interface Acquirer {
    /**
     * City of the merchant\'s financial institution. This field appears only in account funding and original credit transactions.
     */
    'city'?: string;
    /**
     * Country code of the merchant\'s financial institution. This field appears only in account funding and original credit transactions.
     */
    'country_code'?: string;
    /**
     * Country code of the merchant\'s financial institution.
     */
    'institution_country'?: string;
    /**
     * Identifier code of the merchant\'s financial institution.
     */
    'institution_id_code'?: string;
    /**
     * Street address of the merchant. This field appears only in account funding and original credit transactions.
     */
    'merchant_street_address'?: string;
    /**
     * Name of the merchant\'s financial institution. This field appears only in account funding and original credit transactions.
     */
    'name'?: string;
    /**
     * International network identifier.
     */
    'network_international_id'?: string;
    /**
     * Postal code of the merchant\'s financial institution. This field appears only in account funding and original credit transactions.
     */
    'postal_code'?: string;
    /**
     * Retrieval reference number of the merchant\'s financial institution.
     */
    'retrieval_reference_number'?: string;
    /**
     * State where the merchant\'s financial institution is located. This field appears only in account funding and original credit transactions.
     */
    'state'?: string;
    'street_address'?: string;
    /**
     * System trace audit number of the merchant\'s financial institution.
     */
    'system_trace_audit_number'?: string;
}
/**
 * Defines actions to execute when the card is activated. The fields in this object are mutually exclusive.
 */
export interface ActivationActions {
    /**
     * Moves all digital wallet tokens from the specified card to the new card.  Not relevant when `reissue_pan_from_card_token` is set.  Send a `GET` request to `/cards/user/{token}` to retrieve card tokens for a particular user.
     */
    'swap_digital_wallet_tokens_from_card_token'?: string;
    /**
     * If you are reissuing a card, the source card is terminated by default. To prevent the source card from being terminated, set this field to `false`.  Only relevant when `reissue_pan_from_card_token` is set.
     */
    'terminate_reissued_source_card'?: boolean;
}
export interface AddressRequestModel {
    'address1'?: string;
    'address2'?: string;
    'city'?: string;
    'country'?: string;
    'postal_code'?: string;
    'state'?: string;
    'zip'?: string;
}
export interface AddressResponseModel {
    'address1'?: string;
    'address2'?: string;
    'city'?: string;
    'country'?: string;
    'postal_code'?: string;
    'state'?: string;
    'zip'?: string;
}
/**
 * Contains address verification information.
 */
export interface AddressVerification {
    /**
     * Name of the cardholder.
     */
    'name'?: string;
    /**
     * Postal code.
     */
    'postal_code'?: string;
    /**
     * Street address provided by the cardholder.
     */
    'street_address'?: string;
    /**
     * United States ZIP code.
     */
    'zip'?: string;
}
/**
 * Contains address verification data consisting of address data entered by the cardholder, address data held by the Marqeta platform, and an assertion by the Marqeta platform as to whether the two sets of data match.
 */
export interface AddressVerificationModel {
    'on_file'?: AvsInformation;
    'request'?: AvsInformation;
    'response'?: Response;
}
/**
 * Contains address verification data consisting of address data entered by the cardholder, address data held by the Marqeta platform, and an assertion by the Marqeta platform as to whether the two sets of data match.
 */
export interface AddressVerificationSource {
    'on_file'?: AvsInformation;
    'response'?: Response;
}
/**
 * Visa Alias response object for retrieving information.
 */
export interface AdsAliasResponse {
    /**
     * Type of Visa Alias in the Alias Directory Service (ADS) profile. Visa supports phone and email as Visa Alias types that can be used in place of sensitive payment credentials details.  This field is returned if it exists in the resource.
     */
    'aliasType'?: AdsAliasResponseAliasTypeEnum;
    /**
     * Visa Alias value, which is the email address or phone number.
     */
    'aliasValue'?: string;
    'consent'?: AdsConsent;
    /**
     * Date and time when the Visa Alias was created.
     */
    'createdOn'?: string;
    'identification'?: AdsIdentification;
    /**
     * Date and time when the Visa Alias was last modified.
     */
    'lastModifiedOn'?: string;
    'profile'?: AdsProfile;
    /**
     * Status of the Visa Alias.
     */
    'status'?: AdsAliasResponseStatusEnum;
}

export const AdsAliasResponseAliasTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    DirectoryAliasid: 'DIRECTORY_ALIASID'
} as const;

export type AdsAliasResponseAliasTypeEnum = typeof AdsAliasResponseAliasTypeEnum[keyof typeof AdsAliasResponseAliasTypeEnum];
export const AdsAliasResponseStatusEnum = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Blocked: 'BLOCKED',
    Expired: 'EXPIRED'
} as const;

export type AdsAliasResponseStatusEnum = typeof AdsAliasResponseStatusEnum[keyof typeof AdsAliasResponseStatusEnum];

/**
 * Visa Alias response object for retrieving information.
 */
export interface AdsAliasResponseYaml {
    /**
     * Type of Visa Alias in the Alias Directory Service (ADS) profile. Visa supports phone and email as Visa Alias types that can be used in place of sensitive payment credentials details.  This field is returned if it exists in the resource.
     */
    'aliasType'?: AdsAliasResponseYamlAliasTypeEnum;
    /**
     * Visa Alias value, which is the email address or phone number.
     */
    'aliasValue'?: string;
    'consent'?: AdsConsent;
    /**
     * Date and time when the Visa Alias was created.
     */
    'createdOn'?: string;
    'identification'?: AdsIdentification;
    /**
     * Date and time when the Visa Alias was last modified.
     */
    'lastModifiedOn'?: string;
    'profile'?: AdsProfile;
    /**
     * Status of the Visa Alias.
     */
    'status'?: AdsAliasResponseYamlStatusEnum;
}

export const AdsAliasResponseYamlAliasTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    DirectoryAliasid: 'DIRECTORY_ALIASID'
} as const;

export type AdsAliasResponseYamlAliasTypeEnum = typeof AdsAliasResponseYamlAliasTypeEnum[keyof typeof AdsAliasResponseYamlAliasTypeEnum];
export const AdsAliasResponseYamlStatusEnum = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Blocked: 'BLOCKED',
    Expired: 'EXPIRED'
} as const;

export type AdsAliasResponseYamlStatusEnum = typeof AdsAliasResponseYamlStatusEnum[keyof typeof AdsAliasResponseYamlStatusEnum];

/**
 * Associated payment credential IDs.
 */
export interface AdsAssociatedIds {
    /**
     * UUID generated by Alias Directory, which identifies the Visa Alias.
     */
    'id'?: string;
    'type'?: AdsAssociatedIdsTypeEnum;
}

export const AdsAssociatedIdsTypeEnum = {
    Alias: 'ALIAS',
    PaymentCredential: 'PAYMENT_CREDENTIAL'
} as const;

export type AdsAssociatedIdsTypeEnum = typeof AdsAssociatedIdsTypeEnum[keyof typeof AdsAssociatedIdsTypeEnum];

/**
 * Billing address associated with the payment credential.
 */
export interface AdsBillingAddress {
    /**
     * Address line 1 of the billing address associated with the payment credential.
     */
    'addressLine1'?: string;
    /**
     * Address line 2 of the billing address associated with the payment credential.
     */
    'addressLine2'?: string;
    /**
     * Building number of the billing address associated with the payment credential.
     */
    'buildingNumber'?: string;
    /**
     * City of the billing address associated with the payment credential.
     */
    'city'?: string;
    /**
     * Country of the billing address associated with the payment credential, expressed as an ISO 3166 code. For example, the numeric code for the United States is `840` and the alpha-3 code is `USA`.  The ISO maintains the link:https://www.iso.org/iso-3166-country-codes.html[full list of ISO 3166 country codes, window=\"_blank\"].
     */
    'country': string;
    /**
     * Minor subdivision of the billing address associated with the payment credential.
     */
    'minorSubdivision'?: string;
    /**
     * Postal code of the billing address associated with the payment credential.
     */
    'postalCode'?: string;
    /**
     * State of the billing address associated with the payment credential.
     */
    'state'?: string;
    /**
     * Street name of the billing address associated with the payment credential.
     */
    'streetName'?: string;
}
/**
 * Request object for creating or updating a Visa ADS card.
 */
export interface AdsCardDetailsRequest {
    'billingAddress': AdsBillingAddress;
    /**
     * Unique identifier of the card.
     */
    'cardToken': string;
    /**
     * Indicates the type of card for the payment credential.
     */
    'cardType': string;
    /**
     * Three-digit ISO 4217 currency code for the payment credential.
     */
    'currencyCode'?: string;
    /**
     * Name of the card issuer for the payment credential.
     */
    'issuerName': string;
    /**
     * Name on the card for the payment credential.
     */
    'nameOnCard': string;
    /**
     * Indicates if a payment credential is a preferred Receiving, Sending, or Paying account.
     */
    'preferredFor'?: Array<AdsCardDetailsRequestPreferredForEnum>;
}

export const AdsCardDetailsRequestPreferredForEnum = {
    Receive: 'RECEIVE',
    Send: 'SEND',
    Paying: 'PAYING'
} as const;

export type AdsCardDetailsRequestPreferredForEnum = typeof AdsCardDetailsRequestPreferredForEnum[keyof typeof AdsCardDetailsRequestPreferredForEnum];

/**
 * Response containing the payment credential associated with a Visa ADS alias.
 */
export interface AdsCardResponse {
    /**
     * Account number of the payment instrument.
     */
    'accountNumber': string;
    /**
     * Type of account number associated with the payment credential.
     */
    'accountNumberType'?: AdsCardResponseAccountNumberTypeEnum;
    'billingAddress': AdsBillingAddress;
    /**
     * Type of card associated with the payment credential.
     */
    'cardType'?: string;
    /**
     * Date and time when the payment credential was created.
     */
    'createdOn'?: string;
    /**
     * Three-digit ISO 4217 currency code for the payment credential.
     */
    'currencyCode'?: string;
    /**
     * Expiration date of the card.
     */
    'expirationDate'?: string;
    /**
     * External ID of the payment credential, which corresponds to Marqetas card token.
     */
    'externalId'?: string;
    /**
     * Unique identifier of the payment credential generated by Alias Directory.
     */
    'id'?: string;
    /**
     * Name of the issuer of the payment credential.
     */
    'issuerName'?: string;
    /**
     * Last four digits of the card number.
     */
    'lastFourDigits'?: string;
    /**
     * Date and time when the payment credential was last updated.
     */
    'lastUpdatedOn'?: string;
    /**
     * Name on the card associated with the payment credential.
     */
    'nameOnCard'?: string;
    /**
     * Indicates if a payment credential is a preferred Receiving, Sending, or Paying account.  This array is returned if the payment credential is a preferred account.
     */
    'preferredFor'?: Array<AdsPreferredFor>;
    /**
     * Status of the payment credential.
     */
    'status'?: AdsCardResponseStatusEnum;
    /**
     * Type of payment credential associated with the Visa Alias.
     */
    'type': AdsCardResponseTypeEnum;
}

export const AdsCardResponseAccountNumberTypeEnum = {
    Pan: 'PAN',
    Niubiz: 'NIUBIZ',
    Token: 'TOKEN'
} as const;

export type AdsCardResponseAccountNumberTypeEnum = typeof AdsCardResponseAccountNumberTypeEnum[keyof typeof AdsCardResponseAccountNumberTypeEnum];
export const AdsCardResponseStatusEnum = {
    Active: 'ACTIVE',
    Blocked: 'BLOCKED',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED'
} as const;

export type AdsCardResponseStatusEnum = typeof AdsCardResponseStatusEnum[keyof typeof AdsCardResponseStatusEnum];
export const AdsCardResponseTypeEnum = {
    Card: 'CARD'
} as const;

export type AdsCardResponseTypeEnum = typeof AdsCardResponseTypeEnum[keyof typeof AdsCardResponseTypeEnum];

/**
 * Response containing the payment credential associated with a Visa ADS alias.
 */
export interface AdsCardResponseYaml {
    /**
     * Account number of the payment instrument.
     */
    'accountNumber': string;
    /**
     * Type of account number associated with the payment credential.
     */
    'accountNumberType'?: AdsCardResponseYamlAccountNumberTypeEnum;
    'billingAddress': AdsBillingAddress;
    /**
     * Type of card associated with the payment credential.
     */
    'cardType'?: string;
    /**
     * Date and time when the payment credential was created.
     */
    'createdOn'?: string;
    /**
     * Three-digit ISO 4217 currency code for the payment credential.
     */
    'currencyCode'?: string;
    /**
     * Expiration date of the card.
     */
    'expirationDate'?: string;
    /**
     * External ID of the payment credential, which corresponds to Marqetas card token.
     */
    'externalId'?: string;
    /**
     * Unique identifier of the payment credential generated by Alias Directory.
     */
    'id'?: string;
    /**
     * Name of the issuer of the payment credential.
     */
    'issuerName'?: string;
    /**
     * Last four digits of the card number.
     */
    'lastFourDigits'?: string;
    /**
     * Date and time when the payment credential was last updated.
     */
    'lastUpdatedOn'?: string;
    /**
     * Name on the card associated with the payment credential.
     */
    'nameOnCard'?: string;
    /**
     * Indicates if a payment credential is a preferred Receiving, Sending, or Paying account.  This array is returned if the payment credential is a preferred account.
     */
    'preferredFor'?: Array<AdsPreferredFor>;
    /**
     * Status of the payment credential.
     */
    'status'?: AdsCardResponseYamlStatusEnum;
    /**
     * Type of payment credential associated with the Visa Alias.
     */
    'type': AdsCardResponseYamlTypeEnum;
}

export const AdsCardResponseYamlAccountNumberTypeEnum = {
    Pan: 'PAN',
    Niubiz: 'NIUBIZ',
    Token: 'TOKEN'
} as const;

export type AdsCardResponseYamlAccountNumberTypeEnum = typeof AdsCardResponseYamlAccountNumberTypeEnum[keyof typeof AdsCardResponseYamlAccountNumberTypeEnum];
export const AdsCardResponseYamlStatusEnum = {
    Active: 'ACTIVE',
    Blocked: 'BLOCKED',
    Disabled: 'DISABLED',
    Expired: 'EXPIRED'
} as const;

export type AdsCardResponseYamlStatusEnum = typeof AdsCardResponseYamlStatusEnum[keyof typeof AdsCardResponseYamlStatusEnum];
export const AdsCardResponseYamlTypeEnum = {
    Card: 'CARD'
} as const;

export type AdsCardResponseYamlTypeEnum = typeof AdsCardResponseYamlTypeEnum[keyof typeof AdsCardResponseYamlTypeEnum];

/**
 * Response containing the payment credentials associated with a Visa Alias Directory Service (ADS) alias.
 */
export interface AdsCardsResponse {
    /**
     * Response containing the payment credentials associated with a Visa Alias.  This array is returned if the Visa Alias exists and one or more payment credentials are linked to it.
     */
    'GetPaymentCredentialsResponse'?: Array<AdsCardResponse>;
}
/**
 * Response containing the payment credentials associated with a Visa Alias Directory Service (ADS) alias.
 */
export interface AdsCardsResponseYaml {
    /**
     * Response containing the payment credentials associated with a Visa Alias.  This array is returned if the Visa Alias exists and one or more payment credentials are linked to it.
     */
    'GetPaymentCredentialsResponse'?: Array<AdsCardResponse>;
}
/**
 * Visa Alias Directory Service (ADS) consent information in the ADS profile.
 */
export interface AdsConsent {
    /**
     * Date and time when the validity of the Visa ADS consent ends.  This field is returned if it exists in the resource.
     */
    'expiryDateTime'?: string;
    /**
     * Intermediaries of the Visa ADS consent.
     */
    'intermediaries'?: Array<string>;
    /**
     * Presenter of the Visa Alias Directory Service (ADS) consent.
     */
    'presenter': string;
    /**
     * Date and time when the validity of the Visa ADS consent begins.
     */
    'validFromDateTime': string;
    /**
     * Version of the Visa ADS consent.
     */
    'version': string;
}
/**
 * Contact information in the Alias Directory Service (ADS) profile.  This array is returned if the Visa Alias\' contact information details exist.
 */
export interface AdsContactInfo {
    /**
     * Type of contact information in the Alias Directory Service (ADS) profile.
     */
    'type': AdsContactInfoTypeEnum;
    /**
     * Contact information value, which is the email address or phone number.
     */
    'value': string;
}

export const AdsContactInfoTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    DirectoryAliasid: 'DIRECTORY_ALIASID'
} as const;

export type AdsContactInfoTypeEnum = typeof AdsContactInfoTypeEnum[keyof typeof AdsContactInfoTypeEnum];

/**
 * Response containing the unique identifier of the additional alias generated by Alias Directory.
 */
export interface AdsCreateAdditionalAliasResponse {
    /**
     * UUID generated by Alias Directory, which identifies the Visa Alias.
     */
    'id': string;
}
/**
 * Request to create an additional alias.
 */
export interface AdsCreateAdditionalAliasesRequest {
    /**
     * The type of the additional alias
     */
    'type': AdsCreateAdditionalAliasesRequestTypeEnum;
    /**
     * A customer unique identifier that represents him in the payment ecosystem where the user move funds.
     */
    'value': string;
}

export const AdsCreateAdditionalAliasesRequestTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type AdsCreateAdditionalAliasesRequestTypeEnum = typeof AdsCreateAdditionalAliasesRequestTypeEnum[keyof typeof AdsCreateAdditionalAliasesRequestTypeEnum];

export interface AdsCreateAliasRequest {
    /**
     * Type of Visa Alias in the Alias Directory Service (ADS) profile. Visa supports phone and email as Visa Alias types that can be used in place of sensitive payment credentials details.
     */
    'aliasType': AdsCreateAliasRequestAliasTypeEnum;
    /**
     * Visa Alias value, which is the email address or phone number.
     */
    'aliasValue': string;
    'consent': AdsConsent;
    'identification'?: AdsIdentification;
    /**
     * List of payment credentials associated with the Visa Alias.  This array is returned if the Visa Alias exists and one or more payment credentials are linked to it.
     */
    'paymentCredentials': Array<AdsCardDetailsRequest>;
    'profile': AdsProfile;
    /**
     * Unique identifier of the user.
     */
    'userToken': string;
}

export const AdsCreateAliasRequestAliasTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE',
    DirectoryAliasid: 'DIRECTORY_ALIASID'
} as const;

export type AdsCreateAliasRequestAliasTypeEnum = typeof AdsCreateAliasRequestAliasTypeEnum[keyof typeof AdsCreateAliasRequestAliasTypeEnum];

/**
 * Response containing the unique identifier of the alias generated by Alias Directory.
 */
export interface AdsCreateAliasResponse {
    /**
     * External ID of the Visa Alias.
     */
    'externalId'?: string;
    /**
     * UUID generated by Alias Directory, which identifies the Visa Alias.
     */
    'id': string;
    /**
     * List of payment credentials associated with the Visa Alias.  This array is returned if the Visa Alias exists and one or more payment credentials are linked to it.
     */
    'paymentCredentials'?: Array<AdsPaymentCredentialsResponse>;
}
/**
 * Response containing the payment credential associated with a Visa ADS alias.
 */
export interface AdsCreateCardDetailsResponse {
    /**
     * External ID of the payment credential, which corresponds to Marqeta\'s card token.
     */
    'externalId'?: string;
    /**
     * UUID generated by Alias Directory, a utility used to identify the payment credential.
     */
    'id': string;
    /**
     * Indicates the type of payment credential.
     */
    'type': AdsCreateCardDetailsResponseTypeEnum;
}

export const AdsCreateCardDetailsResponseTypeEnum = {
    Card: 'CARD',
    Bank: 'BANK'
} as const;

export type AdsCreateCardDetailsResponseTypeEnum = typeof AdsCreateCardDetailsResponseTypeEnum[keyof typeof AdsCreateCardDetailsResponseTypeEnum];

/**
 * ADS create report request.
 */
export interface AdsCreateReportRequest {
    'filters': AdsReportFilters;
    /**
     * The format of the report
     */
    'format': string;
    /**
     * The type of the report
     */
    'reportType': AdsCreateReportRequestReportTypeEnum;
}

export const AdsCreateReportRequestReportTypeEnum = {
    DirectoryStatus: 'DIRECTORY_STATUS',
    PlatformRequests: 'PLATFORM_REQUESTS',
    ResolutionReconciliation: 'RESOLUTION_RECONCILIATION',
    DirectoryActivity: 'DIRECTORY_ACTIVITY',
    PaymentCredentialDetails: 'PAYMENT_CREDENTIAL_DETAILS'
} as const;

export type AdsCreateReportRequestReportTypeEnum = typeof AdsCreateReportRequestReportTypeEnum[keyof typeof AdsCreateReportRequestReportTypeEnum];

/**
 * Request to get a Visa Alias by external ID.
 */
export interface AdsGetByExternalIdRequest {
    /**
     * External ID of the Visa Alias.
     */
    'externalId': string;
    /**
     * The type of the Visa Alias
     */
    'type': AdsGetByExternalIdRequestTypeEnum;
}

export const AdsGetByExternalIdRequestTypeEnum = {
    Alias: 'ALIAS',
    PaymentCredential: 'PAYMENT_CREDENTIAL'
} as const;

export type AdsGetByExternalIdRequestTypeEnum = typeof AdsGetByExternalIdRequestTypeEnum[keyof typeof AdsGetByExternalIdRequestTypeEnum];

/**
 * Response for retrieve by external ID request.
 */
export interface AdsGetByExternalIdResponse {
    /**
     * The list of associated Visa Alias IDs
     */
    'associatedIds': Array<AdsAssociatedIds>;
    /**
     * UUID generated by Alias Directory, which identifies the Visa Alias.
     */
    'id'?: string;
}
/**
 * Response containing the status of the report.
 */
export interface AdsGetReportStatusResponse {
    /**
     * The timestamp when the report was created in ISO UTC format YYYY-MM-DDThh:mm:ss.000Z
     */
    'creationDateTime'?: string;
    /**
     * The data classification of the report
     */
    'dataClassification'?: string;
    /**
     * The timestamp after which the report won\'t be available for download in ISO UTC format YYYY-MM-DDThh:mm:ss.000Z
     */
    'expirationDateTime'?: string;
    /**
     * The UUIDs of the files generated by the report.
     */
    'fileIds'?: Array<string>;
    /**
     * The format of the report
     */
    'format'?: string;
    /**
     * UUID generated by Alias Directory, which identifies the Visa Alias.
     */
    'id'?: string;
    /**
     * The type of the report
     */
    'reportType'?: AdsGetReportStatusResponseReportTypeEnum;
    /**
     * Indicates the status of the report.
     */
    'status'?: AdsGetReportStatusResponseStatusEnum;
}

export const AdsGetReportStatusResponseReportTypeEnum = {
    PlatformRequests: 'PLATFORM_REQUESTS',
    DirectoryStatus: 'DIRECTORY_STATUS',
    PaymentCredentialDetails: 'PAYMENT_CREDENTIAL_DETAILS'
} as const;

export type AdsGetReportStatusResponseReportTypeEnum = typeof AdsGetReportStatusResponseReportTypeEnum[keyof typeof AdsGetReportStatusResponseReportTypeEnum];
export const AdsGetReportStatusResponseStatusEnum = {
    Created: 'CREATED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED'
} as const;

export type AdsGetReportStatusResponseStatusEnum = typeof AdsGetReportStatusResponseStatusEnum[keyof typeof AdsGetReportStatusResponseStatusEnum];

/**
 * Identification of the user associated with the Visa Alias.
 */
export interface AdsIdentification {
    /**
     * Type of identification provided by the user associated with the Visa Alias.
     */
    'type': AdsIdentificationTypeEnum;
    /**
     * Value of the identification provided by the user associated with the Visa Alias, which is used to validate the user. Passport number, for example.
     */
    'value': string;
    'verificationDetails'?: AdsVerificationDetails;
}

export const AdsIdentificationTypeEnum = {
    Dni: 'DNI',
    Ce: 'CE',
    Passport: 'PASSPORT',
    Ptp: 'PTP',
    Ffpp: 'FFPP',
    Ffaa: 'FFAA',
    Ccd: 'CCD',
    Coi: 'COI',
    Pn: 'PN',
    Cie: 'CIE',
    Cpf: 'CPF',
    Dl: 'DL',
    Dpi: 'DPI',
    Nidn: 'NIDN'
} as const;

export type AdsIdentificationTypeEnum = typeof AdsIdentificationTypeEnum[keyof typeof AdsIdentificationTypeEnum];

/**
 * Response containing the details of a payment credential.
 */
export interface AdsPaymentCredentialsResponse {
    /**
     * External ID of the Visa Alias.
     */
    'externalId'?: string;
    /**
     * UUID generated by Alias Directory, which identifies the Visa Alias.
     */
    'id': string;
    /**
     * The type of payment credential
     */
    'type': AdsPaymentCredentialsResponseTypeEnum;
}

export const AdsPaymentCredentialsResponseTypeEnum = {
    Card: 'CARD',
    Bank: 'BANK'
} as const;

export type AdsPaymentCredentialsResponseTypeEnum = typeof AdsPaymentCredentialsResponseTypeEnum[keyof typeof AdsPaymentCredentialsResponseTypeEnum];

/**
 * Details of the operation.
 */
export interface AdsPreferredFor {
    /**
     * Date of the Receiving, Sending, or Paying operation.
     */
    'date'?: string;
    /**
     * Type of operation.
     */
    'type': AdsPreferredForTypeEnum;
}

export const AdsPreferredForTypeEnum = {
    Receive: 'RECEIVE',
    Send: 'SEND',
    Pay: 'PAY'
} as const;

export type AdsPreferredForTypeEnum = typeof AdsPreferredForTypeEnum[keyof typeof AdsPreferredForTypeEnum];

/**
 * Alias Directory Service (ADS) profile information.
 */
export interface AdsProfile {
    /**
     * Contact information in the Alias Directory Service (ADS) profile.  This array is returned if the Visa Alias\' contact information details exist.
     */
    'contactInfo'?: Array<AdsContactInfo>;
    /**
     * Date of birth in the Alias Directory Service (ADS) profile.  This field is returned if it exists in the resource.
     */
    'dateOfBirth'?: string;
    /**
     * First name in the Alias Directory Service (ADS) profile.
     */
    'firstName': string;
    /**
     * First name in the Alias Directory Service (ADS) profile, expressed in the user\'s local language.  This field is returned if it exists in the resource.
     */
    'firstNameLocal'?: string;
    /**
     * Last name in the Alias Directory Service (ADS) profile.
     */
    'lastName': string;
    /**
     * Last name in the Alias Directory Service (ADS) profile, expressed in the user\'s local language.  This field is returned if it exists in the resource.
     */
    'lastNameLocal'?: string;
    /**
     * Middle name in the Alias Directory Service (ADS) profile.  This field is returned if it exists in the resource.
     */
    'middleName'?: string;
    /**
     * Middle name in the Alias Directory Service (ADS) profile, expressed in the user\'s local language.  This field is returned if it exists in the resource.
     */
    'middleNameLocal'?: string;
    /**
     * Preferred name in the Alias Directory Service (ADS) profile, as provided by the user.  This field is returned if it exists in the resource.
     */
    'preferredName'?: string;
}
/**
 * The response schema for the ADS report file.
 */
export interface AdsReportFileResponse {
    /**
     * The type of the operation
     */
    'operationType'?: string;
    /**
     * The number of operations in the report
     */
    'operationsCount'?: number;
    /**
     * The Originator Actor Id
     */
    'originatorActorId'?: string;
    /**
     * The program ID
     */
    'programId'?: string;
    /**
     * The status code of the operation
     */
    'statusCode'?: number;
}
/**
 * Filters for the report.
 */
export interface AdsReportFilters {
    'aliasStatuses': Array<AdsReportFiltersAliasStatusesEnum>;
    /**
     * Type of Visa Alias in the Alias Directory Service (ADS) profile. Visa supports phone and email as Visa Alias types that can be used in place of sensitive payment credentials details.
     */
    'aliasType': AdsReportFiltersAliasTypeEnum;
    'billingEventTypes'?: Array<string>;
    /**
     * Date when the report ends in ISO UTC format YYYY-MM-DDThh:mm:ss.000Z
     */
    'endDate': string;
    /**
     * Date when the report starts in ISO UTC format YYYY-MM-DDThh:mm:ss.000Z
     */
    'startDate': string;
}

export const AdsReportFiltersAliasStatusesEnum = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Blocked: 'BLOCKED',
    Expired: 'EXPIRED',
    Deleted: 'DELETED'
} as const;

export type AdsReportFiltersAliasStatusesEnum = typeof AdsReportFiltersAliasStatusesEnum[keyof typeof AdsReportFiltersAliasStatusesEnum];
export const AdsReportFiltersAliasTypeEnum = {
    Email: 'EMAIL',
    Phone: 'PHONE'
} as const;

export type AdsReportFiltersAliasTypeEnum = typeof AdsReportFiltersAliasTypeEnum[keyof typeof AdsReportFiltersAliasTypeEnum];

/**
 * Ads update alias request.
 */
export interface AdsUpdateAliasRequest {
    'consent': AdsConsent;
    'identification'?: AdsIdentification;
    'profile': AdsProfile;
}
/**
 * Verification details associated with the Visa Alias.  This field is returned if it exists in the resource.
 */
export interface AdsVerificationDetails {
    /**
     * Time when the user provided the credentials for verification in ISO UTC format YYYY-MM-DDThh:mm:ss.000Z
     */
    'authDateTime'?: string;
    /**
     * Authentication method used when the user provided the credentials for verification, in ISO UTC format YYYY-MM-DDThh:mm:ss.000Z
     */
    'authMethodReference'?: string;
    /**
     * Time when the user was created or enrolled in ISO UTC format YYYY-MM-DDThh:mm:ss.000Z
     */
    'creationDateTime'?: string;
    /**
     * True if an email was verified during the verification process. This email does not need to match the Alias or contact info if an email was used.
     */
    'verifiedEmail'?: boolean;
    /**
     * True if a phone number was verified during the verification process. This phone number does not need to match the Alias or contact info if a phone number was used.
     */
    'verifiedPhone'?: boolean;
}
/**
 * Contains information about airline-related transactions.
 */
export interface Airline {
    /**
     * The date and time of departure.
     */
    'depart_date'?: string;
    /**
     * The city where the flight originates.
     */
    'origination_city'?: string;
    /**
     * The name of the passenger.
     */
    'passenger_name'?: string;
}
/**
 * Specifies the cardholder address.
 */
export interface AndroidPushTokenRequestAddress {
    /**
     * Street address of the cardholder.
     */
    'address1'?: string;
    /**
     * Additional address information for the cardholder, such as a suite or apartment number.  `Suite 600`, for example.
     */
    'address2'?: string;
    /**
     * City of the cardholder.
     */
    'city'?: string;
    /**
     * Two-character link:https://www.iso.org/iso-3166-country-codes.html[ISO alpha-2 country code, window=\"_blank\"]. `US`, for example.
     */
    'country'?: string;
    /**
     * Name of the cardholder.
     */
    'name'?: string;
    /**
     * Telephone number of the cardholder.
     */
    'phone'?: string;
    /**
     * Postal code of the cardholder, such as a United States ZIP code. `94612`, for example.
     */
    'postal_code'?: string;
    /**
     * Two-character state, provincial, or territorial abbreviation.  For the complete list, see <</core-api/kyc-verification#_valid_state_provincial_territorial_and_federal_abbreviations, Valid state, provincial, territorial, and federal abbreviations>>.
     */
    'state'?: string;
    'zip'?: string;
}
/**
 * Contains details about a card tokenization push request.
 */
export interface AndroidPushTokenizeRequestData {
    /**
     * Name of the card as displayed in the digital wallet, typically showing the card brand and last four digits of the primary account number (PAN). `Visa 5678`, for example.
     */
    'display_name'?: string;
    /**
     * Last four digits of the primary account number of the physical or virtual card.
     */
    'last_digits'?: string;
    /**
     * Specifies the card network of the physical or virtual card.
     */
    'network'?: string;
    /**
     * Encrypted data field created by the issuer and passed to Google Wallet during the push provisioning process.
     */
    'opaque_payment_card'?: string;
    /**
     * Specifies the network that provides the digital wallet token service.
     */
    'token_service_provider'?: string;
    'user_address'?: AndroidPushTokenRequestAddress;
}
/**
 * Contains account name verification data used to make JIT Funding decisions.
 */
export interface AniInformation {
    'card_name'?: string;
    /**
     * First or given name of the cardholder.
     */
    'first_name'?: string;
    /**
     * Last or family name of the cardholder.
     */
    'last_name'?: string;
    /**
     * Middle name of the cardholder.
     */
    'middle_name'?: string;
}
/**
 * Contains client application information.
 */
export interface Application {
    /**
     * Access code of the client application.
     */
    'access_code'?: string;
    /**
     * URL of the client application assets.
     */
    'assets_url'?: string;
    /**
     * Base URL of the client API.
     */
    'client_api_base_url'?: string;
    /**
     * Client application\'s environment.
     */
    'environment'?: string;
    /**
     * Name of the program on the Marqeta platform.
     */
    'program'?: string;
    /**
     * Short code of the program on the Marqeta platform.
     */
    'program_short_code'?: string;
    /**
     * Unique identifier of the `application` object.
     */
    'token'?: string;
}
export interface AprScheduleEntryResponse {
    /**
     * Whether the APR is ignored for the current billing cycle and applied on the next.
     */
    'apply_next_cycle'?: boolean;
    /**
     * Date and time when the APR goes into effect, in UTC.
     */
    'effective_date'?: string;
    /**
     * Number of percentage points added to the prime rate, used to calculate a variable value.  Used for variable values only.
     */
    'margin'?: number;
    /**
     * Indicates whether the APR value is fixed or variable.
     */
    'type'?: AprScheduleEntryResponseTypeEnum;
    /**
     * Percentage value of the APR.  If the APR type is `FIXED`, this is the value of the fixed rate. If the APR type is `VARIABLE`, the value is calculated by adding the margin to the prime rate that was stored on Marqeta\'s credit platform when your credit program was created.  When backdating an APR, this value cannot be greater than the value of the effective APR on the backdated date.
     */
    'value': number;
}

export const AprScheduleEntryResponseTypeEnum = {
    Fixed: 'FIXED',
    Variable: 'VARIABLE'
} as const;

export type AprScheduleEntryResponseTypeEnum = typeof AprScheduleEntryResponseTypeEnum[keyof typeof AprScheduleEntryResponseTypeEnum];

export interface AprScheduleEntryUpdateReq {
    /**
     * Whether the APR can be ignored for the current billing cycle and applied on the next.
     */
    'apply_next_cycle'?: boolean;
    /**
     * Date and time when the APR goes into effect, in UTC.  If you do not include a date-time value, the system uses the date and time when the API request was received.  *NOTE:* When passing multiple `schedule` objects, this field is required in all objects but the first. If you do not include `effective_date` in the first `schedule`, the system uses the date and time when the API request was received.
     */
    'effective_date'?: string;
    /**
     * Number of percentage points added to the prime rate, used to calculate a variable value.  Used for variable values only.
     */
    'margin'?: number;
    /**
     * Indicates whether the APR value is fixed or variable.
     */
    'type'?: AprScheduleEntryUpdateReqTypeEnum;
    /**
     * Percentage value of the APR.  If the APR type is `FIXED`, this is the value of the fixed rate. If the APR type is `VARIABLE`, the value is calculated by adding the margin to the prime rate that was stored on Marqeta\'s credit platform when your credit program was created.  When backdating an APR, this value cannot be greater than the value of the effective APR on the backdated date.
     */
    'value': number;
}

export const AprScheduleEntryUpdateReqTypeEnum = {
    Fixed: 'FIXED',
    Variable: 'VARIABLE'
} as const;

export type AprScheduleEntryUpdateReqTypeEnum = typeof AprScheduleEntryUpdateReqTypeEnum[keyof typeof AprScheduleEntryUpdateReqTypeEnum];

export interface AprScheduleResponse {
    /**
     * Whether the APR is active.
     */
    'active'?: boolean;
    /**
     * Date and time when the APR was created on Marqeta\'s credit platform, in UTC.
     */
    'created_date'?: string;
    /**
     * Contains one or more `schedule` objects, which contain information about the annual percentage rates (APRs) associated with the type of balance on the credit account and when they are effective.
     */
    'schedule': Array<AprScheduleEntryResponse>;
    'type': AccountAprType;
    /**
     * Date and time when the APR was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_date'?: string;
}


export interface AprScheduleUpdateReq {
    /**
     * Contains one or more `schedule` objects, which contain information about the annual percentage rates (APRs) associated with the type of balance on the credit account and when they are effective.
     */
    'schedule': Array<AprScheduleEntryUpdateReq>;
    'type': AccountAprType;
}


/**
 * Defines to which the velocity control applies.
 */
export interface Association {
    /**
     * Unique identifier of the card group.
     */
    'card_group_token'?: string;
}
export interface AtcInformation {
    'atc_discrepancy_indicator'?: string;
    'atc_discrepancy_value'?: number;
    'atc_value'?: number;
}
export interface AuthControlExemptMidsListResponse {
    'count'?: number;
    'data'?: Array<AuthControlExemptMidsResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface AuthControlExemptMidsRequest {
    'association'?: SpendControlAssociation;
    'end_time'?: string;
    /**
     * 36 char max
     */
    'merchant_group_token'?: string;
    'mid'?: string;
    'name': string;
    'start_time'?: string;
    'token'?: string;
}
export interface AuthControlExemptMidsResponse {
    'active'?: boolean;
    'association'?: SpendControlAssociation;
    'created'?: string;
    'end_time'?: string;
    'last_updated'?: string;
    /**
     * 36 char max
     */
    'merchant_group_token'?: string;
    'mid'?: string;
    'name': string;
    'start_time'?: string;
    'token'?: string;
}
export interface AuthControlExemptMidsUpdateRequest {
    'active'?: boolean;
}
export interface AuthControlListResponse {
    'count'?: number;
    'data'?: Array<AuthControlResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface AuthControlMerchantScope {
    /**
     * 4 char max
     */
    'mcc'?: string;
    /**
     * 36 char max
     */
    'mcc_group'?: string;
    /**
     * 36 char max
     */
    'merchant_group_token'?: string;
    /**
     * 36 char max
     */
    'mid'?: string;
}
export interface AuthControlRequest {
    'active'?: boolean;
    'association'?: SpendControlAssociation;
    'end_time'?: string;
    'merchant_scope'?: AuthControlMerchantScope;
    'name': string;
    'start_time'?: string;
    'token'?: string;
}
export interface AuthControlResponse {
    'active'?: boolean;
    'association'?: SpendControlAssociation;
    'end_time'?: string;
    'merchant_scope'?: AuthControlMerchantScope;
    'name': string;
    'start_time'?: string;
    'token'?: string;
}
export interface AuthControlUpdateRequest {
    'active'?: boolean;
    'association'?: SpendControlAssociation;
    'end_time'?: string;
    'merchant_scope'?: MerchantScope;
    'name'?: string;
    'start_time'?: string;
    'token': string;
}
export interface AuthControls {
    'hold_expiration_days'?: number;
    'hold_increase'?: HoldIncrease;
}
export interface AuthRequestModel {
    'amount': number;
    'card_acceptor'?: CardAcceptorModel;
    'card_options'?: CardOptions;
    'card_token': string;
    'cash_back_amount'?: number;
    'is_pre_auth'?: boolean;
    'mid': string;
    'network_fees'?: Array<NetworkFeeModel>;
    'network_metadata'?: NetworkMetadata;
    'pin'?: string;
    'transaction_options'?: TransactionOptions;
    'webhook'?: Webhook;
}
/**
 * Contains the cardholder\'s email address and password information.
 */
export interface Authentication {
    /**
     * Specifies whether the email address has been verified.
     */
    'email_verified'?: boolean;
    /**
     * Date and time when the email address was verified.
     */
    'email_verified_time'?: string;
    /**
     * Specifies the channel through which the password was last changed.
     */
    'last_password_update_channel'?: AuthenticationLastPasswordUpdateChannelEnum;
    /**
     * Date and time when the password was last changed.
     */
    'last_password_update_time'?: string;
}

export const AuthenticationLastPasswordUpdateChannelEnum = {
    UserChange: 'USER_CHANGE',
    UserReset: 'USER_RESET'
} as const;

export type AuthenticationLastPasswordUpdateChannelEnum = typeof AuthenticationLastPasswordUpdateChannelEnum[keyof typeof AuthenticationLastPasswordUpdateChannelEnum];

export interface AuthorizationAdviceModel {
    'amount': number;
    'network_fees'?: Array<NetworkFeeModel>;
    'original_transaction_token': string;
    'transaction_options'?: TransactionOptions;
    'webhook'?: Webhook;
}
export interface AutoCommandoModeProgramFundingSourceResponse {
    'account': string;
    'active'?: boolean;
    'created_time': string;
    'last_modified_time': string;
    'name': string;
    'token': string;
}
/**
 * Specifies the scope of the auto reload.  Input no more than one field. If no value is supplied, the auto reload applies at the program level.
 */
export interface AutoReloadAssociation {
    'account_template_token'?: string;
    /**
     * Unique identifier of the business for which the auto reload is configured.  Send a `GET` request to `/businesses` to retrieve business tokens.
     */
    'business_token'?: string;
    /**
     * Unique identifier of the card product for which the auto reload is configured.  Send a `GET` request to `/cardproducts` to retrieve card product tokens.
     */
    'card_product_token'?: string;
    /**
     * Unique identifier of the user for which the auto reload is configured.  Send a `GET` request to `/users` to retrieve user tokens.
     */
    'user_token'?: string;
}
export interface AutoReloadListResponse {
    'count'?: number;
    'data'?: Array<AutoReloadResponseModel>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
/**
 * Contains information about an auto reload. See <</core-api/auto-reload, Auto Reloads>> for more information.  Returned if an auto reload was executed.
 */
export interface AutoReloadModel {
    /**
     * Specifies whether the auto reload is active.  Only one auto reload per level, per object, can be active.
     */
    'active'?: boolean;
    'association'?: AutoReloadAssociation;
    /**
     * Three-digit link:https://www.iso.org/iso-4217-currency-codes.html[ISO 4217 currency code, window=\"_blank\"].
     */
    'currency_code': string;
    /**
     * Unique identifier of the funding source address to use for this auto reload.  If your funding source is an ACH account, then a `funding_source_address_token` is not required. If your funding source is a payment card, you must have at least one funding source address in order to create a GPA order.  Send a `GET` request to `/fundingsources/addresses/user/{user_token}` to retrieve address tokens for a user.  Send a `GET` request to `/fundingsources/addresses/business/{business_token}` to retrieve address tokens for a business.
     */
    'funding_source_address_token'?: string;
    /**
     * Unique identifier of the funding source to use for this auto reload.  Send a `GET` request to `/fundingsources/user/{user_token}` to retrieve funding source tokens for a user.  Send a `GET` request to `/fundingsources/business/{business_token}` to retrieve funding source tokens for a business.
     */
    'funding_source_token'?: string;
    'order_scope': OrderScope;
    /**
     * Unique identifier of the auto reload.  If you do not include a token, the system will generate one automatically. This token is necessary for use in other API calls, so we recommend that rather than let the system generate one, you use a simple string that is easy to remember. This value cannot be updated.
     */
    'token'?: string;
}
export interface AutoReloadResponseModel {
    'active'?: boolean;
    'association'?: AutoReloadAssociation;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'currency_code': string;
    'funding_source_address_token'?: string;
    /**
     * Required when order scope is GPA
     */
    'funding_source_token'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'order_scope': OrderScope;
    'token'?: string;
}
export interface AutoReloadUpdateModel {
    'active'?: boolean;
    'association'?: AutoReloadAssociation;
    'currency_code'?: string;
    'funding_source_address_token'?: string;
    'funding_source_token'?: string;
    'order_scope'?: OrderScope;
    'token'?: string;
}
/**
 * Specifies the available balances of the velocity controls associated with a user.  This object is not returned if the velocity control window is `TRANSACTION`, because available balances do not apply to single-transaction velocity windows.
 */
export interface Available {
    /**
     * Total amount of spend remaining in the velocity control.
     */
    'amount': number;
    /**
     * Number of days remaining in the velocity control time window.
     */
    'days_remaining'?: number;
    /**
     * Number of uses remaining in the velocity control.
     */
    'uses': number;
}
export interface AvsControlOptions {
    'decline_on_address_number_mismatch'?: boolean;
    'decline_on_postal_code_mismatch'?: boolean;
    'validate'?: boolean;
}
export interface AvsControls {
    'auth_messages'?: AvsControlOptions;
    'av_messages'?: AvsControlOptions;
}
/**
 * Contains address verification information.
 */
export interface AvsInformation {
    /**
     * Postal code of the address.
     */
    'postal_code'?: string;
    /**
     * Street name and number of the address.
     */
    'street_address'?: string;
    /**
     * United States ZIP code of the address.
     */
    'zip'?: string;
}
export interface BadRequestError {
    'error_code': BadRequestErrorErrorCodeEnum;
    'error_message': string;
}

export const BadRequestErrorErrorCodeEnum = {
    _400: '400'
} as const;

export type BadRequestErrorErrorCodeEnum = typeof BadRequestErrorErrorCodeEnum[keyof typeof BadRequestErrorErrorCodeEnum];

export interface BalanceInquiryRequestModel {
    'account_type': BalanceInquiryRequestModelAccountTypeEnum;
    'card_acceptor': CardAcceptorModel;
    'card_token': string;
    'mid': string;
    'network_fees'?: Array<NetworkFeeModel>;
    'pin'?: string;
    'webhook'?: Webhook;
}

export const BalanceInquiryRequestModelAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    Credit: 'credit'
} as const;

export type BalanceInquiryRequestModelAccountTypeEnum = typeof BalanceInquiryRequestModelAccountTypeEnum[keyof typeof BalanceInquiryRequestModelAccountTypeEnum];

/**
 * Type of balance.  * `PURCHASE` - The balance on purchases.
 */

export const BalanceType = {
    Purchase: 'PURCHASE'
} as const;

export type BalanceType = typeof BalanceType[keyof typeof BalanceType];


export interface BankAccountFundingSourceModel extends FundingSourceModel {
    'account_suffix': string;
    'account_type': string;
    /**
     * Required if \'user_token\' is null
     */
    'business_token'?: string;
    'name_on_account': string;
    'routing_number': string;
    /**
     * Required if \'business_token\' is null
     */
    'user_token'?: string;
    'verification_status': string;
}
export interface BankTransferListResponse {
    'count'?: number;
    'data'?: Array<BankTransferResponseModel>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface BankTransferRequestModel {
    'amount': number;
    /**
     * default = API
     */
    'channel'?: BankTransferRequestModelChannelEnum;
    'created_by'?: string;
    /**
     * default = USD
     */
    'currency_code'?: string;
    'funding_source_token': string;
    'memo'?: string;
    'standard_entry_class_code'?: BankTransferRequestModelStandardEntryClassCodeEnum;
    'statement_descriptor'?: string;
    'token'?: string;
    /**
     * default = STANDARD
     */
    'transfer_speed'?: BankTransferRequestModelTransferSpeedEnum;
    'type': BankTransferRequestModelTypeEnum;
}

export const BankTransferRequestModelChannelEnum = {
    Api: 'API',
    System: 'SYSTEM',
    Admin: 'ADMIN'
} as const;

export type BankTransferRequestModelChannelEnum = typeof BankTransferRequestModelChannelEnum[keyof typeof BankTransferRequestModelChannelEnum];
export const BankTransferRequestModelStandardEntryClassCodeEnum = {
    Web: 'WEB',
    Ppd: 'PPD',
    Ccd: 'CCD'
} as const;

export type BankTransferRequestModelStandardEntryClassCodeEnum = typeof BankTransferRequestModelStandardEntryClassCodeEnum[keyof typeof BankTransferRequestModelStandardEntryClassCodeEnum];
export const BankTransferRequestModelTransferSpeedEnum = {
    Standard: 'STANDARD',
    SameDay: 'SAME_DAY'
} as const;

export type BankTransferRequestModelTransferSpeedEnum = typeof BankTransferRequestModelTransferSpeedEnum[keyof typeof BankTransferRequestModelTransferSpeedEnum];
export const BankTransferRequestModelTypeEnum = {
    Push: 'PUSH',
    Pull: 'PULL'
} as const;

export type BankTransferRequestModelTypeEnum = typeof BankTransferRequestModelTypeEnum[keyof typeof BankTransferRequestModelTypeEnum];

export interface BankTransferResponseModel {
    'amount': number;
    'batch_number'?: string;
    /**
     * default = API
     */
    'channel'?: BankTransferResponseModelChannelEnum;
    'created_by'?: string;
    'created_time'?: string;
    /**
     * default = USD
     */
    'currency_code'?: string;
    'funding_source_token': string;
    'is_early_funded'?: boolean;
    'last_modified_time'?: string;
    'memo'?: string;
    'return_code'?: string;
    'return_reason'?: string;
    'standard_entry_class_code'?: BankTransferResponseModelStandardEntryClassCodeEnum;
    'statement_descriptor'?: string;
    'status'?: BankTransferResponseModelStatusEnum;
    'token'?: string;
    /**
     * default = STANDARD
     */
    'transfer_speed'?: BankTransferResponseModelTransferSpeedEnum;
    'transitions'?: Array<BankTransferTransitionResponseModel>;
    'type': BankTransferResponseModelTypeEnum;
}

export const BankTransferResponseModelChannelEnum = {
    Api: 'API',
    System: 'SYSTEM',
    Admin: 'ADMIN'
} as const;

export type BankTransferResponseModelChannelEnum = typeof BankTransferResponseModelChannelEnum[keyof typeof BankTransferResponseModelChannelEnum];
export const BankTransferResponseModelStandardEntryClassCodeEnum = {
    Web: 'WEB',
    Ppd: 'PPD',
    Ccd: 'CCD'
} as const;

export type BankTransferResponseModelStandardEntryClassCodeEnum = typeof BankTransferResponseModelStandardEntryClassCodeEnum[keyof typeof BankTransferResponseModelStandardEntryClassCodeEnum];
export const BankTransferResponseModelStatusEnum = {
    Initiated: 'INITIATED',
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Returned: 'RETURNED',
    Completed: 'COMPLETED',
    Error: 'ERROR',
    Cancelled: 'CANCELLED',
    ReversalPend: 'REVERSAL_PEND',
    ReversalComp: 'REVERSAL_COMP',
    ReversalDecl: 'REVERSAL_DECL'
} as const;

export type BankTransferResponseModelStatusEnum = typeof BankTransferResponseModelStatusEnum[keyof typeof BankTransferResponseModelStatusEnum];
export const BankTransferResponseModelTransferSpeedEnum = {
    Standard: 'STANDARD',
    SameDay: 'SAME_DAY'
} as const;

export type BankTransferResponseModelTransferSpeedEnum = typeof BankTransferResponseModelTransferSpeedEnum[keyof typeof BankTransferResponseModelTransferSpeedEnum];
export const BankTransferResponseModelTypeEnum = {
    Push: 'PUSH',
    Pull: 'PULL'
} as const;

export type BankTransferResponseModelTypeEnum = typeof BankTransferResponseModelTypeEnum[keyof typeof BankTransferResponseModelTypeEnum];

export interface BankTransferTransitionListResponse {
    'count'?: number;
    'data'?: Array<BankTransferTransitionResponseModel>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface BankTransferTransitionRequestModel {
    'amount'?: number;
    'bank_transfer_token': string;
    'batch_number'?: string;
    'channel': BankTransferTransitionRequestModelChannelEnum;
    'effective_date'?: string;
    'program_reserve_token'?: string;
    'reason'?: string;
    'return_code'?: string;
    'reversal_after_45_days'?: boolean;
    'status': BankTransferTransitionRequestModelStatusEnum;
    'token'?: string;
}

export const BankTransferTransitionRequestModelChannelEnum = {
    Api: 'API',
    System: 'SYSTEM',
    Admin: 'ADMIN'
} as const;

export type BankTransferTransitionRequestModelChannelEnum = typeof BankTransferTransitionRequestModelChannelEnum[keyof typeof BankTransferTransitionRequestModelChannelEnum];
export const BankTransferTransitionRequestModelStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Returned: 'RETURNED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    ReversalPend: 'REVERSAL_PEND',
    ReversalComp: 'REVERSAL_COMP'
} as const;

export type BankTransferTransitionRequestModelStatusEnum = typeof BankTransferTransitionRequestModelStatusEnum[keyof typeof BankTransferTransitionRequestModelStatusEnum];

export interface BankTransferTransitionResponseModel {
    'amount'?: number;
    'bank_transfer_token': string;
    'batch_number'?: string;
    'channel': BankTransferTransitionResponseModelChannelEnum;
    'created_time'?: string;
    'effective_date'?: string;
    'last_modified_time'?: string;
    'program_reserve_token'?: string;
    'reason'?: string;
    'return_code'?: string;
    'return_reason'?: string;
    'reversal_after_45_days'?: boolean;
    'status': BankTransferTransitionResponseModelStatusEnum;
    'token'?: string;
    'transaction_jit_token'?: string;
    'transaction_token'?: string;
}

export const BankTransferTransitionResponseModelChannelEnum = {
    Api: 'API',
    System: 'SYSTEM',
    Admin: 'ADMIN'
} as const;

export type BankTransferTransitionResponseModelChannelEnum = typeof BankTransferTransitionResponseModelChannelEnum[keyof typeof BankTransferTransitionResponseModelChannelEnum];
export const BankTransferTransitionResponseModelStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Returned: 'RETURNED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    ReversalPend: 'REVERSAL_PEND',
    ReversalComp: 'REVERSAL_COMP'
} as const;

export type BankTransferTransitionResponseModelStatusEnum = typeof BankTransferTransitionResponseModelStatusEnum[keyof typeof BankTransferTransitionResponseModelStatusEnum];

export interface BaseAchRequestModel {
    'account_number': string;
    'account_type': BaseAchRequestModelAccountTypeEnum;
    'bank_name'?: string;
    'is_default_account'?: boolean;
    'name_on_account': string;
    'routing_number': string;
    'token'?: string;
    'verification_notes'?: string;
    'verification_override'?: boolean;
}

export const BaseAchRequestModelAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    Corporate: 'corporate',
    Loan: 'loan'
} as const;

export type BaseAchRequestModelAccountTypeEnum = typeof BaseAchRequestModelAccountTypeEnum[keyof typeof BaseAchRequestModelAccountTypeEnum];

export interface BaseAchResponseModel {
    'account_suffix': string;
    'account_type': string;
    'active': boolean;
    'bank_name'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'date_sent_for_verification'?: string;
    'date_verified'?: string;
    'is_default_account'?: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'name_on_account': string;
    'partner'?: string;
    'partner_account_link_reference_token'?: string;
    'token': string;
    'verification_notes'?: string;
    'verification_override'?: boolean;
    'verification_status'?: string;
}
export interface BeneficialOwnerRequest {
    'birth_place'?: string;
    'dob'?: string;
    'email'?: string;
    'first_name'?: string;
    'home'?: AddressRequestModel;
    'identifications'?: Array<IdentificationRequestModel>;
    'last_name'?: string;
    'middle_name'?: string;
    'nationality'?: string;
    'ownership_percentage'?: string;
    'phone'?: string;
    'ssn'?: string;
    'title'?: string;
}
export interface BeneficialOwnerResponse {
    'birth_place'?: string;
    'email'?: string;
    'first_name'?: string;
    'getdob'?: string;
    'home'?: AddressResponseModel;
    'identifications'?: Array<IdentificationResponseModel>;
    'last_name'?: string;
    'middle_name'?: string;
    'nationality'?: string;
    'ownership_percentage'?: string;
    'phone'?: string;
    'ssn'?: string;
    'title'?: string;
}
export interface BillPayResponse {
    'amount'?: string;
    'biller_token'?: string;
    'created_time'?: string;
    'delivery_date'?: string;
    'last_modified_time'?: string;
    'payment_token'?: string;
    'payment_type'?: string;
    'processing_date'?: string;
    'status'?: string;
    'user_token'?: string;
}
export interface BillingAddress {
    'address'?: string;
    'compressed_zip'?: string;
    'first_name'?: string;
    'last_name'?: string;
    'zip'?: string;
}
export interface BinPrefixRequest {
    /**
     * 6-14 digit BIN prefix
     */
    'bin_prefix': string;
    /**
     * Status of this BIN prefix
     */
    'status': BinPrefixRequestStatusEnum;
}

export const BinPrefixRequestStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type BinPrefixRequestStatusEnum = typeof BinPrefixRequestStatusEnum[keyof typeof BinPrefixRequestStatusEnum];

export interface BulkCardOrderListResponse {
    'count'?: number;
    'data'?: Array<BulkIssuanceResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface BulkIssuanceRequest {
    'card_allocation': number;
    'card_product_token': string;
    'expedite'?: boolean;
    'expiration_offset'?: ExpirationOffset;
    'fulfillment': FulfillmentRequest;
    'name_line_1_numeric_postfix'?: boolean;
    'name_line_1_random_postfix'?: boolean;
    'token': string;
    'user_association'?: UserAssociation;
}
export interface BulkIssuanceResponse {
    'card_allocation': number;
    'card_fulfillment_time'?: string;
    'card_product_token': string;
    'cards_processed'?: number;
    'created_time'?: string;
    'expedite'?: boolean;
    'expiration_offset'?: ExpirationOffset;
    'fulfillment': FulfillmentResponse;
    'name_line1_end_index'?: number;
    'name_line1_start_index'?: number;
    'name_line_1_numeric_postfix'?: boolean;
    'name_line_1_random_postfix'?: boolean;
    'provider_ship_date'?: string;
    'provider_shipping_method'?: string;
    'provider_tracking_number'?: string;
    'token': string;
    'user_association'?: UserAssociation;
}
/**
 * Contains information on a bundle.
 */
export interface BundleCreateReq {
    /**
     * Unique identifier of the APR policy.
     */
    'apr_policy_token': string;
    /**
     * Unique identifier of the credit product policy.
     */
    'credit_product_policy_token': string;
    /**
     * Description of the bundle.
     */
    'description': string;
    /**
     * Unique identifier of the document policy.
     */
    'document_policy_token': string;
    /**
     * Unique identifier of the fee policy.
     */
    'fee_policy_token': string;
    /**
     * Name of the bundle.
     */
    'name': string;
    /**
     * Unique identifier of the offer policy.
     */
    'offer_policy_token'?: string;
    /**
     * Unique identifier of the reward policy.
     */
    'reward_policy_token'?: string;
    'status': BundleResourceStatus;
    /**
     * Unique identifier of the bundle.
     */
    'token'?: string;
}


/**
 * Status of the bundle.  * `DRAFT` - The bundle is in the process of being created. * `PENDING_APPROVAL` - The bundle has been created and is awaiting approval. * `SENT_FOR_REVISION` - The bundle has been returned for revision. * `ACTIVE` - The bundle is active. * `REJECTED` - The bundle has been rejected; this status cannot be changed. * `ARCHIVED` - The previously active bundle has been archived. * `APPROVED` - The bundle has been approved (after having been sent for approval).
 */

export const BundleResourceStatus = {
    Draft: 'DRAFT',
    PendingApproval: 'PENDING_APPROVAL',
    SentForRevision: 'SENT_FOR_REVISION',
    Active: 'ACTIVE',
    Rejected: 'REJECTED',
    Archived: 'ARCHIVED',
    Approved: 'APPROVED'
} as const;

export type BundleResourceStatus = typeof BundleResourceStatus[keyof typeof BundleResourceStatus];


/**
 * Contains information on a bundle.
 */
export interface BundleResponse {
    'apr_policy_detail'?: PolicyAprResponse;
    /**
     * Unique identifier of the bundle\'s APR policy.
     */
    'apr_policy_token'?: string;
    /**
     * Date and time when the bundle was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    'credit_product_policy_detail'?: PolicyProductResponse;
    /**
     * Unique identifier of the bundle\'s credit product policy.
     */
    'credit_product_policy_token'?: string;
    /**
     * Description of the bundle.
     */
    'description'?: string;
    'document_policy_detail'?: PolicyDocumentResponse;
    /**
     * Unique identifier of the bundle\'s document policy.
     */
    'document_policy_token'?: string;
    'fee_policy_detail'?: PolicyFeeResponse;
    /**
     * Unique identifier of the bundle\'s fee policy.
     */
    'fee_policy_token'?: string;
    /**
     * Name of the bundle.
     */
    'name'?: string;
    'offer_policy_detail'?: PolicyOfferResponse;
    /**
     * Unique identifier of the bundle\'s offer policy.
     */
    'offer_policy_token'?: string;
    'reward_policy_detail'?: PolicyRewardResponse;
    /**
     * Unique identifier of the bundle\'s reward policy.
     */
    'reward_policy_token'?: string;
    'status'?: BundleResourceStatus;
    /**
     * Unique identifier of the bundle.
     */
    'token'?: string;
    /**
     * Date and time when the bundle was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}


/**
 * Returns paginated bundles.
 */
export interface BundleResponsePage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more bundles.
     */
    'data': Array<BundleResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information on a bundle transition.
 */
export interface BundleTransitionReq {
    'status': BundleResourceStatus;
}


/**
 * Contains information on a bundle transition.
 */
export interface BundleTransitionResponse {
    /**
     * Unique identifier of the bundle.
     */
    'bundle_token'?: string;
    /**
     * Date and time when the bundle was changed the status on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    'original_status'?: BundleResourceStatus;
    'status'?: BundleResourceStatus;
    /**
     * Unique identifier of the bundle transition.
     */
    'token'?: string;
}


/**
 * Specifies bundles for a credit program.
 */
export interface BundleUpdateReq {
    /**
     * Unique identifier of the bundle\'s APR policy.
     */
    'apr_policy_token': string;
    /**
     * Unique identifier of the bundle\'s credit product policy.
     */
    'credit_product_policy_token': string;
    /**
     * Description of the bundle.
     */
    'description': string;
    /**
     * Unique identifier of the bundle\'s document policy.
     */
    'document_policy_token': string;
    /**
     * Unique identifier of the bundle\'s fee policy.
     */
    'fee_policy_token': string;
    /**
     * Name of the bundle.
     */
    'name': string;
    /**
     * Unique identifier of the bundle\'s offer policy.
     */
    'offer_policy_token'?: string;
    /**
     * Unique identifier of the bundle\'s reward policy.
     */
    'reward_policy_token'?: string;
}
export interface BusinessCardHolderListResponse {
    'count'?: number;
    'data'?: Array<BusinessCardHolderResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface BusinessCardHolderResponse {
    'account_holder_group_token'?: string;
    /**
     * default = true
     */
    'active'?: boolean;
    'attestation_consent'?: boolean;
    'attestation_date'?: string;
    'attester_name'?: string;
    'attester_title'?: string;
    'authentication'?: Authentication;
    'beneficial_owner1'?: BeneficialOwnerResponse;
    'beneficial_owner2'?: BeneficialOwnerResponse;
    'beneficial_owner3'?: BeneficialOwnerResponse;
    'beneficial_owner4'?: BeneficialOwnerResponse;
    'business_name_dba'?: string;
    'business_name_legal'?: string;
    'business_type'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'date_established'?: string;
    'duns_number'?: string;
    'general_business_description'?: string;
    'history'?: string;
    'identifications'?: Array<IdentificationResponseModel>;
    'in_current_location_since'?: string;
    'incorporation'?: BusinessIncorporationResponse;
    'international_office_locations'?: string;
    'ip_address'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'metadata'?: { [key: string]: string; };
    'notes'?: string;
    'office_location'?: AddressResponseModel;
    /**
     * Strong password required
     */
    'password'?: string;
    'phone'?: string;
    'primary_contact'?: PrimaryContactInfoModel;
    'proprietor_is_beneficial_owner'?: boolean;
    'proprietor_or_officer'?: BusinessProprietorResponse;
    'status'?: BusinessCardHolderResponseStatusEnum;
    'taxpayer_id'?: string;
    'token'?: string;
    'website'?: string;
}

export const BusinessCardHolderResponseStatusEnum = {
    Unverified: 'UNVERIFIED',
    Limited: 'LIMITED',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Closed: 'CLOSED',
    Terminated: 'TERMINATED'
} as const;

export type BusinessCardHolderResponseStatusEnum = typeof BusinessCardHolderResponseStatusEnum[keyof typeof BusinessCardHolderResponseStatusEnum];

export interface BusinessCardHolderUpdate {
    'account_holder_group_token'?: string;
    'active'?: boolean;
    'attestation_consent'?: boolean;
    'attestation_date'?: string;
    'attester_name'?: string;
    'attester_title'?: string;
    'beneficial_owner1'?: BeneficialOwnerRequest;
    'beneficial_owner2'?: BeneficialOwnerRequest;
    'beneficial_owner3'?: BeneficialOwnerRequest;
    'beneficial_owner4'?: BeneficialOwnerRequest;
    'business_name_dba'?: string;
    'business_name_legal'?: string;
    'business_type'?: string;
    'date_established'?: string;
    'duns_number'?: string;
    'general_business_description'?: string;
    'history'?: string;
    'identifications'?: Array<IdentificationRequestModel>;
    'in_current_location_since'?: string;
    'incorporation'?: BusinessIncorporation;
    'international_office_locations'?: string;
    'ip_address'?: string;
    'metadata'?: { [key: string]: string; };
    'notes'?: string;
    'office_location'?: AddressRequestModel;
    'password'?: string;
    'phone'?: string;
    'primary_contact'?: PrimaryContactInfoModel;
    'proprietor_is_beneficial_owner'?: boolean;
    'proprietor_or_officer'?: BusinessProprietor;
    'taxpayer_id'?: string;
    'token'?: string;
    'website'?: string;
}
export interface BusinessCardholder {
    'account_holder_group_token'?: string;
    'active'?: boolean;
    'attestation_consent'?: boolean;
    /**
     * YYYY-MM-DDThh:mm:ssZ
     */
    'attestation_date'?: string;
    'attester_name'?: string;
    'attester_title'?: string;
    'beneficial_owner1'?: BeneficialOwnerRequest;
    'beneficial_owner2'?: BeneficialOwnerRequest;
    'beneficial_owner3'?: BeneficialOwnerRequest;
    'beneficial_owner4'?: BeneficialOwnerRequest;
    'business_name_dba'?: string;
    'business_name_legal'?: string;
    'business_type'?: string;
    'date_established'?: string;
    'duns_number'?: string;
    'general_business_description'?: string;
    'history'?: string;
    'identifications'?: Array<IdentificationRequestModel>;
    'in_current_location_since'?: string;
    'incorporation'?: BusinessIncorporation;
    'international_office_locations'?: string;
    'ip_address'?: string;
    'metadata'?: { [key: string]: string; };
    'notes'?: string;
    'office_location'?: AddressRequestModel;
    /**
     * Strong password required
     */
    'password'?: string;
    'phone'?: string;
    'primary_contact'?: PrimaryContactInfoModel;
    'proprietor_is_beneficial_owner'?: boolean;
    'proprietor_or_officer'?: BusinessProprietor;
    'taxpayer_id'?: string;
    'token'?: string;
    'website'?: string;
}
export interface BusinessDirectorRequestModel {
    'active'?: boolean;
    'address'?: AddressRequestModel;
    'birth_date'?: string;
    'email'?: string;
    'first_name'?: string;
    'identifications'?: Array<IdentificationRequestModel>;
    'last_name'?: string;
    'middle_name'?: string;
    'nationality'?: string;
    'phone'?: string;
    'place_of_birth'?: string;
    'title'?: string;
    'token'?: string;
}
export interface BusinessDirectorResponseModel {
    'active'?: boolean;
    'address'?: AddressResponseModel;
    'birth_date'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'email'?: string;
    'first_name'?: string;
    'identifications'?: Array<IdentificationResponseModel>;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'last_name'?: string;
    'middle_name'?: string;
    'nationality'?: string;
    'phone'?: string;
    'place_of_birth'?: string;
    'title'?: string;
    'token'?: string;
}
export interface BusinessIncorporation {
    'address_registered_under'?: AddressRequestModel;
    'incorporation_type'?: BusinessIncorporationIncorporationTypeEnum;
    'is_public'?: boolean;
    'is_regulated_entity'?: boolean;
    'name_registered_under'?: string;
    'state_of_incorporation'?: string;
    'stock_symbol'?: string;
}

export const BusinessIncorporationIncorporationTypeEnum = {
    Llc: 'LLC',
    Corporation: 'CORPORATION',
    SoleProprietorship: 'SOLE_PROPRIETORSHIP',
    Partnership: 'PARTNERSHIP',
    Cooperative: 'COOPERATIVE',
    Other: 'OTHER',
    FinancialOrCreditInstitution: 'FINANCIAL_OR_CREDIT_INSTITUTION',
    Foundation: 'FOUNDATION',
    Association: 'ASSOCIATION',
    Charity: 'CHARITY',
    Trust: 'TRUST'
} as const;

export type BusinessIncorporationIncorporationTypeEnum = typeof BusinessIncorporationIncorporationTypeEnum[keyof typeof BusinessIncorporationIncorporationTypeEnum];

export interface BusinessIncorporationResponse {
    'address_registered_under'?: AddressResponseModel;
    'incorporation_type'?: BusinessIncorporationResponseIncorporationTypeEnum;
    'is_public'?: boolean;
    'is_regulated_entity'?: boolean;
    'name_registered_under'?: string;
    'state_of_incorporation'?: string;
    'stock_symbol'?: string;
}

export const BusinessIncorporationResponseIncorporationTypeEnum = {
    Llc: 'LLC',
    Corporation: 'CORPORATION',
    SoleProprietorship: 'SOLE_PROPRIETORSHIP',
    Partnership: 'PARTNERSHIP',
    Other: 'OTHER',
    FinancialOrCreditInstitution: 'FINANCIAL_OR_CREDIT_INSTITUTION',
    Foundation: 'FOUNDATION',
    Association: 'ASSOCIATION',
    Charity: 'CHARITY',
    Trust: 'TRUST'
} as const;

export type BusinessIncorporationResponseIncorporationTypeEnum = typeof BusinessIncorporationResponseIncorporationTypeEnum[keyof typeof BusinessIncorporationResponseIncorporationTypeEnum];

/**
 * Contains customer-provided information about the business that funded the transaction.
 */
export interface BusinessMetadata {
    /**
     * Associates customer-provided metadata with the business.
     */
    'metadata'?: { [key: string]: string; };
}
export interface BusinessProprietor {
    'alternative_names'?: string;
    'birth_place'?: string;
    'dob'?: string;
    'email'?: string;
    'first_name': string;
    'home'?: AddressRequestModel;
    'identifications'?: Array<IdentificationRequestModel>;
    'last_name': string;
    'middle_name'?: string;
    'nationality'?: string;
    'phone'?: string;
    'ssn'?: string;
    'title'?: string;
}
export interface BusinessProprietorResponse {
    'alternative_names'?: string;
    'birth_place'?: string;
    'dob'?: string;
    'email'?: string;
    'first_name'?: string;
    'home'?: AddressResponseModel;
    'identifications'?: Array<IdentificationResponseModel>;
    'last_name'?: string;
    'middle_name'?: string;
    'nationality'?: string;
    'phone'?: string;
    'ssn'?: string;
    'title'?: string;
}
export interface BusinessTransitionListResponse {
    'count'?: number;
    'data'?: Array<BusinessTransitionResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface BusinessTransitionRequest {
    'business_token': string;
    'channel': BusinessTransitionRequestChannelEnum;
    'idempotentHash'?: string;
    'reason'?: string;
    'reason_code': BusinessTransitionRequestReasonCodeEnum;
    'status': BusinessTransitionRequestStatusEnum;
    'token'?: string;
}

export const BusinessTransitionRequestChannelEnum = {
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM'
} as const;

export type BusinessTransitionRequestChannelEnum = typeof BusinessTransitionRequestChannelEnum[keyof typeof BusinessTransitionRequestChannelEnum];
export const BusinessTransitionRequestReasonCodeEnum = {
    _00: '00',
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15',
    _16: '16',
    _17: '17',
    _18: '18',
    _19: '19',
    _20: '20',
    _21: '21',
    _22: '22',
    _23: '23',
    _24: '24',
    _25: '25',
    _26: '26',
    _27: '27',
    _28: '28',
    _29: '29',
    _30: '30',
    _31: '31',
    _32: '32',
    _86: '86'
} as const;

export type BusinessTransitionRequestReasonCodeEnum = typeof BusinessTransitionRequestReasonCodeEnum[keyof typeof BusinessTransitionRequestReasonCodeEnum];
export const BusinessTransitionRequestStatusEnum = {
    Unverified: 'UNVERIFIED',
    Limited: 'LIMITED',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Closed: 'CLOSED',
    Terminated: 'TERMINATED'
} as const;

export type BusinessTransitionRequestStatusEnum = typeof BusinessTransitionRequestStatusEnum[keyof typeof BusinessTransitionRequestStatusEnum];

export interface BusinessTransitionResponse {
    'business_token'?: string;
    'channel': BusinessTransitionResponseChannelEnum;
    'created_time'?: string;
    'created_timestamp'?: string;
    'last_modified_time'?: string;
    'metadata'?: { [key: string]: string; };
    'reason'?: string;
    'reason_code': BusinessTransitionResponseReasonCodeEnum;
    'status': BusinessTransitionResponseStatusEnum;
    'token': string;
}

export const BusinessTransitionResponseChannelEnum = {
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM'
} as const;

export type BusinessTransitionResponseChannelEnum = typeof BusinessTransitionResponseChannelEnum[keyof typeof BusinessTransitionResponseChannelEnum];
export const BusinessTransitionResponseReasonCodeEnum = {
    _00: '00',
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15',
    _16: '16',
    _17: '17',
    _18: '18',
    _19: '19',
    _20: '20',
    _21: '21',
    _22: '22',
    _23: '23',
    _24: '24',
    _25: '25',
    _26: '26',
    _27: '27',
    _28: '28',
    _29: '29',
    _30: '30',
    _31: '31',
    _32: '32',
    _86: '86'
} as const;

export type BusinessTransitionResponseReasonCodeEnum = typeof BusinessTransitionResponseReasonCodeEnum[keyof typeof BusinessTransitionResponseReasonCodeEnum];
export const BusinessTransitionResponseStatusEnum = {
    Unverified: 'UNVERIFIED',
    Limited: 'LIMITED',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Closed: 'CLOSED',
    Terminated: 'TERMINATED'
} as const;

export type BusinessTransitionResponseStatusEnum = typeof BusinessTransitionResponseStatusEnum[keyof typeof BusinessTransitionResponseStatusEnum];

export interface BusinessUserCardHolderListResponse {
    'count'?: number;
    'data'?: Array<UserCardHolderResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface CalculatedBalanceResponse {
    /**
     * the latest balance of the account from the migrated program
     */
    'available_credit'?: number;
    /**
     * the latest balance of the account from the migrated program
     */
    'current_balance'?: number;
}
export interface CardAcceptorModel {
    'address'?: string;
    'business_registration_id'?: string;
    'business_registration_id_type'?: string;
    'city'?: string;
    'country'?: string;
    'customer_service_phone'?: string;
    'ecommerce_security_level_indicator'?: string;
    'geographic_coordinates'?: string;
    'legal_business_name'?: string;
    'mcc'?: string;
    'name'?: string;
    'partial_approval_capable'?: boolean;
    'phone'?: string;
    'service_geographic_coordinates'?: string;
    'state'?: string;
    'url'?: string;
    'zip'?: string;
}
export interface CardFulfillmentRequest {
    'card_fulfillment_reason'?: CardFulfillmentRequestCardFulfillmentReasonEnum;
    'card_personalization': CardPersonalization;
    'shipping'?: Shipping;
}

export const CardFulfillmentRequestCardFulfillmentReasonEnum = {
    New: 'NEW',
    LostStolen: 'LOST_STOLEN',
    Expired: 'EXPIRED'
} as const;

export type CardFulfillmentRequestCardFulfillmentReasonEnum = typeof CardFulfillmentRequestCardFulfillmentReasonEnum[keyof typeof CardFulfillmentRequestCardFulfillmentReasonEnum];

/**
 * Determines physical characteristics of a card and shipment information.
 */
export interface CardFulfillmentResponse {
    /**
     * Descriptive reason for the card fulfillment.
     */
    'card_fulfillment_reason'?: CardFulfillmentResponseCardFulfillmentReasonEnum;
    'card_personalization': CardPersonalization;
    'shipping'?: ShippingInformationResponse;
}

export const CardFulfillmentResponseCardFulfillmentReasonEnum = {
    New: 'NEW',
    LostStolen: 'LOST_STOLEN',
    Expired: 'EXPIRED'
} as const;

export type CardFulfillmentResponseCardFulfillmentReasonEnum = typeof CardFulfillmentResponseCardFulfillmentReasonEnum[keyof typeof CardFulfillmentResponseCardFulfillmentReasonEnum];

/**
 * Request body for a Card Group object
 */
export interface CardGroup {
    /**
     * Array of card tokens associated with group. There will be at least one card token in the array.
     */
    'card_tokens'?: Array<string>;
    /**
     * Date and time the card group was created in the system. The date and time is provided in ISO 8601 format.
     */
    'created_time'?: string;
    /**
     * Unique identifier of the last reissued card token associated with group. It may be empty if there is no reissued card.
     */
    'last_issued_card_token'?: string;
    /**
     * Unique identifier of the card token associated with group. This is the card that will be used to create the card group. The Card Group Service will send a request to JCard to verify that this card is not a reissue or replacement.
     */
    'source_card_token': string;
    /**
     * Unique identifier of the card group.  If you do not include a token, the system will generate one automatically. This token is necessary for use in other API calls, so we recommend that rather than let the system generate one, you use a simple string that is easy to remember. This value cannot be updated.
     */
    'token': string;
    /**
     * Date and time the card group was last updated in the system. The date and time is provided in ISO 8601 format.
     */
    'updated_time'?: string;
    /**
     * Unique identifier of the user this card group belongs to.
     */
    'user_token'?: string;
}
export interface CardGroupPage {
    /**
     * Number of resources retrieved.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of Card Group objects.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<CardGroup>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
/**
 * Request body for creating a new Card Group object
 */
export interface CardGroupReq {
    /**
     * Unique identifier token of the card token to be associated with the group.
     */
    'card_token': string;
}
export interface CardHolderAddressModel {
    'active'?: boolean;
    'address_1': string;
    'address_2'?: string;
    /**
     * Required if \'user_token\' is not specified
     */
    'business_token'?: string;
    'city': string;
    'country': string;
    'first_name': string;
    'is_default_address'?: boolean;
    'last_name': string;
    'phone'?: string;
    /**
     * Required if \'zip\' is not specified
     */
    'postal_code'?: string;
    'state': string;
    'token'?: string;
    /**
     * Required if \'business_token\' is not specified
     */
    'user_token'?: string;
    /**
     * Required if \'postal_code\' is not specified
     */
    'zip'?: string;
}
export interface CardHolderAddressUpdateModel {
    'active'?: boolean;
    'address_1'?: string;
    'address_2'?: string;
    'city'?: string;
    'country'?: string;
    'first_name'?: string;
    'is_default_address'?: boolean;
    'last_name'?: string;
    'phone'?: string;
    'postal_code'?: string;
    'state'?: string;
    'zip'?: string;
}
/**
 * Contains information about a cardholder.
 */
export interface CardHolderModel {
    /**
     * Associates the specified account holder group with the cardholder.  Send a `GET` request to `/accountholdergroups` to retrieve account holder group tokens.
     */
    'account_holder_group_token'?: string;
    /**
     * Specifies if the cardholder is in the `ACTIVE` state on the Marqeta platform.  *NOTE:* Do not set the value of the `user.active` field directly. Instead, use the `/usertransitions` endpoints to transition user resources between statuses. For more information on status changes, see <</core-api/user-transitions#postUsertransitions, Create User Transition>>.
     */
    'active'?: boolean;
    /**
     * Cardholder\'s address.  *NOTE:* Required for KYC verification (US-based cardholders only). Cannot perform KYC if set to a PO Box.
     */
    'address1'?: string;
    /**
     * Additional address information for the cardholder.  *NOTE:* Cannot perform KYC if set to a PO Box.
     */
    'address2'?: string;
    /**
     * Cardholder\'s date of birth.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'birth_date'?: string;
    /**
     * Country where the cardholder was born.
     */
    'birth_place'?: string;
    /**
     * City where the cardholder resides.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'city'?: string;
    /**
     * Company name.
     */
    'company'?: string;
    /**
     * Specifies if the cardholder holds a corporate card.
     */
    'corporate_card_holder'?: boolean;
    /**
     * Country where the cardholder resides.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'country'?: string;
    /**
     * Valid email address of the cardholder.  This value must be unique among users.  *NOTE:* Required for KYC verification by certain banks (US-based cardholders only). To determine if you must provide an email address, contact your Marqeta representative.
     */
    'email'?: string;
    /**
     * Cardholder\'s first name.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'first_name'?: string;
    /**
     * Gender of the cardholder.
     */
    'gender'?: CardHolderModelGenderEnum;
    /**
     * Cardholder\'s title or prefix: Dr., Miss, Mr., Ms., and so on.
     */
    'honorific'?: string;
    /**
     * Expiration date of the cardholder\'s identification card.
     */
    'id_card_expiration_date'?: string;
    /**
     * Cardholder\'s identification card number.
     */
    'id_card_number'?: string;
    /**
     * One or more objects containing identifications associated with the cardholder.
     */
    'identifications'?: Array<IdentificationRequestModel>;
    /**
     * Cardholder\'s IP address.
     */
    'ip_address'?: string;
    /**
     * Cardholder\'s last name.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'last_name'?: string;
    /**
     * Associates any additional metadata you provide with the cardholder.
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Cardholder\'s middle name.
     */
    'middle_name'?: string;
    /**
     * Cardholder\'s nationality.
     */
    'nationality'?: string;
    /**
     * Any additional information pertaining to the cardholder.
     */
    'notes'?: string;
    /**
     * Unique identifier of the parent user or business resource. Send a `GET` request to `/users` to retrieve user resource tokens or to `/businesses` to retrieve business resource tokens.  Required if `uses_parent_account = true`. This user or business is configured as the parent of the current user.
     */
    'parent_token'?: string;
    /**
     * Expiration date of the cardholder\'s passport.
     */
    'passport_expiration_date'?: string;
    /**
     * Cardholder\'s passport number.
     */
    'passport_number'?: string;
    /**
     * Password to the cardholder\'s user account on the Marqeta platform.  * Must contain at least one numeral + * Must contain at least one lowercase letter + * Must contain at least one uppercase letter + * Must contain at least one of these symbols:   +  `@` `#` `$` `%` `!` `^` `&` `*` `(` `)`   +  `\\` `_` `+` `~` `-` `=` `[` `]` `{` `}`   +  `,` `;` `:` `\'` `\"` `.` `/` `<` `>` `?` ```
     */
    'password'?: string;
    /**
     * Telephone number of the cardholder (including area code), prepended by the `+` symbol and the 1- to 3-digit country calling code. Do not include hyphens, spaces, or parentheses.  *NOTE:* Required for KYC verification by certain banks (US-based cardholders only). To determine if you must provide a phone number, contact your Marqeta representative.
     */
    'phone'?: string;
    /**
     * Postal code of the cardholder\'s address.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'postal_code'?: string;
    /**
     * Cardholder\'s Social Security Number (SSN) or Individual Taxpayer Identification Number (ITIN).
     */
    'ssn'?: string;
    /**
     * State or province where the cardholder resides.  *NOTE:* <</core-api/kyc-verification#_valid_state_provincial_territorial_and_federal_abbreviations, Valid two-character abbreviation>> required for KYC verification (US-based cardholders only).
     */
    'state'?: string;
    /**
     * Professional title of the cardholder, such as Chief Comptroller.  *NOTE:* Do not use this field for honorific titles such as Mr., Mrs., Miss, Ms., Mx., Sir, or Dame. Instead, add these to the `honorific` field.
     */
    'title'?: string;
    /**
     * Unique identifier of the cardholder. If you do not include a token, the system generates one automatically. This token is necessary for use in other API calls, so we recommend that rather than let the system generate one, you use a simple string that is easy to remember. This value cannot be updated.
     */
    'token'?: string;
    /**
     * Indicates whether the child shares balances with the parent (`true`), or the child\'s balances are independent of the parent (`false`).  If set to `true`, you must also include a `parent_token` in the request. This value cannot be updated.
     */
    'uses_parent_account'?: boolean;
}

export const CardHolderModelGenderEnum = {
    F: 'F',
    M: 'M'
} as const;

export type CardHolderModelGenderEnum = typeof CardHolderModelGenderEnum[keyof typeof CardHolderModelGenderEnum];

export interface CardHolderNoteListResponse {
    'count'?: number;
    'data'?: Array<CardholderNoteResponseModel>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface CardLifeCycle {
    'activate_upon_issue'?: boolean;
    'card_service_code'?: number;
    'expiration_offset'?: ExpirationOffset;
    'reloadability'?: CardLifeCycleReloadabilityEnum;
    'update_expiration_upon_activation'?: boolean;
}

export const CardLifeCycleReloadabilityEnum = {
    SingleUseVirtual: 'SINGLE_USE_VIRTUAL',
    NonReloadable: 'NON_RELOADABLE',
    Reloadable: 'RELOADABLE'
} as const;

export type CardLifeCycleReloadabilityEnum = typeof CardLifeCycleReloadabilityEnum[keyof typeof CardLifeCycleReloadabilityEnum];

export interface CardListResponse {
    'count'?: number;
    'data'?: Array<CardResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface CardMetadata {
    'metadata'?: { [key: string]: string; };
}
export interface CardOptions {
    'billing_address'?: BillingAddress;
    'card_present'?: boolean;
    'cvv'?: string;
    'expiration'?: string;
}
/**
 * Specifies personalized attributes to be added to the card.
 */
export interface CardPersonalization {
    'carrier'?: Carrier;
    'images'?: Images;
    /**
     * Specifies the type of card personalization.
     */
    'perso_type'?: CardPersonalizationPersoTypeEnum;
    'text': Text;
}

export const CardPersonalizationPersoTypeEnum = {
    Emboss: 'EMBOSS',
    Laser: 'LASER',
    Flat: 'FLAT'
} as const;

export type CardPersonalizationPersoTypeEnum = typeof CardPersonalizationPersoTypeEnum[keyof typeof CardPersonalizationPersoTypeEnum];

export interface CardProductConfig {
    'card_life_cycle'?: CardLifeCycle;
    'clearing_and_settlement'?: ClearingAndSettlement;
    'digital_wallet_tokenization'?: DigitalWalletTokenization;
    'fulfillment'?: CardProductFulfillment;
    'jit_funding'?: JitFunding;
    'poi'?: Poi;
    'selective_auth'?: SelectiveAuth;
    'special'?: Special;
    'transaction_controls'?: TransactionControls;
}
export interface CardProductFulfillment {
    'all_zero_card_security_code'?: boolean;
    'allow_card_creation'?: boolean;
    'bin_issue_country'?: string;
    'bin_prefix'?: string;
    /**
     * List of BIN prefixes for multi-BIN support
     */
    'bin_prefixes'?: Array<BinPrefixRequest>;
    'bulk_ship'?: boolean;
    'card_personalization': CardPersonalization;
    'enable_offline_pin'?: boolean;
    'fulfillment_provider'?: CardProductFulfillmentFulfillmentProviderEnum;
    'package_id'?: string;
    'pan_length'?: string;
    'payment_instrument'?: CardProductFulfillmentPaymentInstrumentEnum;
    'shipping'?: Shipping;
    'uppercase_name_lines'?: boolean;
}

export const CardProductFulfillmentFulfillmentProviderEnum = {
    Perfectplastic: 'PERFECTPLASTIC',
    Arroweye: 'ARROWEYE',
    Idemia: 'IDEMIA',
    IdemiaUk: 'IDEMIA_UK',
    IdemiaFr: 'IDEMIA_FR',
    IdemiaCz: 'IDEMIA_CZ',
    IdemiaApac: 'IDEMIA_APAC',
    IdemiaPl: 'IDEMIA_PL',
    IdemiaAu: 'IDEMIA_AU',
    IdemiaLa: 'IDEMIA_LA',
    Gemalto: 'GEMALTO',
    Nitecrest: 'NITECREST',
    Oberthur: 'OBERTHUR',
    Allpay: 'ALLPAY'
} as const;

export type CardProductFulfillmentFulfillmentProviderEnum = typeof CardProductFulfillmentFulfillmentProviderEnum[keyof typeof CardProductFulfillmentFulfillmentProviderEnum];
export const CardProductFulfillmentPaymentInstrumentEnum = {
    PhysicalMsr: 'PHYSICAL_MSR',
    PhysicalIcc: 'PHYSICAL_ICC',
    PhysicalContactless: 'PHYSICAL_CONTACTLESS',
    PhysicalCombo: 'PHYSICAL_COMBO',
    VirtualPan: 'VIRTUAL_PAN'
} as const;

export type CardProductFulfillmentPaymentInstrumentEnum = typeof CardProductFulfillmentPaymentInstrumentEnum[keyof typeof CardProductFulfillmentPaymentInstrumentEnum];

export interface CardProductListResponse {
    'count'?: number;
    'data'?: Array<CardProductResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface CardProductRequest {
    'active'?: boolean;
    'config'?: CardProductConfig;
    /**
     * yyyy-MM-dd
     */
    'end_date'?: string;
    'name': string;
    /**
     * yyyy-MM-dd
     */
    'start_date': string;
    'token'?: string;
}
export interface CardProductResponse {
    'active'?: boolean;
    'config'?: CardProductConfig;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    /**
     * yyyy-MM-dd
     */
    'end_date'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'name': string;
    /**
     * yyyy-MM-dd
     */
    'start_date': string;
    'token'?: string;
}
export interface CardProductUpdateModel {
    'active'?: boolean;
    'config'?: CardProductConfig;
    /**
     * yyyy-MM-dd
     */
    'end_date'?: string;
    'name'?: string;
    /**
     * yyyy-MM-dd
     */
    'start_date'?: string;
}
export interface CardRequest {
    'account_token'?: string;
    'activation_actions'?: ActivationActions;
    'bulk_issuance_token'?: string;
    'card_product_token': string;
    'expedite'?: boolean;
    'expiration_offset'?: ExpirationOffset;
    'fulfillment'?: CardFulfillmentRequest;
    'metadata'?: { [key: string]: string; };
    'new_pan_from_card_token'?: string;
    'reissue_pan_from_card_token'?: string;
    'token'?: string;
    'translate_pin_from_card_token'?: string;
    'user_token': string;
}
/**
 * Contains information about the card used in the transaction.
 */
export interface CardResponse {
    '3csc'?: string;
    /**
     * List of account tokens associated with the card
     */
    'account_tokens'?: Array<string>;
    'activation_actions'?: ActivationActions;
    /**
     * Barcode printed on the card, expressed as numerals.
     */
    'barcode': string;
    /**
     * Unique identifier of the bulk card order.
     */
    'bulk_issuance_token'?: string;
    /**
     * Unique identifier of the card product.
     */
    'card_product_token': string;
    'chip_cvv_contactless_number'?: string;
    /**
     * Three-digit card verification value (ICVV) stored on the chip of the card.
     */
    'chip_cvv_number'?: string;
    /**
     * Running count of the contactless transactions successfully completed since the last strong customer authentication (SCA) challenge was issued. You can limit the number of contactless transactions that can be performed without issuing an SCA challenge at the card product level.  For more information about strong customer authentication, see <</core-api/card-products, Card Products>>.
     */
    'contactless_exemption_counter'?: number;
    /**
     * Running total of the money spent in contactless transactions successfully completed since the last strong customer authentication (SCA) challenge was issued. You can limit the total amount that can be spent in contactless transactions without issuing an SCA challenge at the card product level.  For more information about strong customer authentication, see <</core-api/card-products, Card Products>>.
     */
    'contactless_exemption_total_amount'?: number;
    /**
     * Indicates the currency type of the transaction.
     */
    'contactless_exemption_transaction_currency'?: string;
    /**
     * Date and time when the resource was created, in UTC.
     */
    'created_time': string;
    /**
     * Three-digit card verification value (CVV2 or CVC2) printed on the card.
     */
    'cvv_number'?: string;
    /**
     * A value of `true` indicates that you requested expedited processing of the card from your card fulfillment provider.
     */
    'expedite'?: boolean;
    /**
     * Expiration date in `MMyy` format.
     */
    'expiration': string;
    /**
     * Expiration date and time, in UTC.
     */
    'expiration_time': string;
    'fulfillment'?: CardFulfillmentResponse;
    /**
     * Card fulfillment status:  * *ISSUED:* Initial state of all newly created/issued cards. * *ORDERED:* Card ordered through the card fulfillment provider. * *REORDERED:* Card reordered through the card fulfillment provider. * *REJECTED:* Card rejected by the card fulfillment provider. * *SHIPPED:* Card shipped by the card fulfillment provider. * *DELIVERED:* Card delivered by the card fulfillment provider. * *DIGITALLY_PRESENTED:* Card digitally presented using the `/cards/{token}/showpan` endpoint; does not affect the delivery of physical cards.
     */
    'fulfillment_status': CardResponseFulfillmentStatusEnum;
    /**
     * Instrument type of the card:  * *PHYSICAL_MSR:* A physical card with a magnetic stripe. This is the default physical card type. * *PHYSICAL_ICC:* A physical card with an integrated circuit, or \"chip.\" * *PHYSICAL_CONTACTLESS:* A physical card that uses radio frequency identification (RFID) or near-field communication (NFC) to enable payment over a secure radio interface. * *PHYSICAL_COMBO:* A physical card with a chip that also supports contactless payments. * *VIRTUAL_PAN:* A virtual card with a primary account number (PAN).
     */
    'instrument_type'?: CardResponseInstrumentTypeEnum;
    /**
     * Last four digits of the card primary account number (PAN).
     */
    'last_four': string;
    /**
     * Date and time when the resource was last modified, in UTC.
     */
    'last_modified_time': string;
    /**
     * Associates customer-provided metadata with the card.
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Reissues the specified card (known as the \"source\" card) with a new primary account number (PAN).
     */
    'new_pan_from_card_token'?: string;
    /**
     * Primary account number (PAN) of the card.
     */
    'pan': string;
    /**
     * Specifies if the personal identification number (PIN) has been set for the card.
     */
    'pin_is_set': boolean;
    /**
     * Reissues the specified card (known as the \"source\" card).
     */
    'reissue_pan_from_card_token'?: string;
    /**
     * Indicates the state of the card.
     */
    'state': CardResponseStateEnum;
    /**
     * Descriptive reason for why the card is in its current state. For example, \"Card activated by cardholder\".
     */
    'state_reason': string;
    /**
     * Unique identifier of the card.
     */
    'token': string;
    /**
     * Copies the personal identification number (PIN) from the specified source card to the newly created card.
     */
    'translate_pin_from_card_token'?: string;
    'user'?: UserCardHolderResponse;
    /**
     * Unique identifier of the cardholder.
     */
    'user_token': string;
}

export const CardResponseFulfillmentStatusEnum = {
    Issued: 'ISSUED',
    Ordered: 'ORDERED',
    Reordered: 'REORDERED',
    Rejected: 'REJECTED',
    Shipped: 'SHIPPED',
    Delivered: 'DELIVERED',
    DigitallyPresented: 'DIGITALLY_PRESENTED'
} as const;

export type CardResponseFulfillmentStatusEnum = typeof CardResponseFulfillmentStatusEnum[keyof typeof CardResponseFulfillmentStatusEnum];
export const CardResponseInstrumentTypeEnum = {
    PhysicalMsr: 'PHYSICAL_MSR',
    PhysicalIcc: 'PHYSICAL_ICC',
    PhysicalContactless: 'PHYSICAL_CONTACTLESS',
    PhysicalCombo: 'PHYSICAL_COMBO',
    VirtualPan: 'VIRTUAL_PAN'
} as const;

export type CardResponseInstrumentTypeEnum = typeof CardResponseInstrumentTypeEnum[keyof typeof CardResponseInstrumentTypeEnum];
export const CardResponseStateEnum = {
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Terminated: 'TERMINATED',
    Unsupported: 'UNSUPPORTED',
    Unactivated: 'UNACTIVATED',
    Limited: 'LIMITED'
} as const;

export type CardResponseStateEnum = typeof CardResponseStateEnum[keyof typeof CardResponseStateEnum];

/**
 * Contains information about a verification check performed on the card\'s security code.
 */
export interface CardSecurityCodeVerification {
    'response': Response;
    /**
     * Indicates the type of security code. Can have these possible values:  * *CVV1*  the security code stored in the magnetic stripe on the card. * *CVV2*  the security code printed on the card. * *ICVV*  the security code stored on the chip of the card. * *DCVV*  a dynamic security code used in some contactless payments when a card or device is tapped against the card reader.
     */
    'type': CardSecurityCodeVerificationTypeEnum;
}

export const CardSecurityCodeVerificationTypeEnum = {
    Cvv1: 'CVV1',
    Cvv2: 'CVV2',
    Icvv: 'ICVV',
    Dcvv: 'DCVV'
} as const;

export type CardSecurityCodeVerificationTypeEnum = typeof CardSecurityCodeVerificationTypeEnum[keyof typeof CardSecurityCodeVerificationTypeEnum];

/**
 * Contains identifiers for swapping digital wallet tokens between cards.
 */
export interface CardSwapHash {
    /**
     * Unique identifier of the new card resource to which the digital wallet tokens are assigned.
     */
    'new_card_token': string;
    /**
     * Unique identifier of the existing card resource that has digital wallet tokens assigned to it.
     */
    'previous_card_token': string;
}
export interface CardTransitionListResponse {
    'count'?: number;
    'data'?: Array<CardTransitionResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface CardTransitionRequest {
    'card_token': string;
    'channel': CardTransitionRequestChannelEnum;
    'reason'?: string;
    'reason_code'?: CardTransitionRequestReasonCodeEnum;
    'state': CardTransitionRequestStateEnum;
    'sync_state_with_dwts'?: boolean;
    'token'?: string;
    'validations'?: ValidationsRequest;
}

export const CardTransitionRequestChannelEnum = {
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM'
} as const;

export type CardTransitionRequestChannelEnum = typeof CardTransitionRequestChannelEnum[keyof typeof CardTransitionRequestChannelEnum];
export const CardTransitionRequestReasonCodeEnum = {
    _00: '00',
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15',
    _16: '16',
    _17: '17',
    _18: '18',
    _19: '19',
    _20: '20',
    _21: '21',
    _22: '22',
    _23: '23',
    _24: '24',
    _25: '25',
    _26: '26',
    _27: '27',
    _28: '28',
    _29: '29',
    _30: '30',
    _31: '31',
    _32: '32',
    _86: '86'
} as const;

export type CardTransitionRequestReasonCodeEnum = typeof CardTransitionRequestReasonCodeEnum[keyof typeof CardTransitionRequestReasonCodeEnum];
export const CardTransitionRequestStateEnum = {
    Active: 'ACTIVE',
    Limited: 'LIMITED',
    Suspended: 'SUSPENDED',
    Terminated: 'TERMINATED'
} as const;

export type CardTransitionRequestStateEnum = typeof CardTransitionRequestStateEnum[keyof typeof CardTransitionRequestStateEnum];

export interface CardTransitionResponse {
    'barcode': string;
    'bulk_issuance_token'?: string;
    'card'?: CardMetadata;
    'card_product_token': string;
    'card_token': string;
    'channel': CardTransitionResponseChannelEnum;
    'created_time'?: string;
    'created_timestamp'?: string;
    'expedite'?: boolean;
    'expiration': string;
    'expiration_time': string;
    'fulfillment'?: CardFulfillmentRequest;
    'fulfillment_status': CardTransitionResponseFulfillmentStatusEnum;
    'last_four': string;
    'new_pan_from_card_token'?: string;
    'pan': string;
    'pin_is_set': boolean;
    'reason'?: string;
    'reason_code'?: CardTransitionResponseReasonCodeEnum;
    'reissue_pan_from_card_token'?: string;
    'state': CardTransitionResponseStateEnum;
    'token': string;
    'type': CardTransitionResponseTypeEnum;
    'user'?: CardholderMetadata;
    'user_token': string;
    'validations'?: ValidationsResponse;
}

export const CardTransitionResponseChannelEnum = {
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM'
} as const;

export type CardTransitionResponseChannelEnum = typeof CardTransitionResponseChannelEnum[keyof typeof CardTransitionResponseChannelEnum];
export const CardTransitionResponseFulfillmentStatusEnum = {
    Issued: 'ISSUED',
    Ordered: 'ORDERED',
    Rejected: 'REJECTED',
    Shipped: 'SHIPPED',
    Delivered: 'DELIVERED',
    DigitallyPresented: 'DIGITALLY_PRESENTED'
} as const;

export type CardTransitionResponseFulfillmentStatusEnum = typeof CardTransitionResponseFulfillmentStatusEnum[keyof typeof CardTransitionResponseFulfillmentStatusEnum];
export const CardTransitionResponseReasonCodeEnum = {
    _00: '00',
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15',
    _16: '16',
    _17: '17',
    _18: '18',
    _19: '19',
    _20: '20',
    _21: '21',
    _22: '22',
    _23: '23',
    _24: '24',
    _25: '25',
    _26: '26',
    _27: '27',
    _28: '28',
    _29: '29',
    _30: '30',
    _31: '31',
    _32: '32',
    _86: '86'
} as const;

export type CardTransitionResponseReasonCodeEnum = typeof CardTransitionResponseReasonCodeEnum[keyof typeof CardTransitionResponseReasonCodeEnum];
export const CardTransitionResponseStateEnum = {
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Terminated: 'TERMINATED',
    Unactivated: 'UNACTIVATED'
} as const;

export type CardTransitionResponseStateEnum = typeof CardTransitionResponseStateEnum[keyof typeof CardTransitionResponseStateEnum];
export const CardTransitionResponseTypeEnum = {
    FulfillmentIssued: 'fulfillment.issued',
    StateActivated: 'state.activated',
    StateSuspended: 'state.suspended',
    StateReinstated: 'state.reinstated',
    StateTerminated: 'state.terminated',
    StateLimited: 'state.limited',
    FulfillmentOrdered: 'fulfillment.ordered',
    FulfillmentRejected: 'fulfillment.rejected',
    FulfillmentShipped: 'fulfillment.shipped',
    FulfillmentDelivered: 'fulfillment.delivered',
    FulfillmentDigitallyPresented: 'fulfillment.digitally_presented'
} as const;

export type CardTransitionResponseTypeEnum = typeof CardTransitionResponseTypeEnum[keyof typeof CardTransitionResponseTypeEnum];

export interface CardUpdateRequest {
    'expedite'?: boolean;
    'fulfillment'?: CardFulfillmentRequest;
    'metadata'?: { [key: string]: string; };
    'token': string;
    'user_token'?: string;
}
export interface CardholderAddressListResponse {
    'count'?: number;
    'data'?: Array<CardholderAddressResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
/**
 * Contains information about the billing address of the funding source.
 */
export interface CardholderAddressResponse {
    /**
     * Whether the address is active.
     */
    'active'?: boolean;
    /**
     * Street address of the funding source.
     */
    'address_1': string;
    /**
     * Additional address information for the funding source.  This field is returned if it exists in the resource.
     */
    'address_2'?: string;
    /**
     * Unique identifier of the business account holder associated with the address.  This field is returned if it exists in the resource.
     */
    'business_token'?: string;
    /**
     * City of the funding source.
     */
    'city': string;
    /**
     * Country of the funding source.
     */
    'country': string;
    /**
     * Date and time when the address was created, in UTC.
     */
    'created_time': string;
    /**
     * First name of the account holder associated with the funding source.
     */
    'first_name': string;
    /**
     * Whether this address is the default address used by the funding source.
     */
    'is_default_address'?: boolean;
    /**
     * Date and time when the address was last modified, in UTC.  This field is returned if it exists in the resource.
     */
    'last_modified_time': string;
    /**
     * Last name of the account holder associated with the funding source.
     */
    'last_name': string;
    /**
     * Phone number of the funding source.  This field is returned if it exists in the resource.
     */
    'phone'?: string;
    /**
     * Postal code of the funding source.
     */
    'postal_code': string;
    /**
     * Two-character state, provincial, or territorial abbreviation.  For the complete list, see <</core-api/kyc-verification#_valid_state_provincial_territorial_and_federal_abbreviations, Valid state, provincial, territorial, and federal abbreviations>>.
     */
    'state': string;
    /**
     * Unique identifier of the `funding_source_address` object.
     */
    'token': string;
    /**
     * Unique identifier of the user account holder associated with the address.  This field is returned if it exists in the resource.
     */
    'user_token'?: string;
    /**
     * United States ZIP code of the funding source.
     */
    'zip': string;
}
/**
 * Contains authentication data for 3D Secure and digital wallet token transactions:  * `electronic_commerce_indicator`  The level of verification performed. * `verification_result`  The result of the verification. * `verification_value_created_by`  The transaction participant who determined the verification result. * `three_ds_message_version`  The 3D Secure message version used for authentication. * `authentication_method`  The 3D Secure authentication method. * `authentication_status`  The 3D Secure authentication status. * `acquirer_exemption`  Indicates a 3D Secure authentication exemption from the acquirer. * `issuer_exemption`  Indicates a 3D Secure authentication exemption from the issuer. * `cavv_authentication_amount`  CAVV authentication amount. * `raw_cavv_data`  Raw CAVV data provided by the card network.
 */
export interface CardholderAuthenticationData {
    /**
     * Indicates 3D Secure authentication exemptions from the acquirer. This array is returned if it is included in the transaction data from the card network.
     */
    'acquirer_exemption'?: Array<string>;
    /**
     * Specifies the 3D Secure authentication method.
     */
    'authentication_method'?: string;
    /**
     * Specifies the status of the 3D Secure authentication:  * `ATTEMPTED`: Indicates that 3D Secure authentication was requested and processed by the card network. * `DATA_SHARE_EXEMPTED`: Indicates that 3D Secure authentication was for information only and exempted. * `EXEMPTED`: Indicates that 3D Secure authentication was requested but the challenge was exempted. * `EXEMPTION_CLAIMED`: Indicates that 3D Secure authentication was exempted because acquirer transaction risk analysis (TRA) was already performed. * `SCA_EXEMPTION`: Indicates that 3D Secure authentication was exempted because strong customer authentication (SCA) was already performed. * `SUCCESSFUL`: Indicates that 3D Secure authentication was successful. * `SUCCESSFUL_NON_PAYMENT`: Indicates that 3D Secure non-payment authentication was successful. * `THREEDS_REQUESTER_DATA_SHARE_EXEMPTION`: Status is deprecated and will be removed from a future release of the Marqeta platform. After June 2023, use `DATA_SHARE_EXEMPTION` instead. * `THREEDS_REQUESTER_SCA_EXEMPTION`: Status is deprecated and will be removed in a June 2023 release of the Marqeta platform. After June 2023, use `SCA_EXEMPTION` instead. * `THREEDS_REQUESTER_TRA_EXEMPTION`: Status is deprecated and will be removed in a June 2023 release of the Marqeta platform. After June 2023, use `EXEMPTION_CLAIMED` instead. * `UNAVAILABLE`: ** For Visa transactions, this status indicates that 3D Secure authentication was requested, but Marqeta\'s access control server (ACS) was not available. ** For Mastercard transactions, this status indicates that 3D Secure authentication was not available.
     */
    'authentication_status'?: string;
    /**
     * Authentication amount from the cardholder authentication verification value (CAVV) used to validate an authorization. This field is returned if it is included in the transaction data from the card network.  To enable this field, contact your Marqeta representative.
     */
    'cavv_authentication_amount'?: string;
    /**
     * Status of the 3D Secure or digital wallet token transaction authentication attempt, as provided by a transaction participant.  * `authentication_attempted`: Merchant attempted to authenticate, but either the issuer or the cardholder does not participate in 3D Secure or card tokenization. * `authentication_successful`: Cardholder authentication successful. * `no_authentication`: Non-authenticated e-commerce transaction.
     */
    'electronic_commerce_indicator'?: string;
    /**
     * Indicates a 3D Secure authentication exemption from the issuer. This field is returned if it is included in the transaction data from the card network.
     */
    'issuer_exemption'?: string;
    /**
     * Raw cardholder authentication verification value provided by the card network. This field is returned if it is included in the transaction data from the card network.  To enable this field, contact your Marqeta representative.
     */
    'raw_cavv_data'?: string;
    'three_ds_data_quality'?: string;
    /**
     * Specifies the 3D Secure message version used for authentication.
     */
    'three_ds_message_version'?: string;
    /**
     * The 3D Secure authentication indicator, as provided by the Mastercard card network.
     */
    'three_ds_reference_id'?: string;
    /**
     * Result of cardholder authentication verification value (CAVV) or accountholder authentication value (AAV) verification performed by the card network.  * `failed` * `not_present` * `not_provided` * `not_verified` * `not_verified_authentication_outage` * `verified` * `verified_amount_checked` * `verified_amount_greater_than_20_percent`: For Mastercard AAV verification, indicates that the original authentication amount and final authorization amount are mismatched, and that the final authorization amount exceeds the original authentication amount by more than 20%. This 20% margin falls outside Mastercard\'s suggested tolerance for what a European cardholder might reasonably expect when the total transaction amount is not known in advance. * `verified_amount_less_than_20_percent`: For Mastercard AAV verification, indicates that the original authentication amount and final authorization amount are mismatched, and that the final authorization amount exceeds the original authentication amount by 20% or less. This 20% margin falls within Mastercard\'s suggested tolerance for what a European cardholder might reasonably expect when the total transaction amount is not known in advance. * `not_verified_mac_key_validation_passed`: For Mastercard only. This field is present when the transaction passes MAC key validation but Dynamic Linking was not performed by the Mastercard card network due to system connectivity issues. * `not_verified_mac_key_validation_failed`: For Mastercard only. This field is present when the transaction fails MAC key validation and Dynamic Linking was not performed by the Mastercard card network due to system connectivity issues.
     */
    'verification_result'?: string;
    /**
     * Transaction participant who determined the verification result.
     */
    'verification_value_created_by'?: string;
}
/**
 * Returns general purpose account (GPA) balances for a user or business.
 */
export interface CardholderBalance {
    /**
     * Ledger balance minus any authorized transactions that have not yet cleared. Also known as the cardholder\'s purchasing power. When using JIT Funding, this balance is usually equal to $0.00.
     */
    'available_balance': number;
    /**
     * Contains GPA balance information, organized by currency code.
     */
    'balances': { [key: string]: CardholderBalance; };
    /**
     * Not currently in use.
     */
    'cached_balance'?: number;
    /**
     * Not currently in use.
     */
    'credit_balance': number;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * Balance change based on the amount of the transaction.
     */
    'impacted_amount'?: number;
    /**
     * Date and time when the resource was last updated, in UTC.
     */
    'last_updated_time': string;
    /**
     * When using standard funding: The funds that are available to spend immediately, including funds from any authorized transactions that have not yet cleared. When using Just-in-Time (JIT) Funding: Authorized funds that are currently on hold, but not yet cleared.
     */
    'ledger_balance': number;
    /**
     * ACH loads that have been accepted, but for which the funding time has not yet elapsed.
     */
    'pending_credits': number;
}
export interface CardholderBalances {
    'gpa': CardholderBalance;
    'links': Set<Link>;
}
/**
 * Contains customer-provided information about the cardholder that performed the transaction.
 */
export interface CardholderMetadata {
    /**
     * Associates customer-provided metadata with the cardholder.
     */
    'metadata'?: { [key: string]: string; };
}
export interface CardholderNoteRequestModel {
    'created_by': string;
    'created_by_user_role'?: CardholderNoteRequestModelCreatedByUserRoleEnum;
    'description': string;
    'private'?: boolean;
    'token'?: string;
}

export const CardholderNoteRequestModelCreatedByUserRoleEnum = {
    User: 'USER',
    Admin: 'ADMIN',
    BankUser: 'BANK_USER',
    BankAdmin: 'BANK_ADMIN',
    MarqetaPd: 'MARQETA_PD',
    MarqetaAdmin: 'MARQETA_ADMIN'
} as const;

export type CardholderNoteRequestModelCreatedByUserRoleEnum = typeof CardholderNoteRequestModelCreatedByUserRoleEnum[keyof typeof CardholderNoteRequestModelCreatedByUserRoleEnum];

export interface CardholderNoteResponseModel {
    'created_by': string;
    'created_by_user_role'?: CardholderNoteResponseModelCreatedByUserRoleEnum;
    'created_time'?: string;
    'description': string;
    'last_modified_time'?: string;
    'private'?: boolean;
    'token'?: string;
}

export const CardholderNoteResponseModelCreatedByUserRoleEnum = {
    User: 'USER',
    Admin: 'ADMIN',
    BankUser: 'BANK_USER',
    BankAdmin: 'BANK_ADMIN',
    MarqetaPd: 'MARQETA_PD',
    MarqetaAdmin: 'MARQETA_ADMIN'
} as const;

export type CardholderNoteResponseModelCreatedByUserRoleEnum = typeof CardholderNoteResponseModelCreatedByUserRoleEnum[keyof typeof CardholderNoteResponseModelCreatedByUserRoleEnum];

export interface CardholderNoteUpdateRequestModel {
    'description': string;
}
/**
 * Specifies attributes of the card carrier.
 */
export interface Carrier {
    /**
     * Specifies an image to display on the card carrier.
     */
    'logo_file'?: string;
    /**
     * Specifies a thumbnail-sized rendering of the image specified in the `logo_file` field.
     */
    'logo_thumbnail_file'?: string;
    /**
     * Specifies a text file containing a custom message to print on the card carrier.
     */
    'message_file'?: string;
    /**
     * Specifies a custom message that appears on the card carrier.
     */
    'message_line'?: string;
    /**
     * Specifies the second line of a custom message that appears on the card carrier.
     */
    'message_line_2'?: string;
    /**
     * Specifies the card carrier template to use.
     */
    'template_id'?: string;
}
export interface CashloadsResponseModel {
    'vendor_product_id'?: string;
}
export interface ChargebackAllocationAckRequest {
    'chargeback_token': string;
    'token'?: string;
}
export interface ChargebackFundingSourceModel extends FundingSourceModel {
    'credit': boolean;
    'name': string;
}
export interface ChargebackListResponse {
    'count'?: number;
    'data'?: Array<ChargebackResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface ChargebackRequest {
    'amount': number;
    'channel': ChargebackRequestChannelEnum;
    'credit_user'?: boolean;
    'currency_code'?: string;
    'memo'?: string;
    'pre_initiated'?: boolean;
    /**
     * Either \'reason_code\' or \'reason_description\' is required
     */
    'reason_code'?: string;
    /**
     * Either \'reason_description\' or \'reason_code\' is required
     */
    'reason_description'?: ChargebackRequestReasonDescriptionEnum;
    'regulation_type'?: string;
    'status'?: ChargebackRequestStatusEnum;
    'token'?: string;
    'transaction_token': string;
}

export const ChargebackRequestChannelEnum = {
    Gateway: 'GATEWAY',
    GatewayAutomated: 'GATEWAY_AUTOMATED',
    Issuer: 'ISSUER',
    IssuerAutomated: 'ISSUER_AUTOMATED'
} as const;

export type ChargebackRequestChannelEnum = typeof ChargebackRequestChannelEnum[keyof typeof ChargebackRequestChannelEnum];
export const ChargebackRequestReasonDescriptionEnum = {
    ServiceNotProvidedMerchandiseNotReceived: 'SERVICE_NOT_PROVIDED_MERCHANDISE_NOT_RECEIVED',
    CancelledRecurringTransaction: 'CANCELLED_RECURRING_TRANSACTION',
    NotAsDescribedOrDefectiveMerchandise: 'NOT_AS_DESCRIBED_OR_DEFECTIVE_MERCHANDISE',
    FraudMultipleTransactions: 'FRAUD_MULTIPLE_TRANSACTIONS',
    FraudTransaction: 'FRAUD_TRANSACTION',
    NoAuthorization: 'NO_AUTHORIZATION',
    LatePresentment: 'LATE_PRESENTMENT',
    TransactionNotRecognized: 'TRANSACTION_NOT_RECOGNIZED',
    IncorrectCurrency: 'INCORRECT_CURRENCY',
    IncorrectTransactionCode: 'INCORRECT_TRANSACTION_CODE',
    IncorrectCurrencyOrTransactionCode: 'INCORRECT_CURRENCY_OR_TRANSACTION_CODE',
    IncorrectTransactionAmount: 'INCORRECT_TRANSACTION_AMOUNT',
    IncorrectAccountNumber: 'INCORRECT_ACCOUNT_NUMBER',
    IncorrectTransactionAmountOrAccountNumber: 'INCORRECT_TRANSACTION_AMOUNT_OR_ACCOUNT_NUMBER',
    NotAuthorizedCardPresent: 'NOT_AUTHORIZED_CARD_PRESENT',
    NotAuthorizedCardAbsent: 'NOT_AUTHORIZED_CARD_ABSENT',
    CreditNotProcessed: 'CREDIT_NOT_PROCESSED',
    NonReceiptOfCashOrLoadTransactionValueAtAtm: 'NON_RECEIPT_OF_CASH_OR_LOAD_TRANSACTION_VALUE_AT_ATM',
    DuplicateProcessingOrPaidByOtherMeans: 'DUPLICATE_PROCESSING_OR_PAID_BY_OTHER_MEANS'
} as const;

export type ChargebackRequestReasonDescriptionEnum = typeof ChargebackRequestReasonDescriptionEnum[keyof typeof ChargebackRequestReasonDescriptionEnum];
export const ChargebackRequestStatusEnum = {
    Arbitration: 'ARBITRATION',
    CaseLost: 'CASE_LOST',
    CaseWon: 'CASE_WON',
    Initiated: 'INITIATED',
    NetworkRejected: 'NETWORK_REJECTED',
    Prearbitration: 'PREARBITRATION',
    PreInitiated: 'PRE_INITIATED',
    Representment: 'REPRESENTMENT',
    Withdrawn: 'WITHDRAWN',
    WrittenOffIssuer: 'WRITTEN_OFF_ISSUER',
    WrittenOffProgram: 'WRITTEN_OFF_PROGRAM'
} as const;

export type ChargebackRequestStatusEnum = typeof ChargebackRequestStatusEnum[keyof typeof ChargebackRequestStatusEnum];

/**
 * Contains the chargeback object associated with this transaction if a chargeback has been initiated.
 */
export interface ChargebackResponse {
    /**
     * Amount of the chargeback.
     */
    'amount': number;
    /**
     * Channel the chargeback came through.
     */
    'channel': ChargebackResponseChannelEnum;
    /**
     * Date and time when the chargeback was created. Not returned for transactions when the associated chargeback is in the `INITIATED` state.
     */
    'created_time': string;
    /**
     * Whether to credit the user for the chargeback amount.
     */
    'credit_user': boolean;
    'currency_code'?: string;
    /**
     * Date and time when the chargeback was last modified. Not returned for transactions when the associated chargeback is in the `INITIATED` state.
     */
    'last_modified_time': string;
    /**
     * Additional comments about the chargeback.
     */
    'memo'?: string;
    /**
     * Network handling the chargeback.
     */
    'network': ChargebackResponseNetworkEnum;
    /**
     * Network-assigned identifier of the chargeback.
     */
    'network_case_id'?: string;
    /**
     * Identifies the standardized reason for the chargeback.
     */
    'reason_code'?: string;
    /**
     * State of the case.
     */
    'state': ChargebackResponseStateEnum;
    /**
     * Unique identifier of the chargeback.
     */
    'token': string;
    /**
     * Unique identifier of the transaction being charged back.
     */
    'transaction_token': string;
}

export const ChargebackResponseChannelEnum = {
    Gateway: 'GATEWAY',
    GatewayAutomated: 'GATEWAY_AUTOMATED',
    Issuer: 'ISSUER',
    IssuerAutomated: 'ISSUER_AUTOMATED'
} as const;

export type ChargebackResponseChannelEnum = typeof ChargebackResponseChannelEnum[keyof typeof ChargebackResponseChannelEnum];
export const ChargebackResponseNetworkEnum = {
    Marqeta: 'MARQETA',
    Discover: 'DISCOVER',
    Mastercard: 'MASTERCARD',
    Pulse: 'PULSE',
    Visa: 'VISA',
    Americanexpress: 'AMERICANEXPRESS'
} as const;

export type ChargebackResponseNetworkEnum = typeof ChargebackResponseNetworkEnum[keyof typeof ChargebackResponseNetworkEnum];
export const ChargebackResponseStateEnum = {
    Initiated: 'INITIATED',
    Representment: 'REPRESENTMENT',
    Prearbitration: 'PREARBITRATION',
    Arbitration: 'ARBITRATION',
    CaseWon: 'CASE_WON',
    CaseLost: 'CASE_LOST',
    NetworkRejected: 'NETWORK_REJECTED',
    Withdrawn: 'WITHDRAWN',
    RetrievalRequest: 'RETRIEVAL_REQUEST',
    RetrievalResponse: 'RETRIEVAL_RESPONSE'
} as const;

export type ChargebackResponseStateEnum = typeof ChargebackResponseStateEnum[keyof typeof ChargebackResponseStateEnum];

export interface ChargebackTransitionListResponse {
    'count'?: number;
    'data'?: Array<ChargebackTransitionResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface ChargebackTransitionRequest {
    /**
     * Representment or prearbitration amount; this is for transitioning to Representment or Prearbitration only
     */
    'amount'?: number;
    'chargeback_token': string;
    'reason'?: string;
    'regulation_type'?: string;
    'state': ChargebackTransitionRequestStateEnum;
    'token'?: string;
    'type'?: string;
}

export const ChargebackTransitionRequestStateEnum = {
    Representment: 'REPRESENTMENT',
    Prearbitration: 'PREARBITRATION',
    PrearbResponded: 'PREARB_RESPONDED',
    Arbitration: 'ARBITRATION',
    CaseWon: 'CASE_WON',
    CaseLost: 'CASE_LOST',
    WrittenOffIssuer: 'WRITTEN_OFF_ISSUER',
    WrittenOffProgram: 'WRITTEN_OFF_PROGRAM',
    ArbitrationResponse: 'ARBITRATION_RESPONSE',
    ArbitrationDecision: 'ARBITRATION_DECISION',
    RetrievalRequest: 'RETRIEVAL_REQUEST',
    RetrievalResponse: 'RETRIEVAL_RESPONSE'
} as const;

export type ChargebackTransitionRequestStateEnum = typeof ChargebackTransitionRequestStateEnum[keyof typeof ChargebackTransitionRequestStateEnum];

export interface ChargebackTransitionResponse {
    'amount'?: number;
    'channel': ChargebackTransitionResponseChannelEnum;
    'chargeback_token': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'previous_state': ChargebackTransitionResponsePreviousStateEnum;
    'reason'?: string;
    'state': ChargebackTransitionResponseStateEnum;
    'token': string;
    'transaction_token'?: string;
    'type': ChargebackTransitionResponseTypeEnum;
}

export const ChargebackTransitionResponseChannelEnum = {
    Gateway: 'GATEWAY',
    GatewayAutomated: 'GATEWAY_AUTOMATED',
    Issuer: 'ISSUER',
    IssuerAutomated: 'ISSUER_AUTOMATED'
} as const;

export type ChargebackTransitionResponseChannelEnum = typeof ChargebackTransitionResponseChannelEnum[keyof typeof ChargebackTransitionResponseChannelEnum];
export const ChargebackTransitionResponsePreviousStateEnum = {
    Initiated: 'INITIATED',
    Representment: 'REPRESENTMENT',
    Prearbitration: 'PREARBITRATION',
    Arbitration: 'ARBITRATION',
    CaseWon: 'CASE_WON',
    CaseLost: 'CASE_LOST',
    NetworkRejected: 'NETWORK_REJECTED',
    Withdrawn: 'WITHDRAWN',
    ArbitrationResponse: 'ARBITRATION_RESPONSE',
    ArbitrationDecision: 'ARBITRATION_DECISION'
} as const;

export type ChargebackTransitionResponsePreviousStateEnum = typeof ChargebackTransitionResponsePreviousStateEnum[keyof typeof ChargebackTransitionResponsePreviousStateEnum];
export const ChargebackTransitionResponseStateEnum = {
    Initiated: 'INITIATED',
    Representment: 'REPRESENTMENT',
    Prearbitration: 'PREARBITRATION',
    Arbitration: 'ARBITRATION',
    CaseWon: 'CASE_WON',
    CaseLost: 'CASE_LOST',
    NetworkRejected: 'NETWORK_REJECTED',
    Withdrawn: 'WITHDRAWN',
    WrittenOffIssuer: 'WRITTEN_OFF_ISSUER',
    WrittenOffProgram: 'WRITTEN_OFF_PROGRAM',
    ArbitrationResponse: 'ARBITRATION_RESPONSE',
    ArbitrationDecision: 'ARBITRATION_DECISION'
} as const;

export type ChargebackTransitionResponseStateEnum = typeof ChargebackTransitionResponseStateEnum[keyof typeof ChargebackTransitionResponseStateEnum];
export const ChargebackTransitionResponseTypeEnum = {
    Initiated: 'initiated',
    Representment: 'representment',
    Prearbitration: 'prearbitration',
    Arbitration: 'arbitration',
    CaseWon: 'case.won',
    CaseLost: 'case.lost',
    NetworkRejected: 'network.rejected',
    WrittenOffIssuer: 'written.off.issuer',
    WrittenOffProgram: 'written.off.program'
} as const;

export type ChargebackTransitionResponseTypeEnum = typeof ChargebackTransitionResponseTypeEnum[keyof typeof ChargebackTransitionResponseTypeEnum];

export interface ChargebackUpdateRequest {
    /**
     * Either \'reason_code\' or \'reason_description\' is required
     */
    'reason_code'?: string;
    /**
     * Either \'reason_description\' or \'reason_code\' is required
     */
    'reason_description'?: ChargebackUpdateRequestReasonDescriptionEnum;
    'status'?: ChargebackUpdateRequestStatusEnum;
}

export const ChargebackUpdateRequestReasonDescriptionEnum = {
    ServiceNotProvidedMerchandiseNotReceived: 'SERVICE_NOT_PROVIDED_MERCHANDISE_NOT_RECEIVED',
    CancelledRecurringTransaction: 'CANCELLED_RECURRING_TRANSACTION',
    NotAsDescribedOrDefectiveMerchandise: 'NOT_AS_DESCRIBED_OR_DEFECTIVE_MERCHANDISE',
    FraudMultipleTransactions: 'FRAUD_MULTIPLE_TRANSACTIONS',
    FraudTransaction: 'FRAUD_TRANSACTION',
    NoAuthorization: 'NO_AUTHORIZATION',
    LatePresentment: 'LATE_PRESENTMENT',
    TransactionNotRecognized: 'TRANSACTION_NOT_RECOGNIZED',
    IncorrectCurrency: 'INCORRECT_CURRENCY',
    IncorrectTransactionCode: 'INCORRECT_TRANSACTION_CODE',
    IncorrectCurrencyOrTransactionCode: 'INCORRECT_CURRENCY_OR_TRANSACTION_CODE',
    IncorrectTransactionAmount: 'INCORRECT_TRANSACTION_AMOUNT',
    IncorrectAccountNumber: 'INCORRECT_ACCOUNT_NUMBER',
    IncorrectTransactionAmountOrAccountNumber: 'INCORRECT_TRANSACTION_AMOUNT_OR_ACCOUNT_NUMBER',
    NotAuthorizedCardPresent: 'NOT_AUTHORIZED_CARD_PRESENT',
    NotAuthorizedCardAbsent: 'NOT_AUTHORIZED_CARD_ABSENT',
    CreditNotProcessed: 'CREDIT_NOT_PROCESSED',
    NonReceiptOfCashOrLoadTransactionValueAtAtm: 'NON_RECEIPT_OF_CASH_OR_LOAD_TRANSACTION_VALUE_AT_ATM',
    DuplicateProcessingOrPaidByOtherMeans: 'DUPLICATE_PROCESSING_OR_PAID_BY_OTHER_MEANS'
} as const;

export type ChargebackUpdateRequestReasonDescriptionEnum = typeof ChargebackUpdateRequestReasonDescriptionEnum[keyof typeof ChargebackUpdateRequestReasonDescriptionEnum];
export const ChargebackUpdateRequestStatusEnum = {
    Arbitration: 'ARBITRATION',
    CaseLost: 'CASE_LOST',
    CaseWon: 'CASE_WON',
    Initiated: 'INITIATED',
    NetworkRejected: 'NETWORK_REJECTED',
    Prearbitration: 'PREARBITRATION',
    PreInitiated: 'PRE_INITIATED',
    Representment: 'REPRESENTMENT',
    Withdrawn: 'WITHDRAWN',
    WrittenOffIssuer: 'WRITTEN_OFF_ISSUER',
    WrittenOffProgram: 'WRITTEN_OFF_PROGRAM'
} as const;

export type ChargebackUpdateRequestStatusEnum = typeof ChargebackUpdateRequestStatusEnum[keyof typeof ChargebackUpdateRequestStatusEnum];

export interface ClearingAndSettlement {
    /**
     * Default value of GPA does not apply when JIT funding is enabled
     */
    'overdraft_destination'?: ClearingAndSettlementOverdraftDestinationEnum;
}

export const ClearingAndSettlementOverdraftDestinationEnum = {
    Gpa: 'GPA',
    Msa: 'MSA',
    MerchantCampaignAccount: 'MERCHANT_CAMPAIGN_ACCOUNT',
    GlobalOverdraftAccount: 'GLOBAL_OVERDRAFT_ACCOUNT'
} as const;

export type ClearingAndSettlementOverdraftDestinationEnum = typeof ClearingAndSettlementOverdraftDestinationEnum[keyof typeof ClearingAndSettlementOverdraftDestinationEnum];

export interface ClearingModel {
    'amount': number;
    'card_acceptor'?: CardAcceptorModel;
    'force_post'?: boolean;
    'is_refund'?: boolean;
    'mid'?: string;
    'network_fees'?: Array<NetworkFeeModel>;
    'original_transaction_token': string;
    'webhook'?: Webhook;
}
export interface ClickToPayCheckEligibilityResponse {
    /**
     * List of image assets for the Click to Pay logo if `include_asset` is set to `true` in the request.
     */
    'image_assets'?: Array<MediaContent>;
    /**
     * Indicates whether the `bin_prefix` is eligible for Click to Pay.  * `true`: The `bin_prefix` is eligible for Click to Pay. * `false`: The `bin_prefix` is not eligible for Click to Pay.
     */
    'is_eligible'?: boolean;
}
export interface ClickToPayEnrollRequest {
    /**
     * Basic auth password to access your callback URL if authentication type is basic. If authentication type is basic, both username and password are required.
     */
    'basic_auth_password'?: string;
    /**
     * Basic auth username to access your callback URL if authentication type is basic. If authentication type is basic, both username and password are required.
     */
    'basic_auth_username'?: string;
    /**
     * The type of authentication required for the callback URL.  * `OAUTH_BEARER_TOKEN`: OAuth bearer token for the callback URL. * `BASIC_AUTH`: Basic auth username and password for the callback URL.
     */
    'callback_authentication_type'?: ClickToPayEnrollRequestCallbackAuthenticationTypeEnum;
    /**
     * Randomly chosen string used for implementing HMAC-SHA1.  HMAC-SHA1 provides an added layer of security by authenticating the message and validating message integrity. Using this functionality requires that your callback endpoint verify the message signature. For information about implementing this functionality, see <</developer-guides/signature-verification, Signature Verification>>.
     */
    'callback_secret_for_signature'?: string;
    /**
     * The URL to which the Click to Pay request status is sent via webhooks.
     */
    'callback_url'?: string;
    /**
     * Unique identifier of the card resource.
     */
    'card_token': string;
    /**
     * The user-provided country code. The ISO 3166 country code is a two-letter country code that represents a country. For example, the numeric code for the United States is `US`.  The ISO maintains the link:https://www.iso.org/iso-3166-country-codes.html[ISO-3166 country codes, window=\"_blank\"].
     */
    'locale_country': string;
    /**
     * The user-provided language choice. The ISO 639-2 language code is a two-letter country code that represents a language.  The ISO maintains the link:https://id.loc.gov/vocabulary/iso639-2.html[ISO 639-2 language codes, window=\"_blank\"].
     */
    'locale_language': string;
    /**
     * OAuth bearer token to access your callback URL if the `callback_authentication_type` is `OAUTH_BEARER_TOKEN`.
     */
    'oauth_bearer_token'?: string;
    /**
     * User\'s email address and mobile phone number with country code.
     */
    'user_details': Array<ClickToPayEnrollRequestUserDetails>;
    /**
     * Unique identifier of the cardholder.
     */
    'user_token': string;
}

export const ClickToPayEnrollRequestCallbackAuthenticationTypeEnum = {
    OauthBearerToken: 'OAUTH_BEARER_TOKEN',
    BasicAuth: 'BASIC_AUTH'
} as const;

export type ClickToPayEnrollRequestCallbackAuthenticationTypeEnum = typeof ClickToPayEnrollRequestCallbackAuthenticationTypeEnum[keyof typeof ClickToPayEnrollRequestCallbackAuthenticationTypeEnum];

/**
 * User\'s email address and mobile phone number with country code.
 */
export interface ClickToPayEnrollRequestUserDetails {
    /**
     * User\'s email address.
     */
    'email_address': string;
    'mobile_number': ClickToPayEnrollRequestUserMobileNumber;
}
/**
 * User\'s mobile phone number and country code.
 */
export interface ClickToPayEnrollRequestUserMobileNumber {
    /**
     * User\'s mobile phone number country code only.
     */
    'country_code': string;
    /**
     * User\'s mobile phone number without country code.
     */
    'phone_number': string;
}
export interface ClickToPayEnrollResponse {
    /**
     * Unique identifier of the Click to Pay request.
     */
    'token'?: string;
}
export interface ClickToPayStatusResponse {
    /**
     * The status of the Click to Pay request.  * `SUCCESS`: The Click to Pay request was successful. * `FAILED`: The Click to Pay request failed. * `RECEIVED`: The Click to Pay request was received.
     */
    'status'?: ClickToPayStatusResponseStatusEnum;
    /**
     * Unique identifier of the Click to Pay request, used to track the status of the request.
     */
    'token'?: string;
    /**
     * Unique identifier of the digital wallet token within the card network.
     */
    'token_reference_id'?: string;
}

export const ClickToPayStatusResponseStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED',
    Received: 'RECEIVED'
} as const;

export type ClickToPayStatusResponseStatusEnum = typeof ClickToPayStatusResponseStatusEnum[keyof typeof ClickToPayStatusResponseStatusEnum];

export interface ClientAccessTokenRequest {
    /**
     * Unique identifier of the `application` object.
     */
    'application_token'?: string;
    /**
     * Unique identifier of the card whose sensitive information you want to display.
     */
    'card_token': string;
}
export interface ClientAccessTokenResponse {
    'application'?: Application;
    /**
     * Unique identifier of the card whose sensitive information you want to display.
     */
    'card_token'?: string;
    /**
     * Date and time when the client access token was created, in UTC.
     */
    'created'?: string;
    /**
     * Date and time when the client access token expires, in UTC.
     */
    'expires'?: string;
    /**
     * Value of the client access token to redeem when displaying sensitive card data.
     */
    'token'?: string;
}
export interface CommandoModeEnables {
    'auth_controls'?: Array<string>;
    'ignore_card_suspended_state'?: boolean;
    'program_funding_source': string;
    'use_cache_balance'?: boolean;
    'velocity_controls'?: Array<string>;
}
export interface CommandoModeListResponse {
    'count'?: number;
    'data'?: Array<CommandoModeResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface CommandoModeNestedTransition {
    'channel': CommandoModeNestedTransitionChannelEnum;
    'commando_enabled': boolean;
    'reason'?: string;
    'username'?: string;
}

export const CommandoModeNestedTransitionChannelEnum = {
    Api: 'API',
    System: 'SYSTEM',
    Admin: 'ADMIN'
} as const;

export type CommandoModeNestedTransitionChannelEnum = typeof CommandoModeNestedTransitionChannelEnum[keyof typeof CommandoModeNestedTransitionChannelEnum];

export interface CommandoModeResponse {
    'commando_mode_enables'?: CommandoModeEnables;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'current_state'?: CommandoModeNestedTransition;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'program_gateway_funding_source_token'?: string;
    'real_time_standin_criteria'?: RealTimeStandinCriteria;
    'token'?: string;
}
export interface CommandoModeTransitionListResponse {
    'count'?: number;
    'data'?: Array<CommandoModeTransitionResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface CommandoModeTransitionResponse {
    'commando_mode_token'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'name'?: string;
    'token'?: string;
    'transition'?: CommandoModeNestedTransition;
    'type'?: string;
}
/**
 * Contains information on a fee schedule.
 */
export interface ConfigFeeScheduleEntry {
    /**
     * Date and time when the fee goes into effect, in UTC.
     */
    'effective_date'?: string;
    'method': FeeMethod;
    /**
     * Amount of the fee.
     */
    'value': number;
}


/**
 * Contains information relevant to configuring fees.
 */
export interface ConfigFeeScheduleReq {
    /**
     * Contains one or more fee schedules.
     */
    'schedule': Array<ConfigFeeScheduleEntry>;
    'type': AccountProductFeeType;
}


/**
 * Contains information returned when configuring fees.
 */
export interface ConfigFeeScheduleResponse {
    /**
     * Whether the fee is active.
     */
    'active'?: boolean;
    /**
     * Date and time when the fee was created on Marqeta\'s credit platform, in UTC.
     */
    'created_date'?: string;
    /**
     * Contains one or more fee schedules.
     */
    'schedule'?: Array<ConfigFeeScheduleEntry>;
    'type'?: AccountProductFeeType;
    /**
     * Date and time when the fee was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_date'?: string;
}


export interface ControlTokenRequest {
    /**
     * The unique identifier of the card for which you want to generate a control token.
     */
    'card_token': string;
    /**
     * Specifies the type of action completed by this request.  *WARNING:* Sending a request to this endpoint with a `REVEAL_PIN` control token requires PCI DSS compliance.  The lifespan of the control token depends on the token type:  * *SET_PIN:* 60 minutes * *REVEAL_PIN:* 5 minutes
     */
    'controltoken_type'?: ControlTokenRequestControltokenTypeEnum;
}

export const ControlTokenRequestControltokenTypeEnum = {
    SetPin: 'SET_PIN',
    RevealPin: 'REVEAL_PIN'
} as const;

export type ControlTokenRequestControltokenTypeEnum = typeof ControlTokenRequestControltokenTypeEnum[keyof typeof ControlTokenRequestControltokenTypeEnum];

export interface ControlTokenResponse {
    /**
     * Unique value generated as a result of issuing a `POST` request to the `/pins/controltoken` endpoint. This value cannot be updated.
     */
    'control_token': string;
}
export interface CreateReport200Response {
    /**
     * Unique identifier of the report
     */
    'reportId'?: string;
}
export interface CurrencyBalance {
    'available_balance'?: number;
    'cached_balance'?: number;
    'credit_balance'?: number;
    'impacted_amount'?: number;
    'ledger_balance'?: number;
    'pending_credits'?: number;
}
/**
 * Valid three-digit link:https://www.iso.org/iso-4217-currency-codes.html[ISO 4217 currency code, window=\"_blank\"].
 */

export const CurrencyCode = {
    Usd: 'USD'
} as const;

export type CurrencyCode = typeof CurrencyCode[keyof typeof CurrencyCode];


/**
 * Contains information about currency conversion.
 */
export interface CurrencyConversion {
    'network'?: Network;
}
export interface CustomerDueDiligenceRequest {
    'answer': string;
    'question': string;
    'token'?: string;
}
export interface CustomerDueDiligenceResponse {
    'account_token': string;
    'answer': string;
    'bank': string;
    'question': string;
    'token': string;
    'type': string;
}
export interface CustomerDueDiligenceUpdateRequest {
    'answer'?: string;
}
export interface CustomerDueDiligenceUpdateResponse {
    'answer'?: string;
}
/**
 * Type of cycle.  * `BEGINNING_REVOLVING` - Account is beginning to revolve and just started carrying a balance from the previous month. * `REVOLVING` - Account is revolving and has been carrying a balance from month to month for more than one month. * `END_REVOLVING` - Account is no longer revolving and the previous month\'s balance is paid off. * `TRANSACTING` - Account is not revolving and the balance is paid off each month.
 */

export const CycleType = {
    BeginningRevolving: 'BEGINNING_REVOLVING',
    Revolving: 'REVOLVING',
    EndRevolving: 'END_REVOLVING',
    Transacting: 'TRANSACTING'
} as const;

export type CycleType = typeof CycleType[keyof typeof CycleType];


export interface DDARequest {
    'dda': string;
}
/**
 * One or more delinquency buckets for an account. Each delinquency bucket represents a billing cycle during which the account was delinquent.
 */
export interface DelinquencyBucketResponse {
    /**
     * Delinquency bucket number in the returned array. Delinquency buckets are returned from most recent to least; the most recent delinquency bucket is `1`.
     */
    'bucket_number': number;
    /**
     * Current amount that is due for this delinquency bucket.
     */
    'current_due': number;
    /**
     * Total number of days that the payment is past due for this delinquency bucket.
     */
    'days_past_due': number;
    /**
     * Amount that is past due and carried forward from previous delinquency buckets.
     */
    'past_due_carried_forward': number;
    /**
     * Date that the payment was due for this delinquency bucket.
     */
    'payment_due_date': string;
    /**
     * Total amount that is due for this delinquency bucket; the sum of `past_due_carried_forward` and `current_due`.
     */
    'total_due': number;
}
/**
 * Contains details of the delinquency state of an account.
 */
export interface DelinquencyStateResponse {
    /**
     * Unique identifier of the credit account.
     */
    'account_token': string;
    /**
     * One or more delinquency buckets for an account. Each delinquency bucket represents a billing cycle during which the account was delinquent.
     */
    'buckets'?: Array<DelinquencyBucketResponse>;
    /**
     * Amount that is due for the current billing cycle.
     */
    'current_due': number;
    /**
     * Date and time when the account was last made current on the Marqeta platform, in UTC.  If the account was never delinquent, this field returns the date and time the account was created on the Marqeta platform, in UTC.  If `is_delinquent` is `true`, a null value is returned.
     */
    'date_account_current'?: string | null;
    /**
     * Date and time when the account last fell delinquent on the Marqeta platform, in UTC.  If `is_delinquent` is `false`, a null value is returned.
     */
    'date_account_delinquent'?: string | null;
    /**
     * Total number of days that the account is past the oldest buckets statement end date
     */
    'delinquent_days_past_statement_end_date'?: number;
    /**
     * A value of `true` indicates that the account is currently delinquent.
     */
    'is_delinquent': boolean;
    /**
     * Total number of days that the account is past due.
     */
    'total_days_past_due': number;
    /**
     * Total amount that is due for the current billing cycle; the sum of `total_past_due_amount` and `current_due_amount`.
     */
    'total_due': number;
    /**
     * Total amount that is past due.
     */
    'total_past_due': number;
}
/**
 * Delinquency status of an account.
 */

export const DelinquencyStatus = {
    Current: 'CURRENT',
    Delinquent: 'DELINQUENT'
} as const;

export type DelinquencyStatus = typeof DelinquencyStatus[keyof typeof DelinquencyStatus];


/**
 * Contains details of the account\'s delinquency state transition.
 */
export interface DelinquencyTransitionResponse {
    /**
     * Unique identifier of the credit account.
     */
    'account_token': string;
    /**
     * Number of buckets for the account after the triggering event occurred.
     */
    'bucket_count'?: number;
    /**
     * Date and time when the delinquency state transition was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    /**
     * Current amount that is due after the triggering event occurred.  Equivalent to `current_due` for the account\'s most recent delinquency bucket. To retrieve delinquency buckets for an account, send a `GET` request to `/credit/accounts/{account_token}/delinquencystate`.
     */
    'current_due'?: number;
    /**
     * Date and time when the triggering event impacted the account, in UTC.
     */
    'impact_time': string;
    /**
     * A value of `true` indicates that the system invalidated and rolled back the delinquency transition.  This is a temporary field that allows Marqeta to handle occasional cases of out-of-order processing. This can occur when two delinquency state transition webhooks are sent near-simultaneously.  For example, if a credit and a payment that bring an account current are made around the same time, two delinquency state transitions are sent very close together. In these cases, one of the transitions is rolled back and invalidated. For the transition that is rolled back, `is_rolled_back` is `true` and the transition should be ignored.  This field is temporary and to be deprecated when out-of-order processing is addressed in a future release.
     */
    'is_rolled_back': boolean;
    /**
     * Payment due date of the account\'s oldest delinquency bucket, in UTC.  Useful when used with the delinquency state transition\'s `created_time` to determine the total number of days a payment is past due.
     */
    'oldest_payment_due_date'?: string;
    'original_status': DelinquencyStatus;
    'status': DelinquencyStatus;
    /**
     * Unique identifier of the delinquency state transition.
     */
    'token': string;
    /**
     * Total amount that is due after the triggering event occurred; the sum of `total_past_due` and `current_due`.  Equivalent to `total_due` for the account\'s most recent delinquency bucket. To retrieve delinquency buckets for an account, send a `GET` request to `/credit/accounts/{account_token}/delinquencystate`.
     */
    'total_due'?: number;
    /**
     * Total amount that is past due after the triggering event occurred.  Equivalent to `past_due_carried_forward` for the account\'s most recent delinquency bucket. To retrieve delinquency buckets for an account, send a `GET` request to `/credit/accounts/{account_token}/delinquencystate`.
     */
    'total_past_due'?: number;
    'transition_trigger_reason': DelinquencyTransitionTriggerReason;
    /**
     * Date and time when the triggering event caused the account\'s delinquency state to transition, in UTC.  For <</core-api/credit-account-journal-entries, journal entries>>, equivalent to `request_time`. For <</core-api/credit-account-statements#listStatementJournalEntries, statement journal entries>>, equivalent to `impact_time`,
     */
    'transition_trigger_time': string;
    /**
     * Date and time when the delinquency state transition was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}


/**
 * Event that triggered an update to the account\'s delinquency state.
 */

export const DelinquencyTransitionTriggerReason = {
    Payment: 'PAYMENT',
    PaymentVoid: 'PAYMENT_VOID',
    Credit: 'CREDIT',
    MinimumPaymentOverride: 'MINIMUM_PAYMENT_OVERRIDE',
    StatementGeneration: 'STATEMENT_GENERATION',
    Reage: 'REAGE',
    PastMinPaymentDue: 'PAST_MIN_PAYMENT_DUE'
} as const;

export type DelinquencyTransitionTriggerReason = typeof DelinquencyTransitionTriggerReason[keyof typeof DelinquencyTransitionTriggerReason];


/**
 * Returns paginated information for multiple delinquency state transitions.
 */
export interface DelinquencyTransitionsResponsePage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * List of delinquency state transitions.
     */
    'data': Array<DelinquencyTransitionResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
export interface DepositAccountResponse {
    'account_number': string;
    'allow_immediate_credit'?: boolean;
    'business_token'?: string;
    'routing_number': string;
    'token': string;
    'user_token'?: string;
}
export interface DepositAccountUpdateRequest {
    'allow_immediate_credit'?: boolean;
}
/**
 * Contains information about a direct deposit.
 */
export interface DepositDepositResponse {
    /**
     * Amount being debited or credited.
     */
    'amount'?: number;
    /**
     * The unique identifier of the business account holder.
     */
    'business_token'?: string;
    /**
     * Company-specific data provided by the direct deposit originator.
     */
    'company_discretionary_data'?: string;
    /**
     * Company-specific data provided by the direct deposit originator.
     */
    'company_entry_description'?: string;
    /**
     * Alphanumeric code that identifies the direct deposit originator.
     */
    'company_identification'?: string;
    /**
     * Name of the direct deposit originator.
     */
    'company_name'?: string;
    /**
     * Date and time when the direct deposit account was created.
     */
    'created_time'?: string;
    /**
     * The unique identifier of the direct deposit account.
     */
    'direct_deposit_account_token'?: string;
    /**
     * Accounting number by which the recipient is known to the direct deposit originator.
     */
    'individual_identification_number'?: string;
    /**
     * Name of the direct deposit recipient.
     */
    'individual_name'?: string;
    /**
     * Date and time when the direct deposit account was last modified.
     */
    'last_modified_time'?: string;
    /**
     * Date and time when the credit or debit is applied.
     */
    'settlement_date'?: string;
    /**
     * Three-letter code identifying the type of entry.
     */
    'standard_entry_class_code'?: string;
    /**
     * Current status of the direct deposit record.
     */
    'state'?: DepositDepositResponseStateEnum;
    /**
     * Explanation for why the direct deposit record is in the current state.
     */
    'state_reason'?: string;
    /**
     * Standard code describing the reason for the current state.
     */
    'state_reason_code'?: string;
    /**
     * The unique identifier of the direct deposit record.
     */
    'token'?: string;
    /**
     * Determines whether funds are being debited from or credited to the account.
     */
    'type'?: DepositDepositResponseTypeEnum;
    /**
     * The unique identifier of the user account holder.
     */
    'user_token'?: string;
}

export const DepositDepositResponseStateEnum = {
    Pending: 'PENDING',
    Applied: 'APPLIED',
    Reversed: 'REVERSED',
    Rejected: 'REJECTED'
} as const;

export type DepositDepositResponseStateEnum = typeof DepositDepositResponseStateEnum[keyof typeof DepositDepositResponseStateEnum];
export const DepositDepositResponseTypeEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT'
} as const;

export type DepositDepositResponseTypeEnum = typeof DepositDepositResponseTypeEnum[keyof typeof DepositDepositResponseTypeEnum];

/**
 * Contains information related to the device being provisioned.
 */
export interface Device {
    /**
     * Identity number of the device.
     */
    'device_id'?: string;
    /**
     * Device\'s IP address.
     */
    'ip_address'?: string;
    /**
     * Language the device is configured to use.
     */
    'language_code'?: string;
    /**
     * Geographic coordinates of the device.
     */
    'location'?: string;
    /**
     * Name of the device.
     */
    'name'?: string;
    /**
     * Device\'s telephone number.
     */
    'phone_number'?: string;
    /**
     * Unique identifier of the device object.
     */
    'token'?: string;
    /**
     * Type of device being provisioned.
     */
    'type'?: string;
}
export interface DigitalServiceProvider {
    'cvm_authentication_indicator'?: string;
    'cvm_authentication_method'?: string;
    'digital_service_indicator'?: string;
    'digital_service_provider_identifier_1'?: string;
    'digital_service_provider_identifier_2'?: string;
    'digital_service_provider_type_1'?: string;
    'digital_service_provider_type_2'?: string;
    'first_authentication_factor'?: string;
    'first_authentication_factor_name'?: DigitalServiceProviderFirstAuthenticationFactorNameEnum;
    'second_authentication_factor'?: string;
    'second_authentication_factor_name'?: DigitalServiceProviderSecondAuthenticationFactorNameEnum;
    'token_service_provider_id'?: string;
}

export const DigitalServiceProviderFirstAuthenticationFactorNameEnum = {
    NoAuthentication: 'NO_AUTHENTICATION',
    DeviceBoundPayment: 'DEVICE_BOUND_PAYMENT',
    UsernamePassword: 'USERNAME_PASSWORD',
    PasscodeOrPassword: 'PASSCODE_OR_PASSWORD',
    BehavioralBiometrics: 'BEHAVIORAL_BIOMETRICS',
    BiometricFingerprint: 'BIOMETRIC_FINGERPRINT',
    BiometricFace: 'BIOMETRIC_FACE',
    BiometricIris: 'BIOMETRIC_IRIS',
    BiometricVoice: 'BIOMETRIC_VOICE',
    OtherBiometrics: 'OTHER_BIOMETRICS',
    KnowledgeBased: 'KNOWLEDGE_BASED',
    InAppLogin: 'IN_APP_LOGIN',
    OtpSms: 'OTP_SMS',
    OtpEmail: 'OTP_EMAIL',
    OtherOtp: 'OTHER_OTP',
    Other: 'OTHER'
} as const;

export type DigitalServiceProviderFirstAuthenticationFactorNameEnum = typeof DigitalServiceProviderFirstAuthenticationFactorNameEnum[keyof typeof DigitalServiceProviderFirstAuthenticationFactorNameEnum];
export const DigitalServiceProviderSecondAuthenticationFactorNameEnum = {
    NoAuthentication: 'NO_AUTHENTICATION',
    DeviceBoundPayment: 'DEVICE_BOUND_PAYMENT',
    UsernamePassword: 'USERNAME_PASSWORD',
    PasscodeOrPassword: 'PASSCODE_OR_PASSWORD',
    BehavioralBiometrics: 'BEHAVIORAL_BIOMETRICS',
    BiometricFingerprint: 'BIOMETRIC_FINGERPRINT',
    BiometricFace: 'BIOMETRIC_FACE',
    BiometricIris: 'BIOMETRIC_IRIS',
    BiometricVoice: 'BIOMETRIC_VOICE',
    OtherBiometrics: 'OTHER_BIOMETRICS',
    KnowledgeBased: 'KNOWLEDGE_BASED',
    InAppLogin: 'IN_APP_LOGIN',
    OtpSms: 'OTP_SMS',
    OtpEmail: 'OTP_EMAIL',
    OtherOtp: 'OTHER_OTP',
    Other: 'OTHER'
} as const;

export type DigitalServiceProviderSecondAuthenticationFactorNameEnum = typeof DigitalServiceProviderSecondAuthenticationFactorNameEnum[keyof typeof DigitalServiceProviderSecondAuthenticationFactorNameEnum];

export interface DigitalWalletAndroidPayProvisionRequest {
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token': string;
    /**
     * Unique identifier of the user\'s Google device, as provided by Google during the provisioning process.
     */
    'device_id': string;
    /**
     * Type of device into which the digital wallet token will be provisioned.
     */
    'device_type': DigitalWalletAndroidPayProvisionRequestDeviceTypeEnum;
    /**
     * Version of the application making the provisioning request. Used for debugging and fraud prevention.
     */
    'provisioning_app_version': string;
    /**
     * User\'s Google Wallet account ID, as provided by Google during the provisioning process.
     */
    'wallet_account_id': string;
}

export const DigitalWalletAndroidPayProvisionRequestDeviceTypeEnum = {
    MobilePhone: 'MOBILE_PHONE',
    Watch: 'WATCH',
    Tablet: 'TABLET',
    WearableDevice: 'WEARABLE_DEVICE',
    HouseholdDevice: 'HOUSEHOLD_DEVICE',
    AutomobileDevice: 'AUTOMOBILE_DEVICE'
} as const;

export type DigitalWalletAndroidPayProvisionRequestDeviceTypeEnum = typeof DigitalWalletAndroidPayProvisionRequestDeviceTypeEnum[keyof typeof DigitalWalletAndroidPayProvisionRequestDeviceTypeEnum];

export interface DigitalWalletAndroidPayProvisionResponse {
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token': string;
    /**
     * Date and time when the digital wallet provisioning request was created, in UTC.
     */
    'created_time': string;
    /**
     * Date and time when the digital wallet token provisioning request was last updated, in UTC.
     */
    'last_modified_time': string;
    'push_tokenize_request_data': AndroidPushTokenizeRequestData;
}
export interface DigitalWalletApplePayProvisionRequest {
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token': string;
    /**
     * Base64-encoded leaf and sub-CA certificates provided by Apple.  The first element of the array should be the leaf certificate, followed by the sub-CA.
     */
    'certificates': Array<string>;
    /**
     * Type of device into which the digital wallet token will be provisioned.
     */
    'device_type': DigitalWalletApplePayProvisionRequestDeviceTypeEnum;
    /**
     * One-time-use nonce provided by Apple for security purposes.
     */
    'nonce': string;
    /**
     * Apple-provided signature to the nonce.
     */
    'nonce_signature': string;
    /**
     * Version of the application making the provisioning request. Used for debugging and fraud prevention.
     */
    'provisioning_app_version': string;
}

export const DigitalWalletApplePayProvisionRequestDeviceTypeEnum = {
    MobilePhone: 'MOBILE_PHONE',
    Watch: 'WATCH',
    Tablet: 'TABLET',
    WearableDevice: 'WEARABLE_DEVICE',
    HouseholdDevice: 'HOUSEHOLD_DEVICE',
    AutomobileDevice: 'AUTOMOBILE_DEVICE'
} as const;

export type DigitalWalletApplePayProvisionRequestDeviceTypeEnum = typeof DigitalWalletApplePayProvisionRequestDeviceTypeEnum[keyof typeof DigitalWalletApplePayProvisionRequestDeviceTypeEnum];

export interface DigitalWalletApplePayProvisionResponse {
    /**
     * Cryptographic one-time passcode conforming to the payment network operator or service provider specifications.
     */
    'activation_data': string;
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token': string;
    /**
     * Date and time when the digital wallet provisioning request was created, in UTC.
     */
    'created_time': string;
    /**
     * Payload encrypted with a shared key derived from the Apple Public Certificates and the generated ephemeral private key.
     */
    'encrypted_pass_data': string;
    /**
     * Ephemeral public key used for the provisioning attempt.
     */
    'ephemeral_public_key': string;
    /**
     * Date and time when the digital wallet token provisioning request was last updated, in UTC.
     */
    'last_modified_time': string;
}
export interface DigitalWalletSamsungPayProvisionRequest {
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token': string;
    /**
     * User\'s Samsung device unique identifier, as provided by Samsung during the provisioning process.
     */
    'device_id': string;
    /**
     * Type of device into which the digital wallet token will be provisioned.
     */
    'device_type': DigitalWalletSamsungPayProvisionRequestDeviceTypeEnum;
    /**
     * Version of the application making the provisioning request. Used for debugging and fraud prevention.
     */
    'provisioning_app_version': string;
    /**
     * User\'s Samsung Wallet account ID, as provided by Samsung during the provisioning process.
     */
    'wallet_user_id': string;
}

export const DigitalWalletSamsungPayProvisionRequestDeviceTypeEnum = {
    MobilePhone: 'MOBILE_PHONE',
    Watch: 'WATCH',
    Tablet: 'TABLET',
    WearableDevice: 'WEARABLE_DEVICE',
    HouseholdDevice: 'HOUSEHOLD_DEVICE',
    AutomobileDevice: 'AUTOMOBILE_DEVICE'
} as const;

export type DigitalWalletSamsungPayProvisionRequestDeviceTypeEnum = typeof DigitalWalletSamsungPayProvisionRequestDeviceTypeEnum[keyof typeof DigitalWalletSamsungPayProvisionRequestDeviceTypeEnum];

export interface DigitalWalletSamsungPayProvisionResponse {
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token': string;
    /**
     * Date and time when the digital wallet provisioning request was created, in UTC.
     */
    'created_time': string;
    /**
     * Date and time when the digital wallet token provisioning request was last updated, in UTC.
     */
    'last_modified_time': string;
    'push_tokenize_request_data': SamsungPushTokenizeRequestData;
}
/**
 * Contains information about the digital wallet that funded the transaction.  Returned for all transactions funded by a digital wallet or related to digital wallet token provisioning.  For more on digital wallets, see the <</core-api/digital-wallets-management, Digital Wallets Management>> API reference and <</developer-guides/digital-wallets-and-tokenization, Digital Wallets and Tokenization>> developer guide.
 */
export interface DigitalWalletToken {
    'address_verification'?: AddressVerification;
    /**
     * Unique identifier of the card.
     */
    'card_token'?: string;
    /**
     * Date and time when the digital wallet token object was created, in UTC.
     */
    'created_time'?: string;
    'device'?: Device;
    /**
     * Digital wallet token\'s provisioning status.  For fulfillment status descriptions, see <</core-api/digital-wallets-management#postDigitalwallettokentransitions, Create digital wallet token transition>>.
     */
    'fulfillment_status'?: string;
    /**
     * The Marqeta platform\'s decision as to whether the digital wallet token should be provisioned.  * *0000*  The token should be provisioned.  * *token.activation.verification.required*  Provisioning is pending; further action is required for completion.  For all other values, check the value of the `fulfillment_status` field to definitively ascertain the provisioning outcome.  *NOTE:* The value `invalid.cid` indicates an invalid CVV2 number.
     */
    'issuer_eligibility_decision'?: string;
    /**
     * Date and time when the digital wallet token object was last modified, in UTC.
     */
    'last_modified_time'?: string;
    'metadata'?: DigitalWalletTokenMetadata;
    /**
     * State of the digital wallet token.  For state descriptions, see <</developer-guides/managing-the-digital-wallet-token-lifecycle#_transitioning_token_states, Transitioning Token States>>.
     */
    'state'?: string;
    /**
     * Reason why the digital wallet token transitioned to its current state.
     */
    'state_reason'?: string;
    /**
     * Unique identifier of the digital wallet token.
     */
    'token'?: string;
    'token_service_provider'?: TokenServiceProvider;
    'transaction_device'?: TransactionDevice;
    'user'?: UserCardHolderResponse;
    'wallet_provider_profile'?: WalletProviderProfile;
}
export interface DigitalWalletTokenAddressVerification {
    /**
     * Specifies whether or not the address used for address verification is valid.
     */
    'validate'?: boolean;
}
/**
 * Contains identifiers of the digital wallet token resource and the card resource.
 */
export interface DigitalWalletTokenHash {
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token'?: string;
    /**
     * Unique identifier of the digital wallet token resource.
     */
    'token': string;
}
export interface DigitalWalletTokenListResponse {
    /**
     * Number of resources returned.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of digital wallet token resources.  Resources are returned as appropriate to your query.
     */
    'data'?: Array<DigitalWalletToken>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
/**
 * Contains additional information about the digital wallet token.
 */
export interface DigitalWalletTokenMetadata {
    /**
     * Language specified in the `config.transaction_controls.notification_language` field of the card product:  * *ces*  Czech * *deu*  German * *eng*  English * *fra*  French * *grc*  Greek * *ita*  Italian * *nld*  Dutch * *pol*  Polish * *por*  Portuguese * *rou*  Romanian * *spa*  Spanish * *swe*  Swedish  By default, notifications are sent in English.  The ISO maintains the link:https://www.iso.org/iso-3166-country-codes.html[full list of ISO 3166 two- and three-digit numeric country codes, window=\"_blank\"].
     */
    'cardproduct_preferred_notification_language'?: string;
    /**
     * Unique identifier of the product configuration on the Marqeta platform.
     */
    'issuer_product_config_id'?: string;
}
export interface DigitalWalletTokenTransitionListResponse {
    /**
     * Number of resources returned.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of digital wallet token transition resources.  Resources are returned as appropriate to your query.
     */
    'data'?: Array<DigitalWalletTokenTransitionResponse>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface DigitalWalletTokenTransitionRequest {
    /**
     * Mechanism by which the transition was initiated.
     */
    'channel'?: DigitalWalletTokenTransitionRequestChannelEnum;
    'digital_wallet_token': DigitalWalletTokenHash;
    /**
     * The reason for the transition.
     */
    'reason'?: string;
    /**
     * Standard code describing the reason for the transition.  *NOTE:* This field is required if your program uses v2 of the `user_card_state_version`, which is a program-specific configuration value that is managed by Marqeta and cannot be accessed via the API. To learn more about the `user_card_state_version` program configuration, contact your Marqeta representative.  * *00:* Object activated for the first time * *01:* Requested by you * *02:* Inactivity over time * *03:* This address cannot accept mail or the addressee is unknown * *04:* Negative account balance * *05:* Account under review * *06:* Suspicious activity was identified * *07:* Activity outside the program parameters was identified * *08:* Confirmed fraud was identified * *09:* Matched with an Office of Foreign Assets Control list * *10:* Card was reported lost * *11:* Card information was cloned * *12:* Account or card information was compromised * *13:* Temporary status change while on hold/leave * *14:* Initiated by Marqeta * *15:* Initiated by issuer * *16:* Card expired * *17:* Failed KYC * *18:* Changed to `ACTIVE` because information was properly validated * *19:* Changed to `ACTIVE` because account activity was properly validated * *20:* Change occurred prior to the normalization of reason codes * *21:* Initiated by a third party, often a digital wallet provider * *22:* PIN retry limit reached * *23:* Card was reported stolen * *24:* Address issue * *25:* Name issue * *26:* SSN issue * *27:* DOB issue * *28:* Email issue * *29:* Phone issue * *30:* Account/fulfillment mismatch * *31:* Other reason * *32:* Unblock request * *86:* Notification of death
     */
    'reason_code'?: DigitalWalletTokenTransitionRequestReasonCodeEnum;
    /**
     * Specifies the state to which the digital wallet token will transition.  The original state is `REQUESTED`. You cannot modify the state if its current value is either `REQUEST_DECLINED` or `TERMINATED`.
     */
    'state': DigitalWalletTokenTransitionRequestStateEnum;
    /**
     * The unique identifier of the digital wallet token transition (not the identifier of the digital wallet token itself).  If you do not include a value for the `token` field, the system will generate one automatically. This value is necessary for use in other API calls, so we recommend that rather than let the system generate one, you use a simple string that is easy to remember. This value cannot be updated.
     */
    'token'?: string;
    /**
     * The unique identifier of the digital wallet token within the card network. The `token_reference_id` is unique at the card network level.
     */
    'token_reference_id'?: string;
}

export const DigitalWalletTokenTransitionRequestChannelEnum = {
    TokenServiceProvider: 'TOKEN_SERVICE_PROVIDER',
    TokenServiceProviderApi: 'TOKEN_SERVICE_PROVIDER_API',
    DigitalWallet: 'DIGITAL_WALLET',
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM'
} as const;

export type DigitalWalletTokenTransitionRequestChannelEnum = typeof DigitalWalletTokenTransitionRequestChannelEnum[keyof typeof DigitalWalletTokenTransitionRequestChannelEnum];
export const DigitalWalletTokenTransitionRequestReasonCodeEnum = {
    _00: '00',
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15',
    _16: '16',
    _17: '17',
    _18: '18',
    _19: '19',
    _20: '20',
    _21: '21',
    _22: '22',
    _23: '23',
    _24: '24',
    _25: '25',
    _26: '26',
    _27: '27',
    _28: '28',
    _29: '29',
    _30: '30',
    _31: '31',
    _32: '32',
    _86: '86'
} as const;

export type DigitalWalletTokenTransitionRequestReasonCodeEnum = typeof DigitalWalletTokenTransitionRequestReasonCodeEnum[keyof typeof DigitalWalletTokenTransitionRequestReasonCodeEnum];
export const DigitalWalletTokenTransitionRequestStateEnum = {
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Terminated: 'TERMINATED'
} as const;

export type DigitalWalletTokenTransitionRequestStateEnum = typeof DigitalWalletTokenTransitionRequestStateEnum[keyof typeof DigitalWalletTokenTransitionRequestStateEnum];

export interface DigitalWalletTokenTransitionResponse {
    'card_swap'?: CardSwapHash;
    /**
     * Mechanism by which the transition was initiated.
     */
    'channel': DigitalWalletTokenTransitionResponseChannelEnum;
    /**
     * Date and time when the transition was created, in UTC.
     */
    'created_time'?: string;
    'digital_wallet_token': DigitalWalletTokenHash;
    /**
     * Provisioning status of the digital wallet token.
     */
    'fulfillment_status': DigitalWalletTokenTransitionResponseFulfillmentStatusEnum;
    /**
     * Reason for the transition.
     */
    'reason'?: string;
    /**
     * Standard code describing the reason for the transition:  * *00:* Object activated for the first time * *01:* Requested by you * *02:* Inactivity over time * *03:* This address cannot accept mail or the addressee is unknown * *04:* Negative account balance * *05:* Account under review * *06:* Suspicious activity was identified * *07:* Activity outside the program parameters was identified * *08:* Confirmed fraud was identified * *09:* Matched with an Office of Foreign Assets Control list * *10:* Card was reported lost * *11:* Card information was cloned * *12:* Account or card information was compromised * *13:* Temporary status change while on hold/leave * *14:* Initiated by Marqeta * *15:* Initiated by issuer * *16:* Card expired * *17:* Failed KYC * *18:* Changed to `ACTIVE` because information was properly validated * *19:* Changed to `ACTIVE` because account activity was properly validated * *20:* Change occurred prior to the normalization of reason codes * *21:* Initiated by a third party, often a digital wallet provider * *22:* PIN retry limit reached * *23:* Card was reported stolen * *24:* Address issue * *25:* Name issue * *26:* SSN issue * *27:* DOB issue * *28:* Email issue * *29:* Phone issue * *30:* Account/fulfillment mismatch * *31:* Other reason * *32:* Unblock request * *86:* Notification of death
     */
    'reason_code'?: DigitalWalletTokenTransitionResponseReasonCodeEnum;
    /**
     * Specifies the state to which the digital wallet token is transitioning.
     */
    'state': DigitalWalletTokenTransitionResponseStateEnum;
    /**
     * Unique identifier of the digital wallet token transition, and not the identifier of the digital wallet token itself.
     */
    'token': string;
    /**
     * Type of digital wallet token transition. `state.activated`, for example.
     */
    'type': string;
}

export const DigitalWalletTokenTransitionResponseChannelEnum = {
    TokenServiceProvider: 'TOKEN_SERVICE_PROVIDER',
    DigitalWallet: 'DIGITAL_WALLET',
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM',
    TokenServiceProviderApi: 'TOKEN_SERVICE_PROVIDER_API'
} as const;

export type DigitalWalletTokenTransitionResponseChannelEnum = typeof DigitalWalletTokenTransitionResponseChannelEnum[keyof typeof DigitalWalletTokenTransitionResponseChannelEnum];
export const DigitalWalletTokenTransitionResponseFulfillmentStatusEnum = {
    DecisionRed: 'DECISION_RED',
    DecisionYellow: 'DECISION_YELLOW',
    DecisionGreen: 'DECISION_GREEN',
    Rejected: 'REJECTED',
    Provisioned: 'PROVISIONED'
} as const;

export type DigitalWalletTokenTransitionResponseFulfillmentStatusEnum = typeof DigitalWalletTokenTransitionResponseFulfillmentStatusEnum[keyof typeof DigitalWalletTokenTransitionResponseFulfillmentStatusEnum];
export const DigitalWalletTokenTransitionResponseReasonCodeEnum = {
    _00: '00',
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15',
    _16: '16',
    _17: '17',
    _18: '18',
    _19: '19',
    _20: '20',
    _21: '21',
    _22: '22',
    _23: '23',
    _24: '24',
    _25: '25',
    _26: '26',
    _27: '27',
    _28: '28',
    _29: '29',
    _30: '30',
    _31: '31',
    _32: '32',
    _86: '86'
} as const;

export type DigitalWalletTokenTransitionResponseReasonCodeEnum = typeof DigitalWalletTokenTransitionResponseReasonCodeEnum[keyof typeof DigitalWalletTokenTransitionResponseReasonCodeEnum];
export const DigitalWalletTokenTransitionResponseStateEnum = {
    Requested: 'REQUESTED',
    RequestDeclined: 'REQUEST_DECLINED',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Terminated: 'TERMINATED'
} as const;

export type DigitalWalletTokenTransitionResponseStateEnum = typeof DigitalWalletTokenTransitionResponseStateEnum[keyof typeof DigitalWalletTokenTransitionResponseStateEnum];

export interface DigitalWalletTokenization {
    'card_art_id'?: string;
    'provisioning_controls'?: ProvisioningControls;
}
export interface DigitalWalletXPayProvisionRequest {
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token': string;
    /**
     * Unique identifier of the user\'s XPay device, as provided by XPay during the provisioning process.
     */
    'device_id': string;
    /**
     * Type of device into which the digital wallet token will be provisioned.
     */
    'device_type': DigitalWalletXPayProvisionRequestDeviceTypeEnum;
    /**
     * Version of the application making the provisioning request. Used for debugging and fraud prevention.
     */
    'provisioning_app_version': string;
    /**
     * Unique numerical identifier of the digital wallet token requestor within the card network. These ID numbers map to `token_requestor_name` field values as follows:  *Mastercard*  * 50110030273  `APPLE_PAY` * 50120834693  `ANDROID_PAY` * 50139059239  `SAMSUNG_PAY`  *Visa*  * 40010030273  `APPLE_PAY` * 40010075001  `ANDROID_PAY` * 40010043095  `SAMSUNG_PAY` * 40010075196  `MICROSOFT_PAY` * 40010075338  `VISA_CHECKOUT` * 40010075449  `FACEBOOK` * 40010075839  `NETFLIX` * 40010077056  `FITBIT_PAY` * 40010069887  `GARMIN_PAY`
     */
    'token_requestor_id': string;
    /**
     * User\'s XPay account identifier, as provided by XPay during the provisioning process.
     */
    'wallet_account_id': string;
}

export const DigitalWalletXPayProvisionRequestDeviceTypeEnum = {
    MobilePhone: 'MOBILE_PHONE',
    Watch: 'WATCH',
    Tablet: 'TABLET',
    WearableDevice: 'WEARABLE_DEVICE',
    HouseholdDevice: 'HOUSEHOLD_DEVICE',
    AutomobileDevice: 'AUTOMOBILE_DEVICE'
} as const;

export type DigitalWalletXPayProvisionRequestDeviceTypeEnum = typeof DigitalWalletXPayProvisionRequestDeviceTypeEnum[keyof typeof DigitalWalletXPayProvisionRequestDeviceTypeEnum];

export interface DigitalWalletXPayProvisionResponse {
    /**
     * Unique identifier of the card resource to use for the provisioning request.
     */
    'card_token': string;
    /**
     * Date and time when the digital wallet provisioning request was created, in UTC.
     */
    'created_time': string;
    /**
     * Date and time when the digital wallet token provisioning request was last updated, in UTC.
     */
    'last_modified_time': string;
    'push_tokenize_request_data': XpayPushTokenizeRequestData;
}
export interface DirectDepositAccountListResponse {
    'count'?: number;
    'data'?: Array<DirectDepositAccountResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface DirectDepositAccountRequest {
    'allow_immediate_credit'?: boolean;
    /**
     * Required if \'user_token\' is null
     */
    'business_token'?: string;
    /**
     * Required if account type = Checking
     */
    'customer_due_diligence'?: Array<CustomerDueDiligenceRequest>;
    'token'?: string;
    'type'?: DirectDepositAccountRequestTypeEnum;
    /**
     * Required if \'business_token\' is null
     */
    'user_token'?: string;
}

export const DirectDepositAccountRequestTypeEnum = {
    DepositAccount: 'DEPOSIT_ACCOUNT',
    Checking: 'CHECKING',
    Savings: 'SAVINGS',
    InterestBearing: 'INTEREST_BEARING'
} as const;

export type DirectDepositAccountRequestTypeEnum = typeof DirectDepositAccountRequestTypeEnum[keyof typeof DirectDepositAccountRequestTypeEnum];

export interface DirectDepositAccountResponse {
    'account_number': string;
    'allow_immediate_credit': boolean;
    'business_token': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'routing_number': string;
    'state': string;
    'token': string;
    'type'?: string;
    'user_token': string;
}
export interface DirectDepositAccountTransitionRequest {
    'account_token': string;
    'channel': DirectDepositAccountTransitionRequestChannelEnum;
    'reason'?: string;
    'state'?: DirectDepositAccountTransitionRequestStateEnum;
    'token'?: string;
}

export const DirectDepositAccountTransitionRequestChannelEnum = {
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM',
    Network: 'NETWORK',
    ProdSupport: 'PROD_SUPPORT',
    Unsupported: 'UNSUPPORTED'
} as const;

export type DirectDepositAccountTransitionRequestChannelEnum = typeof DirectDepositAccountTransitionRequestChannelEnum[keyof typeof DirectDepositAccountTransitionRequestChannelEnum];
export const DirectDepositAccountTransitionRequestStateEnum = {
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Terminated: 'TERMINATED',
    Unsupported: 'UNSUPPORTED',
    Unactivated: 'UNACTIVATED',
    Limited: 'LIMITED'
} as const;

export type DirectDepositAccountTransitionRequestStateEnum = typeof DirectDepositAccountTransitionRequestStateEnum[keyof typeof DirectDepositAccountTransitionRequestStateEnum];

export interface DirectDepositAccountTransitionResponse {
    'account_token': string;
    'business_token': string;
    'channel': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'reason': string;
    'state': string;
    'token': string;
    'user_token': string;
}
export interface DirectDepositFundingSourceModel extends FundingSourceModel {
    'name': string;
}
export interface DirectDepositListResponse {
    'count'?: number;
    'data'?: Array<DepositDepositResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface DirectDepositRequest {
    'account_number': string;
    'amount': number;
    'company_discretionary_data'?: string;
    'company_entry_description'?: string;
    'company_identification'?: string;
    'company_name'?: string;
    'earlyPayEligible'?: boolean;
    'individual_identification_number'?: string;
    'individual_name'?: string;
    'settlement_date': string;
    'standard_entry_class_code'?: string;
    'token'?: string;
    'type': DirectDepositRequestTypeEnum;
}

export const DirectDepositRequestTypeEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT'
} as const;

export type DirectDepositRequestTypeEnum = typeof DirectDepositRequestTypeEnum[keyof typeof DirectDepositRequestTypeEnum];

export interface DirectDepositTransitionListResponse {
    'count'?: number;
    'data'?: Array<DirectDepositTransitionResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface DirectDepositTransitionRequest {
    'channel': DirectDepositTransitionRequestChannelEnum;
    'direct_deposit_token': string;
    'idempotentHash'?: string;
    'reason': string;
    'reason_code'?: DirectDepositTransitionRequestReasonCodeEnum;
    'state': DirectDepositTransitionRequestStateEnum;
    'token'?: string;
}

export const DirectDepositTransitionRequestChannelEnum = {
    Api: 'API',
    System: 'SYSTEM',
    ProdSupport: 'PROD_SUPPORT'
} as const;

export type DirectDepositTransitionRequestChannelEnum = typeof DirectDepositTransitionRequestChannelEnum[keyof typeof DirectDepositTransitionRequestChannelEnum];
export const DirectDepositTransitionRequestReasonCodeEnum = {
    R01: 'R01',
    R02: 'R02',
    R03: 'R03',
    R04: 'R04',
    R06: 'R06',
    R08: 'R08',
    R09: 'R09',
    R10: 'R10',
    R11: 'R11',
    R14: 'R14',
    R15: 'R15',
    R16: 'R16',
    R17: 'R17',
    R18: 'R18',
    R20: 'R20',
    R23: 'R23',
    R24: 'R24',
    R29: 'R29'
} as const;

export type DirectDepositTransitionRequestReasonCodeEnum = typeof DirectDepositTransitionRequestReasonCodeEnum[keyof typeof DirectDepositTransitionRequestReasonCodeEnum];
export const DirectDepositTransitionRequestStateEnum = {
    Pending: 'PENDING',
    Applied: 'APPLIED',
    Reversed: 'REVERSED',
    Rejected: 'REJECTED'
} as const;

export type DirectDepositTransitionRequestStateEnum = typeof DirectDepositTransitionRequestStateEnum[keyof typeof DirectDepositTransitionRequestStateEnum];

export interface DirectDepositTransitionResponse {
    'channel'?: DirectDepositTransitionResponseChannelEnum;
    'created_time'?: string;
    'direct_deposit_account_token'?: string;
    'direct_deposit_token'?: string;
    'reason'?: string;
    'reason_code'?: string;
    'state'?: DirectDepositTransitionResponseStateEnum;
    'token'?: string;
    'transaction_token'?: string;
    'type'?: string;
}

export const DirectDepositTransitionResponseChannelEnum = {
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM',
    Network: 'NETWORK',
    ProdSupport: 'PROD_SUPPORT',
    Unsupported: 'UNSUPPORTED'
} as const;

export type DirectDepositTransitionResponseChannelEnum = typeof DirectDepositTransitionResponseChannelEnum[keyof typeof DirectDepositTransitionResponseChannelEnum];
export const DirectDepositTransitionResponseStateEnum = {
    Pending: 'PENDING',
    Applied: 'APPLIED',
    Reversed: 'REVERSED',
    Rejected: 'REJECTED'
} as const;

export type DirectDepositTransitionResponseStateEnum = typeof DirectDepositTransitionResponseStateEnum[keyof typeof DirectDepositTransitionResponseStateEnum];

/**
 * Category to which the dispute belongs.
 */

export const DisputeCategory = {
    Fraud: 'FRAUD',
    Auth: 'AUTH',
    ProcessingError: 'PROCESSING_ERROR',
    ConsumerDispute: 'CONSUMER_DISPUTE'
} as const;

export type DisputeCategory = typeof DisputeCategory[keyof typeof DisputeCategory];


/**
 * Information about a transaction dispute creation request.
 */
export interface DisputeCreateReq {
    /**
     * Amount of the dispute. Max value is equal to the value of the original transaction.
     */
    'amount': number;
    'category': DisputeCategory;
    /**
     * Unique identifier of the journal entry (`authorization.clearing` type only) in dispute.
     */
    'ledger_entry_token': string;
    /**
     * Additional information on the dispute (for example, a reason for the dispute).
     */
    'notes'?: string;
    /**
     * Unique identifier of the dispute.
     */
    'token'?: string;
}


/**
 * Contains information about a disputed transaction.
 */
export interface DisputeModel {
    /**
     * The unique identifier of the dispute case.
     */
    'case_management_identifier'?: string;
    /**
     * The reason for the dispute.
     */
    'reason'?: string;
}
/**
 * Information about a transaction dispute response.
 */
export interface DisputeResponse {
    /**
     * Unique identifier of the credit account on which the dispute was created.
     */
    'account_token': string;
    /**
     * Amount of the dispute.
     */
    'amount': number;
    'category': DisputeCategory;
    /**
     * Date and time when the dispute was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    /**
     * Unique identifier of the journal entry (`authorization.clearing` type only) in dispute.
     */
    'ledger_entry_token': string;
    /**
     * Additional information on the dispute (for example, a reason for the dispute).
     */
    'notes'?: string;
    /**
     * Date and time when the dispute was resolved and no longer in `ACTIVE` status.
     */
    'resolved_at'?: string;
    'status': DisputeStatus;
    /**
     * Unique identifier of the dispute.
     */
    'token': string;
    /**
     * Date and time when the dispute was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time': string;
}


/**
 * Return paginated disputes.
 */
export interface DisputeResponsePage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more disputes on a credit account.
     */
    'data': Array<DisputeResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Status of the dispute.  * `ACTIVE` - The dispute is active and awaiting resolution. * `REVERSED` - The dispute has been reversed and is no longer active. * `AH_WON` - The account holder won the dispute. * `AH_LOST` - The account holder lost the dispute.
 */

export const DisputeStatus = {
    Active: 'ACTIVE',
    Reversed: 'REVERSED',
    AhWon: 'AH_WON',
    AhLost: 'AH_LOST',
    Refunded: 'REFUNDED'
} as const;

export type DisputeStatus = typeof DisputeStatus[keyof typeof DisputeStatus];


/**
 * Information about a transaction dispute update request.
 */
export interface DisputeTransitionReq {
    /**
     * Updated amount of the dispute, based on the resolution.
     */
    'amount': number;
    /**
     * a list of interest charges and their effective times, if applicable. Note that this typically only applies for a cross-cycle activity, such as a dispute or payment 
     */
    'interest_adjustments'?: Array<MigrateDisputeInterestAdjustment>;
    /**
     * Additional information on the dispute update (for example, a reason for the dispute update).
     */
    'notes'?: string;
    /**
     * Date and time when the dispute occurred.
     */
    'source_created_time'?: string;
    'status': DisputeStatus;
    /**
     * Unique identifier of the dispute update.
     */
    'token'?: string;
}


/**
 * Information about a transaction dispute update request.
 */
export interface DisputeTransitionResponse {
    /**
     * Unique identifier of the credit account on which the dispute was updated.
     */
    'account_token': string;
    /**
     * Amount of the updated dispute, based on the resolution.
     */
    'amount': number;
    /**
     * Date and time when the dispute update was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    /**
     * Additional information on the dispute update (for example, a reason for the dispute update).
     */
    'notes'?: string;
    'status': DisputeStatus;
    /**
     * Unique identifier of the dispute update.
     */
    'token': string;
}


export interface EarlyFundsRequestModel {
    'bank_transfer_token'?: string;
}
export interface EchoPingRequest {
    /**
     * Payload of the ping request.
     */
    'payload'?: string;
    /**
     * Unique identifier of the ping request.
     */
    'token'?: string;
}
export interface EchoPingResponse {
    'id'?: string;
    'payload'?: string;
    'success'?: boolean;
}
export interface ErrorMessageFromWebPushProvisioningRequest {
    /**
     * Code for the error that occurred.
     */
    'error_code': string;
    /**
     * Descriptive error message.
     */
    'error_message': string;
}
export interface ExpirationOffset {
    /**
     * specify if a value is provided; default is card product expiration offset unit
     */
    'unit'?: ExpirationOffsetUnitEnum;
    /**
     * specify if unit is provided; default is card product expiration offset value
     */
    'value'?: number;
}

export const ExpirationOffsetUnitEnum = {
    Years: 'YEARS',
    Months: 'MONTHS',
    Days: 'DAYS',
    Hours: 'HOURS',
    Minutes: 'MINUTES',
    Seconds: 'SECONDS'
} as const;

export type ExpirationOffsetUnitEnum = typeof ExpirationOffsetUnitEnum[keyof typeof ExpirationOffsetUnitEnum];

/**
 * Contains details about the fee.
 */
export interface Fee {
    /**
     * Amount of the fee.
     */
    'amount': number;
    /**
     * Date and time when the `fees` object was created, in UTC.
     */
    'created_time': string;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * Date and time when the `fees` object was last modified, in UTC.
     */
    'last_modified_time': string;
    /**
     * Optional property to be used as Dispaly field when the fee is applied 255 char max
     */
    'memo'?: string;
    /**
     * Name of the fee.
     */
    'name': string;
    /**
     * Descriptive metadata about the fee.
     */
    'tags'?: string;
    /**
     * Unique identifier of the `fees` object.
     */
    'token': string;
}
export interface FeeAttributes {
    'reason'?: string;
    'region'?: string;
    'status'?: string;
    'transaction_type'?: string;
}
/**
 * Contains details about a fee.
 */
export interface FeeDetail {
    'fee': Fee;
    /**
     * Additional text describing the fee.
     */
    'memo'?: string;
    /**
     * Dynamic fee amount that overrides the `fee.amount` field value.
     */
    'overrideAmount'?: number;
    /**
     * Descriptive metadata about the fee.
     */
    'tags'?: string;
    /**
     * Unique identifier of the fee.
     */
    'token': string;
    /**
     * Unique identifier of the fee transaction.
     */
    'transaction_token': string;
}
export interface FeeListResponse {
    'count'?: number;
    'data'?: Array<FeeResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
/**
 * Method used to calculate the fee value.
 */

export const FeeMethod = {
    Flat: 'FLAT',
    Percentage: 'PERCENTAGE'
} as const;

export type FeeMethod = typeof FeeMethod[keyof typeof FeeMethod];


/**
 * Contains attributes that define characteristics of one or more fees. This array is returned in the response when it is included in the request.
 */
export interface FeeModel {
    /**
     * Additional text describing the fee.
     */
    'memo'?: string;
    /**
     * Dynamic fee amount that overrides the `fee.amount` field value.
     */
    'overrideAmount'?: number;
    /**
     * Descriptive metadata about the fee.
     */
    'tags'?: string;
    /**
     * Unique identifier of the fee.
     */
    'token': string;
}
export interface FeeRefundRequest {
    'original_fee_transaction_token'?: string;
    'tags'?: string;
}
export interface FeeRefundResponse {
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'fee': Fee;
    'memo'?: string;
    'original_fee_transaction_token'?: string;
    'overrideAmount'?: number;
    'state'?: string;
    'tags'?: string;
    /**
     * 36 char max
     */
    'token': string;
    'transaction_token': string;
}
export interface FeeRequest {
    'active'?: boolean;
    'amount': number;
    'category'?: FeeRequestCategoryEnum;
    'currency_code': string;
    'fee_attributes'?: FeeAttributes;
    'memo'?: string;
    'name': string;
    'tags'?: string;
    'token'?: string;
    'type'?: FeeRequestTypeEnum;
}

export const FeeRequestCategoryEnum = {
    Standalone: 'STANDALONE',
    Realtime: 'REALTIME'
} as const;

export type FeeRequestCategoryEnum = typeof FeeRequestCategoryEnum[keyof typeof FeeRequestCategoryEnum];
export const FeeRequestTypeEnum = {
    Flat: 'FLAT',
    Percentage: 'PERCENTAGE'
} as const;

export type FeeRequestTypeEnum = typeof FeeRequestTypeEnum[keyof typeof FeeRequestTypeEnum];

export interface FeeResponse {
    'active': boolean;
    'amount': number;
    'category'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'currency_code': string;
    'fee_attributes'?: FeeAttributes;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    /**
     * 255 char max
     */
    'memo'?: string;
    /**
     * 50 char max
     */
    'name': string;
    /**
     * 255 char max
     */
    'tags'?: string;
    /**
     * 36 char max
     */
    'token': string;
    'type'?: string;
}
/**
 * Status of the fee.
 */

export const FeeStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED',
    Reversed: 'REVERSED'
} as const;

export type FeeStatusEnum = typeof FeeStatusEnum[keyof typeof FeeStatusEnum];


export interface FeeTransferRequest {
    /**
     * Required if \'user_token\' is null
     */
    'business_token': string;
    'fees': Array<FeeModel>;
    'tags'?: string;
    'token'?: string;
    /**
     * Required if \'business_token\' is null
     */
    'user_token': string;
}
/**
 * Contains information about a fee charge, including the amount, currency code, and user or business token.
 */
export interface FeeTransferResponse {
    /**
     * Specifies the business account holder to which the fee applies.
     */
    'business_token': string;
    /**
     * Date and time when the `fee_charge` object was created, in UTC.
     */
    'created_time': string;
    /**
     * Contains attributes that define characteristics of one or more fees.
     */
    'fees': Array<FeeDetail>;
    /**
     * Metadata about the fee charge.  This field is returned if it exists in the resource.
     */
    'tags'?: string;
    /**
     * Unique identifier of the fee transfer.
     */
    'token': string;
    /**
     * Specifies the user account holder to which the fee applies.
     */
    'user_token': string;
}
/**
 * Type of fee.  *NOTE:* Only `RETURNED_PAYMENT_FEE`, `LATE_PAYMENT_FEE`, `ANNUAL_FEE`, and `MONTHLY_FEE` are currently supported. Do not pass other fees types.
 */

export const FeeType = {
    ForeignTransactionFee: 'FOREIGN_TRANSACTION_FEE',
    OverLimitFee: 'OVER_LIMIT_FEE',
    LatePaymentFee: 'LATE_PAYMENT_FEE',
    ReturnedPaymentFee: 'RETURNED_PAYMENT_FEE',
    CardReplacementFee: 'CARD_REPLACEMENT_FEE',
    MinimumInterestFee: 'MINIMUM_INTEREST_FEE',
    MinimumInterestFeeReversal: 'MINIMUM_INTEREST_FEE_REVERSAL',
    AnnualFee: 'ANNUAL_FEE',
    MonthlyFee: 'MONTHLY_FEE',
    AccountFee: 'ACCOUNT_FEE'
} as const;

export type FeeType = typeof FeeType[keyof typeof FeeType];


export interface FeeUpdateRequest {
    'active'?: boolean;
    'amount'?: number;
    'category'?: FeeUpdateRequestCategoryEnum;
    'currency_code'?: string;
    'fee_attributes'?: FeeAttributes;
    'memo'?: string;
    'name'?: string;
    'tags'?: string;
    'type'?: FeeUpdateRequestTypeEnum;
}

export const FeeUpdateRequestCategoryEnum = {
    Standalone: 'STANDALONE',
    Realtime: 'REALTIME'
} as const;

export type FeeUpdateRequestCategoryEnum = typeof FeeUpdateRequestCategoryEnum[keyof typeof FeeUpdateRequestCategoryEnum];
export const FeeUpdateRequestTypeEnum = {
    Flat: 'FLAT',
    Percentage: 'PERCENTAGE'
} as const;

export type FeeUpdateRequestTypeEnum = typeof FeeUpdateRequestTypeEnum[keyof typeof FeeUpdateRequestTypeEnum];

/**
 * Finalize status of a migrated account.
 */
export interface FinalizeMigrationStatusResponse {
    /**
     * Unique identifier of the credit account with associated finalize response.
     */
    'account_token'?: string;
    /**
     * the amount of the available credit adjustment created.
     */
    'available_credit_adjustment'?: number;
    /**
     * Date and time when the finalize status was created, in UTC.
     */
    'created_time'?: string;
    /**
     * the amount of the curent balance adjustment created.
     */
    'current_balance_adjustment'?: number;
    /**
     * the latest balance of the account from the migrated program
     */
    'expected_available_credit'?: number;
    /**
     * the latest balance of the account from the migrated program
     */
    'expected_current_balance'?: number;
    /**
     * the latest balance of the account from the migrated program
     */
    'final_available_credit'?: number;
    /**
     * the latest balance of the account from the migrated program
     */
    'final_current_balance'?: number;
    /**
     * Finalize status of the account.
     */
    'status'?: FinalizeMigrationStatusResponseStatusEnum;
    /**
     * Unique identifier of the finalize entry.
     */
    'token'?: string;
    /**
     * Date and time when the finalize status was updated, in UTC.
     */
    'updated_time'?: string;
    /**
     * Unique user token tied to the credit account.
     */
    'user_token'?: string;
}

export const FinalizeMigrationStatusResponseStatusEnum = {
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type FinalizeMigrationStatusResponseStatusEnum = typeof FinalizeMigrationStatusResponseStatusEnum[keyof typeof FinalizeMigrationStatusResponseStatusEnum];

export interface FinancialRequestModel {
    'amount': number;
    'card_acceptor': CardAcceptorModel;
    'card_token': string;
    'cash_back_amount'?: number;
    'is_pre_auth'?: boolean;
    'mid': string;
    'pin'?: string;
    'transaction_options'?: TransactionOptions;
    'webhook'?: Webhook;
}
/**
 * Contains information about a Flexible Credential transaction.
 */
export interface Flex {
    /**
     * Indicates whether the Flexible Credential transaction object is actionable (`inquiry`) or merely informative (`advice`).
     */
    'action'?: FlexActionEnum;
    /**
     * Indicates whether or not the transaction is eligible for Flexible Credential transactions.
     */
    'eligible'?: string;
    /**
     * Specifies which of the payment instrument\'s credentials is eligible for this transaction:  * A value of `DEBIT` indicates the primary credential. * A value of `LOAN` indicates the secondary credential.
     */
    'eligible_products'?: Array<string>;
    /**
     * Identifies the secondary credential used in the transaction, if applicable.
     */
    'secondary_credential_identifier'?: string;
    /**
     * Indicates the eligible product that was used in the transaction.
     */
    'selected_product'?: string;
}

export const FlexActionEnum = {
    Inquiry: 'inquiry',
    Advice: 'advice'
} as const;

export type FlexActionEnum = typeof FlexActionEnum[keyof typeof FlexActionEnum];

export interface ForbiddenError {
    'error_code': ForbiddenErrorErrorCodeEnum;
    'error_message': string;
}

export const ForbiddenErrorErrorCodeEnum = {
    _403: '403'
} as const;

export type ForbiddenErrorErrorCodeEnum = typeof ForbiddenErrorErrorCodeEnum[keyof typeof ForbiddenErrorErrorCodeEnum];

/**
 * of the fraud object
 */
export interface FraudFeedbackRequest {
    /**
     * This is the party making a call.
     */
    'actor': FraudFeedbackRequestActorEnum;
    'amount': string;
    'is_fraud': boolean;
    /**
     * This is the value of the status of the fraud.
     */
    'status': FraudFeedbackRequestStatusEnum;
    'transaction_token': string;
}

export const FraudFeedbackRequestActorEnum = {
    Unknown: 'UNKNOWN',
    ThirdPartyFraud: 'THIRD_PARTY_FRAUD',
    CardUserFraud: 'CARD_USER_FRAUD'
} as const;

export type FraudFeedbackRequestActorEnum = typeof FraudFeedbackRequestActorEnum[keyof typeof FraudFeedbackRequestActorEnum];
export const FraudFeedbackRequestStatusEnum = {
    Confirmed: 'CONFIRMED',
    Disputed: 'DISPUTED'
} as const;

export type FraudFeedbackRequestStatusEnum = typeof FraudFeedbackRequestStatusEnum[keyof typeof FraudFeedbackRequestStatusEnum];

/**
 * of the fraudfeedback response object
 */
export interface FraudFeedbackResponse {
    'message': string;
}
/**
 * Contains one or more fraud determinations by the card network that apply to either the transaction or the cardholder\'s account.
 */
export interface FraudView {
    'issuer_processor'?: IssuerFraudView;
    'network'?: NetworkFraudView;
    'network_account_intelligence_score'?: NetworkAccountIntelligenceScore;
}
export interface FulfillmentAddressRequest {
    'address1'?: string;
    'address2'?: string;
    'city'?: string;
    'country'?: string;
    'first_name'?: string;
    'last_name'?: string;
    'middle_name'?: string;
    'phone'?: string;
    'postal_code'?: string;
    'state'?: string;
    'zip'?: string;
}
/**
 * Specifies a fulfillment shipping or return address.
 */
export interface FulfillmentAddressResponse {
    /**
     * Number and street of the address.  This field is returned if it exists in the resource.
     */
    'address1'?: string;
    /**
     * Additional address information.  This field is returned if it exists in the resource.
     */
    'address2'?: string;
    /**
     * City of the address.  This field is returned if it exists in the resource.
     */
    'city'?: string;
    /**
     * Country of the address.  This field is returned if it exists in the resource.
     */
    'country'?: string;
    /**
     * First name of the addressee.  This field is returned if it exists in the resource.
     */
    'first_name'?: string;
    /**
     * Last name of the addressee.  This field is returned if it exists in the resource.
     */
    'last_name'?: string;
    /**
     * Middle name of the addressee.  This field is returned if it exists in the resource.
     */
    'middle_name'?: string;
    /**
     * Telephone number of the addressee.  This field is returned if it exists in the resource.
     */
    'phone'?: string;
    /**
     * Postal code of the address.  This field is returned if it exists in the resource.
     */
    'postal_code'?: string;
    /**
     * State or province of the address.  This field is returned if it exists in the resource.
     */
    'state'?: string;
    /**
     * United States ZIP code of the address.  This field is returned if it exists in the resource.
     */
    'zip'?: string;
}
export interface FulfillmentRequest {
    'card_personalization': CardPersonalization;
    'shipping'?: Shipping;
}
export interface FulfillmentResponse {
    'card_personalization': CardPersonalization;
    'shipping'?: ShippingInformationResponse;
}
/**
 * Contains funding information for the transaction, including funding amount, type, and time.
 */
export interface Funding {
    /**
     * Amount of funds loaded into the GPA.
     */
    'amount'?: number;
    'gateway_log'?: GatewayLogModel;
    'source': FundingSourceModel;
    'source_address'?: CardholderAddressResponse;
}
export interface FundingAccountListResponse {
    'count'?: number;
    'data'?: Array<FundingAccountResponseModel>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface FundingAccountResponseModel {
    'account_suffix'?: string;
    'account_type'?: string;
    'active'?: boolean;
    'business_token'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'date_sent_for_verification'?: string;
    'date_verified'?: string;
    'exp_date'?: string;
    'is_default_account'?: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'link_partner_account_reference_token'?: string;
    'name_on_account'?: string;
    'partner'?: string;
    'token'?: string;
    'type'?: string;
    'user_token'?: string;
    'verification_notes'?: string;
    'verification_override'?: boolean;
    'verification_status'?: string;
}
/**
 * Contains funding source information for the transaction, including the funding type and time.
 */
export interface FundingSourceModel {
    /**
     * Whether the funding source is active.
     */
    'active': boolean;
    /**
     * Date and time when the funding source was created, in UTC.
     */
    'created_time': string;
    /**
     * Whether the GPA order unload\'s funding source is the default funding account.
     */
    'is_default_account': boolean;
    /**
     * Date and time when the funding source was last modified, in UTC.
     */
    'last_modified_time': string;
    /**
     * Unique identifier of the funding source.
     */
    'token': string;
    /**
     * Funding type of the funding source.
     */
    'type': string;
}
export interface GPAUnloadListResponse {
    'count'?: number;
    'data'?: Array<GpaReturns>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
/**
 * Contains information from the JIT Funding gateway in response to a funding request.
 */
export interface GatewayLogModel {
    /**
     * Length of time in milliseconds that the gateway took to respond to a funding request.
     */
    'duration'?: number;
    /**
     * Message about the status of the funding request. Useful for determining whether it was approved and completed successfully, declined by the gateway, or timed out.
     */
    'message': string;
    /**
     * Customer order number, same value as `transaction.token`.
     */
    'order_number': string;
    'response'?: GatewayResponse;
    /**
     * Whether the gateway sent a response (`true`) or timed out (`false`).
     */
    'timed_out'?: boolean;
    /**
     * Customer-defined identifier for the transaction.
     */
    'transaction_id': string;
}
export interface GatewayProgramCustomHeaderUpdateRequest {
    /**
     * Custom headers
     */
    'custom_header'?: { [key: string]: string; };
}
export interface GatewayProgramFundingSourceRequest {
    'active'?: boolean;
    'basic_auth_password': string;
    'basic_auth_username': string;
    /**
     * Custom headers
     */
    'custom_header'?: { [key: string]: string; };
    'name': string;
    /**
     * Total timeout in milliseconds for gateway processing
     */
    'timeout_millis'?: number;
    'token'?: string;
    'url': string;
    /**
     * Use MTLS for funding request
     */
    'use_mtls'?: boolean;
}
export interface GatewayProgramFundingSourceResponse {
    'account': string;
    'active'?: boolean;
    /**
     * 50 char max. Required if URL is present. Minimum 20 chars with upper and lowercase letters, numbers, and symbols
     */
    'basic_auth_password': string;
    /**
     * 50 char max. Required if URL is present
     */
    'basic_auth_username': string;
    'created_time': string;
    /**
     * Custom headers to be passed along with request
     */
    'custom_header': { [key: string]: string; };
    'last_modified_time': string;
    'name': string;
    /**
     * Total timeout in milliseconds for gateway processing
     */
    'timeout_millis': number;
    'token': string;
    /**
     * 250 char max. Empty string (disabled). Must be HTTPS.
     */
    'url': string;
    /**
     * Use MTLS for funding request
     */
    'use_mtls': boolean;
    'version': string;
}
export interface GatewayProgramFundingSourceUpdateRequest {
    'active'?: boolean;
    /**
     * Required if URL is present; must contain upper and lowercase letters, numbers, and symbols
     */
    'basic_auth_password': string;
    /**
     * Required if URL is present
     */
    'basic_auth_username': string;
    /**
     * Custom headers
     */
    'custom_header'?: { [key: string]: string; };
    'name'?: string;
    /**
     * Total timeout in milliseconds for gateway processing
     */
    'timeout_millis'?: number;
    /**
     * Empty string (disabled); must be HTTPS
     */
    'url': string;
    /**
     * Use MTLS for funding request
     */
    'use_mtls'?: boolean;
}
/**
 * Contains information from the gateway in response to a funding request.
 */
export interface GatewayResponse {
    /**
     * Code received from the gateway.
     */
    'code': string;
    'data'?: JitProgramResponse;
}
export interface GetAliasIdByValue200Response {
    /**
     * UUID generated by Alias Directory, which identifies the Visa Alias.
     */
    'id'?: string;
}
export interface GetAliasIdByValueRequest {
    /**
     * Visa Alias value, which is the email address or phone number.
     */
    'aliasValue'?: string;
}
/**
 * Defines the type of order.
 */
export interface Gpa {
    /**
     * Available balance on the card after the reload has completed.  This value must be greater than or equal to the value of `trigger_amount`. Note that this is not the same as the amount added to the card, which will vary from reload to reload.
     */
    'reload_amount': number;
    /**
     * Threshold that determines when the reload happens.  The reload is triggered when the card balance falls below this amount.
     */
    'trigger_amount': number;
}
export interface GpaRequest {
    'amount': number;
    /**
     * Required if \'user_token\' is null
     */
    'business_token'?: string;
    'currency_code': string;
    'fees'?: Array<FeeModel>;
    'funding_source_address_token'?: string;
    'funding_source_token': string;
    'memo'?: string;
    'tags'?: string;
    'token'?: string;
    /**
     * Required if \'business_token\' is null
     */
    'user_token'?: string;
}
/**
 * Contains information about a GPA order, including fees, funding sources, and addresses. See <</core-api/gpa-orders, GPA Orders>> for more information.
 */
export interface GpaResponse {
    /**
     * Amount funded.
     */
    'amount': number;
    /**
     * Unique identifier of the business.  This field is returned if it exists in the resource.
     */
    'business_token'?: string;
    /**
     * Date and time when the GPA order was created, in UTC.
     */
    'created_time': string;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * List of fees associated with the funding transaction.  This array is returned if it exists in the resource.
     */
    'fees'?: Array<FeeDetail>;
    'funding': Funding;
    /**
     * Unique identifier of the funding source address to use for this order.
     */
    'funding_source_address_token'?: string;
    /**
     * Unique identifier of the funding source to use for this order.
     */
    'funding_source_token': string;
    /**
     * Message about the status of the funding request. Useful for determining whether it was approved and completed successfully, declined by the gateway, or timed out.  This field is returned if it exists in the resource.
     */
    'gateway_message'?: string;
    /**
     * Unique identifier of the JIT Funding request and response.  This field is returned if it exists in the resource.
     */
    'gateway_token'?: number;
    'jit_funding'?: JitFundingApi;
    /**
     * Date and time when the GPA order was last modified, in UTC.
     */
    'last_modified_time': string;
    /**
     * Additional descriptive text.  This field is returned if it exists in the resource.
     */
    'memo'?: string;
    'response': Response;
    /**
     * Current status of the funding transaction.
     */
    'state': string;
    /**
     * Comma-delimited list of tags describing the GPA order.  This field is returned if it exists in the resource.
     */
    'tags'?: string;
    /**
     * Unique identifier of the GPA order.
     */
    'token': string;
    /**
     * Unique identifier of the transaction being funded.
     */
    'transaction_token': string;
    /**
     * Unique identifier of the user resource.  This field is returned if it exists in the resource.
     */
    'user_token'?: string;
}
/**
 * Contains information about a GPA unload order.
 */
export interface GpaReturns {
    /**
     * Amount of funds returned to the funding source.
     */
    'amount': number;
    /**
     * Date and time when the GPA unload order was created, in UTC.
     */
    'created_time': string;
    'funding': Funding;
    /**
     * Identifies the funding source used for this order.
     */
    'funding_source_address_token'?: string;
    /**
     * Identifies the funding source used for this order.
     */
    'funding_source_token': string;
    'jit_funding'?: JitFundingApi;
    /**
     * Date and time when the GPA unload order was last modified, in UTC.
     */
    'last_modified_time': string;
    /**
     * Additional descriptive text.
     */
    'memo'?: string;
    /**
     * Identifies the original GPA order.
     */
    'original_order_token'?: string;
    'response': Response;
    /**
     * Current status of the GPA unload order.
     */
    'state': string;
    /**
     * Comma-delimited list of tags describing the GPA order.
     */
    'tags'?: string;
    /**
     * Unique identifier of the GPA unload order.
     */
    'token': string;
    /**
     * Unique identifier of the transaction.
     */
    'transaction_token': string;
}
export interface HoldIncrease {
    'type': HoldIncreaseTypeEnum;
    'value': number;
}

export const HoldIncreaseTypeEnum = {
    Amount: 'AMOUNT',
    Percent: 'PERCENT',
    UpToLimit: 'UP_TO_LIMIT'
} as const;

export type HoldIncreaseTypeEnum = typeof HoldIncreaseTypeEnum[keyof typeof HoldIncreaseTypeEnum];

/**
 * Contains identifications associated with the cardholder.
 */
export interface IdentificationRequestModel {
    /**
     * Expiration date of the identification, if applicable.
     */
    'expiration_date'?: string;
    'issuing_country'?: string;
    /**
     * Type of identification.  *NOTE:* Full Social Security Number (SSN) is required for US-based user cardholder KYC verification, using the `SSN` type. Full Employer Identification Number (EIN) is required for business cardholder KYC verification, using the `BUSINESS_TAX_ID` or `BUSINESS_NUMBER` type. For business directors, use one of SSN, TIN, SIN, or NIN. Nine digits only, no delimiters. `123456789`, for example.
     */
    'type': IdentificationRequestModelTypeEnum;
    /**
     * Number associated with the identification.
     */
    'value'?: string;
}

export const IdentificationRequestModelTypeEnum = {
    Ssn: 'SSN',
    Tin: 'TIN',
    Sin: 'SIN',
    Nin: 'NIN',
    PassportNumber: 'PASSPORT_NUMBER',
    DriversLicense: 'DRIVERS_LICENSE',
    BusinessNumber: 'BUSINESS_NUMBER',
    BusinessTaxId: 'BUSINESS_TAX_ID',
    TaxpayerReference: 'TAXPAYER_REFERENCE'
} as const;

export type IdentificationRequestModelTypeEnum = typeof IdentificationRequestModelTypeEnum[keyof typeof IdentificationRequestModelTypeEnum];

/**
 * Contains identifications associated with the cardholder.
 */
export interface IdentificationResponseModel {
    /**
     * Expiration date of the identification, if applicable.
     */
    'expiration_date'?: string;
    'issuing_country'?: string;
    /**
     * Type of identification.
     */
    'type'?: IdentificationResponseModelTypeEnum;
    /**
     * Number associated with the identification.
     */
    'value'?: string;
}

export const IdentificationResponseModelTypeEnum = {
    Ssn: 'SSN',
    Tin: 'TIN',
    Sin: 'SIN',
    Nin: 'NIN',
    PassportNumber: 'PASSPORT_NUMBER',
    DriversLicense: 'DRIVERS_LICENSE',
    BusinessNumber: 'BUSINESS_NUMBER',
    BusinessTaxId: 'BUSINESS_TAX_ID',
    TaxpayerReference: 'TAXPAYER_REFERENCE'
} as const;

export type IdentificationResponseModelTypeEnum = typeof IdentificationResponseModelTypeEnum[keyof typeof IdentificationResponseModelTypeEnum];

/**
 * Specifies personalized images that appear on the card.
 */
export interface Images {
    'card'?: ImagesCard;
    'carrier'?: ImagesCarrier;
    'carrier_return_window'?: ImagesCarrierReturnWindow;
    'signature'?: ImagesSignature;
}
/**
 * Specifies personalized images that appear on the card.
 */
export interface ImagesCard {
    /**
     * Specifies a PNG image to display on the card.
     */
    'name'?: string;
    /**
     * Specifies the color of the image displayed on the card.
     */
    'thermal_color'?: string;
}
/**
 * Specifies personalized images that appear on the card carrier.
 */
export interface ImagesCarrier {
    /**
     * Specifies a custom message that appears on the card carrier.
     */
    'message_1'?: string;
    /**
     * Specifies a PNG image to display on the card carrier.
     */
    'name'?: string;
}
/**
 * Specifies a custom image to display in the return address window of the card carrier envelope.
 */
export interface ImagesCarrierReturnWindow {
    /**
     * Specifies a PNG image to display in the return address window of envelopes used for sending cards to cardholders.
     */
    'name'?: string;
}
/**
 * Specifies an image of the cardholder\'s signature.
 */
export interface ImagesSignature {
    /**
     * Specifies a PNG image of the cardholder\'s signature.
     */
    'name'?: string;
}
export interface InAppProvisioning {
    'address_verification'?: DigitalWalletTokenAddressVerification;
    /**
     * Specifies if in-app provisioning is enabled.
     */
    'enabled'?: boolean;
}
/**
 * Contains the installment plan identifier used by the Visa Transaction Matching Service for Issuers.
 */
export interface InstallmentData {
    /**
     * (_Visa only_) Visa Transaction Matching Service for Issuers identifier. This identifier matches a transaction on the Marqeta platform to an installment plan or Pay by Points transaction on the Visa card network.
     */
    'installment_plan_identifier'?: string;
}
/**
 * Contains the configurations for interest calculation.
 */
export interface InterestCalculation {
    /**
     * Day-count convention.
     */
    'day_count': InterestCalculationDayCountEnum;
    /**
     * One or more transactions that are excluded from current billing period\'s interest charge, but included in next.
     */
    'exclude_tran_types'?: Array<InterestCalculationExcludeTranTypesEnum>;
    /**
     * Determines the last day of grace period based on which interest charges are calculated.
     */
    'grace_days_application': InterestCalculationGraceDaysApplicationEnum;
    /**
     * One or more balance types on which interest is applied.
     */
    'interest_application': Array<InterestCalculationInterestApplicationEnum>;
    'interest_on_grace_reactivation': InterestOnGraceReactivationEnum;
    /**
     * Method of interest calculation.
     */
    'method': InterestCalculationMethodEnum;
    /**
     * When interest is applied, this value determines the minimum amount of interest that can be charged.
     */
    'minimum_interest': number;
}

export const InterestCalculationDayCountEnum = {
    Actual: 'ACTUAL'
} as const;

export type InterestCalculationDayCountEnum = typeof InterestCalculationDayCountEnum[keyof typeof InterestCalculationDayCountEnum];
export const InterestCalculationExcludeTranTypesEnum = {
    LatePaymentFee: 'LATE_PAYMENT_FEE',
    AnnualFee: 'ANNUAL_FEE',
    MonthlyFee: 'MONTHLY_FEE',
    CashBackStatementCredit: 'CASH_BACK_STATEMENT_CREDIT',
    ReturnedPaymentFee: 'RETURNED_PAYMENT_FEE',
    ForeignTransactionFee: 'FOREIGN_TRANSACTION_FEE'
} as const;

export type InterestCalculationExcludeTranTypesEnum = typeof InterestCalculationExcludeTranTypesEnum[keyof typeof InterestCalculationExcludeTranTypesEnum];
export const InterestCalculationGraceDaysApplicationEnum = {
    NextCycleDate: 'NEXT_CYCLE_DATE'
} as const;

export type InterestCalculationGraceDaysApplicationEnum = typeof InterestCalculationGraceDaysApplicationEnum[keyof typeof InterestCalculationGraceDaysApplicationEnum];
export const InterestCalculationInterestApplicationEnum = {
    Principal: 'PRINCIPAL',
    Fees: 'FEES',
    Interest: 'INTEREST'
} as const;

export type InterestCalculationInterestApplicationEnum = typeof InterestCalculationInterestApplicationEnum[keyof typeof InterestCalculationInterestApplicationEnum];
export const InterestCalculationMethodEnum = {
    AvgDailyBalanceWithNewTransactions: 'AVG_DAILY_BALANCE_WITH_NEW_TRANSACTIONS'
} as const;

export type InterestCalculationMethodEnum = typeof InterestCalculationMethodEnum[keyof typeof InterestCalculationMethodEnum];

/**
 * Determines whether to charge or waive interest for the billing period when the balance is paid off.
 */

export const InterestOnGraceReactivationEnum = {
    AccrueFullCycle: 'ACCRUE_FULL_CYCLE',
    AccruePaymentDate: 'ACCRUE_PAYMENT_DATE',
    Waive: 'WAIVE'
} as const;

export type InterestOnGraceReactivationEnum = typeof InterestOnGraceReactivationEnum[keyof typeof InterestOnGraceReactivationEnum];


export interface InternalServerError {
    'error_code': InternalServerErrorErrorCodeEnum;
    'error_message': string;
}

export const InternalServerErrorErrorCodeEnum = {
    _500: '500'
} as const;

export type InternalServerErrorErrorCodeEnum = typeof InternalServerErrorErrorCodeEnum[keyof typeof InternalServerErrorErrorCodeEnum];

/**
 * Contains one or more fraud determinations by the card network that apply to either the transaction or the cardholder\'s account.
 */
export interface IssuerFraudView {
    'fraud_score_reasons'?: Array<string>;
    /**
     * The action recommended based on the fraud score.
     */
    'recommended_action'?: string;
    /**
     * The fraud rating, or level of risk associated with the transaction.
     */
    'risk_level'?: string;
    /**
     * The RiskControl tags that were triggered by the transaction.
     */
    'riskcontrol_tags'?: Array<RiskcontrolTags>;
    /**
     * The rules violated by the transaction.
     */
    'rule_violations'?: Array<string>;
    /**
     * The risk score generated by RiskControl. This is either the Mastercard Decision Intelligence or Visa Advance Authorization transaction risk score.
     */
    'score'?: number;
    /**
     * Provides a list of rules triggered by a fraud event, along with the information on tags and rule characteristics.
     */
    'triggered_rules'?: Array<TriggeredRule>;
}
/**
 * Contains account name verification data used to make JIT Funding decisions from one of the following objects:  * The `gateway` object, which contains account name verification data from your JIT Funding gateway. * The `issuer` object, which contains account name verification data from the Marqeta platform. * The `request` object, which contains account name verification data as it appears in a JIT Funding request.
 */
export interface JitAccountNameVerification {
    'gateway'?: AccountNameVerificationSource;
    'issuer'?: AccountNameVerificationSource;
    'request'?: AniInformation;
}
/**
 * Contains address verification data used to make JIT Funding decisions.
 */
export interface JitAddressVerification {
    'gateway'?: AddressVerificationSource;
    'issuer'?: AddressVerificationSource;
    'request'?: AvsInformation;
}
export interface JitFunding {
    'paymentcard_funding_source'?: JitFundingPaymentcardFundingSource;
    'program_funding_source'?: JitFundingProgramFundingSource;
    'programgateway_funding_source'?: JitFundingProgramgatewayFundingSource;
}
/**
 * Contains information about the JIT Funding load event, in which funds are loaded into an account.  This object is returned if your program uses JIT Funding.
 */
export interface JitFundingApi {
    'account_name_verification'?: JitAccountNameVerification;
    /**
     * User who conducted the transaction.  Can be a child user configured to share its parent\'s account balance.
     */
    'acting_user_token'?: string;
    'address_verification'?: JitAddressVerification;
    /**
     * Requested amount of funding.
     */
    'amount': number;
    'anticipated_amount_supported'?: boolean;
    /**
     * Contains the GPA\'s balance details.
     */
    'balances'?: { [key: string]: CardholderBalance; };
    /**
     * Holder of the business account that was funded.
     */
    'business_token'?: string;
    /**
     * Reason why the transaction was declined.
     */
    'decline_reason'?: JitFundingApiDeclineReasonEnum;
    /**
     * Array of tokens referencing the JIT Funding tokens of all previous associated incremental authorization JIT Funding requests. Useful for ascertaining the final transaction amount when the original amount was incremented.
     */
    'incremental_authorization_jit_funding_tokens'?: Array<string>;
    'jit_account_name_verification'?: JitAccountNameVerification;
    /**
     * Additional information that describes the JIT Funding transaction.
     */
    'memo'?: string;
    /**
     * JIT Funding response type. See <</core-api/gateway-jit-funding-messages#_the_jit_funding_object, The jit_funding object>> for the purpose, funding event type, and description of each method.
     */
    'method': JitFundingApiMethodEnum;
    /**
     * Unique identifier of the first associated JIT Funding message. Useful for correlating related JIT Funding messages (that is, those associated with the same GPA order). Not included in the first of any set of related messages.
     */
    'original_jit_funding_token'?: string;
    /**
     * Customer-defined tags related to the JIT Funding transaction.
     */
    'tags'?: string;
    /**
     * Existing JIT Funding token matching the `funding.gateway_log.transaction_id` field of the associated GPA order.  *NOTE:* The `transaction_id` field updates if a subsequent JIT Funding message associated with that GPA order is sent. If multiple JIT Funding messages are associated with the same GPA order, the `transaction_id` field matches the token of the most recent message.
     */
    'token': string;
    /**
     * Holder of the user account that was funded.
     */
    'user_token': string;
}

export const JitFundingApiDeclineReasonEnum = {
    InvalidAmount: 'INVALID_AMOUNT',
    InsufficientFunds: 'INSUFFICIENT_FUNDS',
    TransactionNotPermitted: 'TRANSACTION_NOT_PERMITTED',
    SuspectedFraud: 'SUSPECTED_FRAUD',
    AmountLimitExceeded: 'AMOUNT_LIMIT_EXCEEDED',
    TransactionCountLimitExceeded: 'TRANSACTION_COUNT_LIMIT_EXCEEDED',
    DuplicateTransaction: 'DUPLICATE_TRANSACTION',
    InvalidMerchant: 'INVALID_MERCHANT',
    InvalidCard: 'INVALID_CARD',
    NoCreditAccount: 'NO_CREDIT_ACCOUNT',
    ExpiredCard: 'EXPIRED_CARD',
    NoCheckingAccount: 'NO_CHECKING_ACCOUNT',
    NoSavingsAccount: 'NO_SAVINGS_ACCOUNT',
    StopPayment: 'STOP_PAYMENT',
    RevocationAuthorizationOrder: 'REVOCATION_AUTHORIZATION_ORDER',
    RevocationAllAuthorizationOrder: 'REVOCATION_ALL_AUTHORIZATION_ORDER',
    SoftDeclineAuthenticationRequired: 'SOFT_DECLINE_AUTHENTICATION_REQUIRED',
    ClosedAccount: 'CLOSED_ACCOUNT',
    SoftDeclinePinRequired: 'SOFT_DECLINE_PIN_REQUIRED',
    CardNotActive: 'CARD_NOT_ACTIVE',
    CardholderNotActive: 'CARDHOLDER_NOT_ACTIVE',
    BlockedByIssuer: 'BLOCKED_BY_ISSUER',
    BlockedByCardholder: 'BLOCKED_BY_CARDHOLDER',
    BlockedMerchantByCardholder: 'BLOCKED_MERCHANT_BY_CARDHOLDER'
} as const;

export type JitFundingApiDeclineReasonEnum = typeof JitFundingApiDeclineReasonEnum[keyof typeof JitFundingApiDeclineReasonEnum];
export const JitFundingApiMethodEnum = {
    PgfsAuthorization: 'pgfs.authorization',
    PgfsAuthorizationClearing: 'pgfs.authorization.clearing',
    PgfsAuthorizationAdvice: 'pgfs.authorization.advice',
    PgfsAuthorizationIncremental: 'pgfs.authorization.incremental',
    PgfsAuthorizationCapture: 'pgfs.authorization.capture',
    PgfsAuthorizationReversal: 'pgfs.authorization.reversal',
    PgfsAuthorizationCashback: 'pgfs.authorization.cashback',
    PgfsBalanceinquiry: 'pgfs.balanceinquiry',
    PgfsAuthPlusCapture: 'pgfs.auth_plus_capture',
    PgfsRefund: 'pgfs.refund',
    PgfsRefundAuthorization: 'pgfs.refund.authorization',
    PgfsRefundAuthorizationReversal: 'pgfs.refund.authorization.reversal',
    PgfsRefundAuthorizationClearing: 'pgfs.refund.authorization.clearing',
    PgfsForceCapture: 'pgfs.force_capture',
    PgfsAuthorizationCaptureChargeback: 'pgfs.authorization.capture.chargeback',
    PgfsAuthorizationCaptureChargebackReversal: 'pgfs.authorization.capture.chargeback.reversal',
    PgfsPindebit: 'pgfs.pindebit',
    PgfsPindebitChargeback: 'pgfs.pindebit.chargeback',
    PgfsPindebitChargebackReversal: 'pgfs.pindebit.chargeback.reversal',
    PgfsPindebitCashback: 'pgfs.pindebit.cashback',
    PgfsPindebitRefund: 'pgfs.pindebit.refund',
    PgfsPindebitAuthorization: 'pgfs.pindebit.authorization',
    PgfsPindebitAuthorizationClearing: 'pgfs.pindebit.authorization.clearing',
    PgfsPindebitAuthorizationReversal: 'pgfs.pindebit.authorization.reversal',
    PgfsPindebitAtmWithdrawal: 'pgfs.pindebit.atm.withdrawal',
    PgfsPindebitBalanceinquiry: 'pgfs.pindebit.balanceinquiry',
    PgfsPindebitQuasiCash: 'pgfs.pindebit.quasi.cash',
    PgfsDisputeCredit: 'pgfs.dispute.credit',
    PgfsDisputeDebit: 'pgfs.dispute.debit',
    PgfsDirectdepositCredit: 'pgfs.directdeposit.credit',
    PgfsDirectdepositDebit: 'pgfs.directdeposit.debit',
    PgfsDirectdepositCreditReversal: 'pgfs.directdeposit.credit.reversal',
    PgfsDirectdepositDebitReversal: 'pgfs.directdeposit.debit.reversal',
    PgfsAdjustmentCredit: 'pgfs.adjustment.credit',
    PgfsAdjustmentDebit: 'pgfs.adjustment.debit',
    PgfsAuthPlusCaptureStandin: 'pgfs.auth_plus_capture.standin',
    PgfsAuthorizationStandin: 'pgfs.authorization.standin',
    PgfsNetworkLoad: 'pgfs.network.load',
    PgfsOriginalCreditAuthorization: 'pgfs.original.credit.authorization',
    PgfsOriginalCreditAuthPlusCapture: 'pgfs.original.credit.auth_plus_capture',
    PgfsOriginalCreditAuthorizationClearing: 'pgfs.original.credit.authorization.clearing',
    PgfsOriginalCreditAuthorizationReversal: 'pgfs.original.credit.authorization.reversal',
    PgfsBillpayment: 'pgfs.billpayment',
    PgfsBillpaymentCapture: 'pgfs.billpayment.capture',
    PgfsBillpaymentReversal: 'pgfs.billpayment.reversal',
    PgfsAtmWithdrawal: 'pgfs.atm.withdrawal',
    PgfsAtmClearingWithdrawal: 'pgfs.atm.clearing.withdrawal',
    PgfsAuthorizationQuasiCash: 'pgfs.authorization.quasi.cash',
    PgfsAuthorizationClearingQuasiCash: 'pgfs.authorization.clearing.quasi.cash',
    PgfsAuthorizationAccountVerification: 'pgfs.authorization.account_verification',
    PgfsProductInquiry: 'pgfs.product.inquiry'
} as const;

export type JitFundingApiMethodEnum = typeof JitFundingApiMethodEnum[keyof typeof JitFundingApiMethodEnum];

export interface JitFundingPaymentcardFundingSource {
    'enabled'?: boolean;
    'refunds_destination'?: JitFundingPaymentcardFundingSourceRefundsDestinationEnum;
}

export const JitFundingPaymentcardFundingSourceRefundsDestinationEnum = {
    Gateway: 'GATEWAY',
    Gpa: 'GPA',
    Waterfall: 'WATERFALL'
} as const;

export type JitFundingPaymentcardFundingSourceRefundsDestinationEnum = typeof JitFundingPaymentcardFundingSourceRefundsDestinationEnum[keyof typeof JitFundingPaymentcardFundingSourceRefundsDestinationEnum];

export interface JitFundingProgramFundingSource {
    'enabled'?: boolean;
    /**
     * required if enabled
     */
    'funding_source_token'?: string;
    'refunds_destination'?: JitFundingProgramFundingSourceRefundsDestinationEnum;
}

export const JitFundingProgramFundingSourceRefundsDestinationEnum = {
    ProgramFundingSource: 'PROGRAM_FUNDING_SOURCE',
    Gpa: 'GPA',
    Waterfall: 'WATERFALL'
} as const;

export type JitFundingProgramFundingSourceRefundsDestinationEnum = typeof JitFundingProgramFundingSourceRefundsDestinationEnum[keyof typeof JitFundingProgramFundingSourceRefundsDestinationEnum];

export interface JitFundingProgramgatewayFundingSource {
    'always_fund'?: boolean;
    'enabled'?: boolean;
    /**
     * Required if enabled
     */
    'funding_source_token'?: string;
    'refunds_destination'?: JitFundingProgramgatewayFundingSourceRefundsDestinationEnum;
}

export const JitFundingProgramgatewayFundingSourceRefundsDestinationEnum = {
    Gateway: 'GATEWAY',
    Gpa: 'GPA',
    Waterfall: 'WATERFALL'
} as const;

export type JitFundingProgramgatewayFundingSourceRefundsDestinationEnum = typeof JitFundingProgramgatewayFundingSourceRefundsDestinationEnum[keyof typeof JitFundingProgramgatewayFundingSourceRefundsDestinationEnum];

/**
 * Contains the gateway\'s information about the JIT Funding transaction.
 */
export interface JitProgramResponse {
    'flex'?: Flex;
    'jit_funding': JitFundingApi;
    'network_metadata'?: NetworkMetadata;
}
/**
 * Return filtered transactions.
 */
export interface JournalEntriesPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more journal entries on a credit account.
     */
    'data': Array<JournalEntry>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information about a journal entry.
 */
export interface JournalEntry {
    /**
     * Unique identifier of the credit account associated with the credit card used to make the journal entry.
     */
    'account_token': string;
    /**
     * Amount of the journal entry.
     */
    'amount': number;
    /**
     * Unique identifier of the credit card used to make the journal entry.
     */
    'card_token'?: string;
    /**
     * Date and time when the journal entry was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    'currency_code': CurrencyCode;
    'detail_object'?: object;
    /**
     * Unique identifier of the journal entry\'s full details.
     */
    'detail_token': string;
    /**
     * Group to which the journal entry belongs.
     */
    'group': JournalEntryGroupEnum;
    /**
     * Eight-digit numeric identifier of the journal entry, an alternate identifier to the UUID that is useful for remembering and referencing.
     */
    'id': string;
    /**
     * Date and time when the journal entry impacts the account balance.  For purchases, this is the time of the authorization.  For purchase authorization clearings, this is the time when the transaction is settled.
     */
    'impact_time': string;
    /**
     * Merchant name or description for the journal entry.
     */
    'memo'?: string;
    'original_currency'?: OriginalCurrency;
    /**
     * Date and time when the journal entry was migrated to Marqeta\'s credit platform, in UTC. Null if not migrated.
     */
    'program_migration_time'?: string;
    /**
     * Unique identifier of the original journal entry. If the current journal entry is the original, this field is returned empty.
     */
    'related_token'?: string;
    /**
     * For purchases, the date and time of the authorization, which is when the user initiates the journal entry.  For other journal entry groups, equivalent to `impact_time`.
     */
    'request_time': string;
    /**
     * Unique identifier of the root journal entry. If the current journal entry is the root, this field is returned empty.
     */
    'root_token'?: string;
    /**
     * Status of the journal entry when it was initially recorded and had an impact on the balance, either `PENDING` or `POSTED`. This field is immutable and may not represent the current status.  To view the current status of purchases, refunds, OCTs, and payments, see the `detail_object.state` field. These journal entries start in `PENDING` and can transition to `CLEARED`, `DECLINED`, or `ERROR`. This transition of status is only sent through webhook event notifications.  Journal entries that are final transactions, such as clearings, start and remain in a `POSTED` state.  *NOTE*: `CLEARED`, `DECLINED`, and `ERROR` are special statuses that do not have an impact on the account balance, and are not recorded in the journal. For these special statuses, `impact_time`, `request_time`, `created_time`, `token`, and `id` are returned blank.
     */
    'status': JournalEntryStatusEnum;
    /**
     * Unique identifier of the journal entry.
     */
    'token': string;
    /**
     * Journal entry event type.
     */
    'type': string;
    /**
     * Unique identifier of the credit user.
     */
    'user_token': string;
}

export const JournalEntryGroupEnum = {
    Purchase: 'PURCHASE',
    Refund: 'REFUND',
    Dispute: 'DISPUTE',
    OriginalCredit: 'ORIGINAL_CREDIT',
    Fee: 'FEE',
    Reward: 'REWARD',
    Interest: 'INTEREST',
    Payment: 'PAYMENT',
    Adjustment: 'ADJUSTMENT',
    BalanceTransfer: 'BALANCE_TRANSFER',
    CashAdvance: 'CASH_ADVANCE',
    BalanceRefund: 'BALANCE_REFUND'
} as const;

export type JournalEntryGroupEnum = typeof JournalEntryGroupEnum[keyof typeof JournalEntryGroupEnum];
export const JournalEntryStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED',
    Declined: 'DECLINED',
    Error: 'ERROR',
    Cleared: 'CLEARED'
} as const;

export type JournalEntryStatusEnum = typeof JournalEntryStatusEnum[keyof typeof JournalEntryStatusEnum];

export interface KYCListResponse {
    'count'?: number;
    'data'?: Array<KycResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface KycRequest {
    /**
     * Required if \'user_token\' is null
     */
    'business_token'?: string;
    'manual_override'?: boolean;
    'notes'?: string;
    'reference_id'?: string;
    'token'?: string;
    /**
     * Required if \'business_token\' is null
     */
    'user_token'?: string;
}
export interface KycResponse {
    'business_token'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'manual_override'?: boolean;
    'notes'?: string;
    'reference_id'?: string;
    'result'?: Result;
    'token'?: string;
    'user_token'?: string;
}
/**
 * Return filtered transactions.
 */
export interface LedgerEntriesPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more ledger entries on a credit account.
     */
    'data': Array<LedgerEntry>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information about a ledger entry.
 */
export interface LedgerEntry {
    /**
     * Unique identifier of the credit account associated with the credit card used to make the ledger entry.
     */
    'account_token': string;
    /**
     * Amount of the ledger entry.
     */
    'amount': number;
    /**
     * Unique identifier of the credit card used to make the ledger entry.
     */
    'card_token': string;
    /**
     * Date and time when the ledger entry was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    'currency_code': CurrencyCode;
    /**
     * Contains the ledger entry\'s full details. The fields returned in this object vary based on the ledger entry group.  The following lists each ledger entry group and the specific fields returned for each group.  * Purchases and refunds: see the <</core-api/transactions#getTransactions, transactions>> response fields.  * Disputes: see the <</core-api/credit-account-disputes#retrieveDispute, account disputes response fields.>>  * Original credit transaction (OCT): see the <</core-api/push-to-card-payments#_create_push_to_card_disbursement, Push-to-Card disbursement>> fields.  * Rewards: see the <</core-api/credit-account-rewards#createReward, account reward>> response fields.  * Payments: see the <</core-api/credit-account-payments#retrievePayment, account payment>> response fields.  * Balance refunds: see the <</core-api/credit-account-balance-refunds#createBalanceRefund, balance refund>> response fields.  * Adjustments: see the <</core-api/credit-account-adjustments#retrieveAdjustment, account adjustment>> response fields.  * Interest and fees: see fields below.
     */
    'detail_object'?: object;
    /**
     * Unique identifier of the ledger entry\'s full details.
     */
    'detail_token': string;
    /**
     * Group to which the ledger entry belongs.
     */
    'group': LedgerEntryGroupEnum;
    /**
     * Eight-digit numeric identifier of the ledger entry, an alternate identifier to the UUID that is useful for remembering and referencing.
     */
    'id': string;
    /**
     * Date and time when the ledger entry impacts the account balance.  For purchases, this is the time of the authorization.  For purchase authorization clearings, this is the time when the transaction is settled.
     */
    'impact_time': string;
    /**
     * Merchant name or description for the ledger entry.
     */
    'memo': string;
    'original_currency'?: OriginalCurrency;
    /**
     * Unique identifier of the original ledger entry. If the current ledger entry is the original, this field is returned empty.
     */
    'related_token'?: string;
    /**
     * For purchases, the date and time of the authorization, which is when the user initiates the ledger entry.  For other ledger entry groups, equivalent to `impact_time`.
     */
    'request_time': string;
    /**
     * Unique identifier of the root ledger entry. If the current ledger entry is the root, this field is returned empty.
     */
    'root_token'?: string;
    /**
     * Status of the ledger entry when it was initially recorded and had an impact on the balance, either `PENDING` or `POSTED`. This field is immutable and may not represent the current status.  To view the current status of purchases, refunds, OCTs, and payments, see the `detail_object.state` field. These journal entries start in `PENDING` and can transition to `CLEARED`, `DECLINED`, or `ERROR`. This transition of status is only sent through webhook event notifications.  Ledger entries that are final transactions, such as clearings, start and remain in a `POSTED` state.  *NOTE*: `CLEARED`, `DECLINED`, and `ERROR` are special statuses that do not have an impact on the account balance, and are not recorded in the ledger. For these special statuses, `impact_time`, `request_time`, `created_time`, `token`, and `id` are returned blank.
     */
    'status': LedgerEntryStatusEnum;
    /**
     * Unique identifier of the ledger entry.
     */
    'token': string;
    /**
     * Ledger entry event type.
     */
    'type': string;
}

export const LedgerEntryGroupEnum = {
    Purchase: 'PURCHASE',
    Internal: 'INTERNAL',
    Fee: 'FEE',
    Reward: 'REWARD',
    Interest: 'INTEREST',
    Payment: 'PAYMENT',
    Adjustment: 'ADJUSTMENT',
    BalanceTransfer: 'BALANCE_TRANSFER',
    CashAdvance: 'CASH_ADVANCE',
    BalanceRefund: 'BALANCE_REFUND',
    OriginalCredit: 'ORIGINAL_CREDIT'
} as const;

export type LedgerEntryGroupEnum = typeof LedgerEntryGroupEnum[keyof typeof LedgerEntryGroupEnum];
export const LedgerEntryStatusEnum = {
    Pending: 'PENDING',
    Posted: 'POSTED',
    Declined: 'DECLINED',
    Error: 'ERROR',
    Cleared: 'CLEARED'
} as const;

export type LedgerEntryStatusEnum = typeof LedgerEntryStatusEnum[keyof typeof LedgerEntryStatusEnum];

export interface Link {
    'href': string;
    'method': string;
    'rel': string;
}
export interface LinkedAccountBalanceResponse {
    'account_balance'?: number;
    'available_balance'?: number;
    'balance_iso_currency_code'?: string;
    'created_time'?: string;
    'last_modified_time'?: string;
    'processor_token'?: string;
}
export interface LoginRequestModel {
    /**
     * Cardholder email address.
     */
    'email'?: string;
    /**
     * Password to the cardholder\'s user account on the Marqeta platform.
     */
    'password'?: string;
    /**
     * Identifies the cardholder to log in.  Send a `GET` request to `/users` to retrieve user tokens.
     */
    'user_token'?: string;
}
export interface LoginResponseModel {
    'access_token'?: AccessTokenResponse;
    'user'?: UserCardHolderResponse;
}
export interface MCCConfig {
    'authorization_controls'?: AuthControls;
}
export interface MCCGroupListResponse {
    'count'?: number;
    'data'?: Array<MccGroupModel>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface ManualEntry {
    'address_verification'?: DigitalWalletTokenAddressVerification;
    /**
     * Specifies if manual entry is enabled.
     */
    'enabled'?: boolean;
}
export interface MaxAPRSchedulesResponse {
    /**
     * Date and time when the override APR ends, in UTC.
     */
    'end_date'?: string;
    /**
     * Reason for the override APR.
     */
    'reason': MaxAPRSchedulesResponseReasonEnum;
    /**
     * Date and time when the override APR goes into effect, in UTC.
     */
    'start_date': string;
    /**
     * The APR percentage value. This is the value of the fixed rate during the override period. The APR value must adhere to the constraints of the main schedule, such as maximum allowable values.
     */
    'value': number;
}

export const MaxAPRSchedulesResponseReasonEnum = {
    Scra: 'SCRA',
    Mla: 'MLA',
    Hardship: 'HARDSHIP'
} as const;

export type MaxAPRSchedulesResponseReasonEnum = typeof MaxAPRSchedulesResponseReasonEnum[keyof typeof MaxAPRSchedulesResponseReasonEnum];

export interface MccGroupModel {
    'active'?: boolean;
    'config'?: MCCConfig;
    'mccs': Set<object>;
    'name': string;
    'token'?: string;
}
export interface MccGroupUpdateModel {
    'active'?: boolean;
    'config'?: MCCConfig;
    'mccs'?: Set<string>;
    'name'?: string;
}
export interface MediaContent {
    /**
     * Media data content.
     */
    'data'?: string;
    /**
     * Height of non-SVG image asset. Specified in pixels.
     */
    'height'?: string;
    /**
     * Type of media. Specified as Multipurpose Internet Mail Extension (MIME).  Supported media types include:  * application/pdf * image/png * image/svg+xml * text/plain * text/html 
     */
    'type'?: string;
    /**
     * Width of non-SVG image asset. Specified in pixels.
     */
    'width'?: string;
}
export interface MerchantGroupListResponse {
    'count'?: number;
    'data'?: Array<MerchantGroupResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface MerchantGroupRequest {
    'active'?: boolean;
    'mids'?: Set<string>;
    'name': string;
    'token'?: string;
}
export interface MerchantGroupResponse {
    'active'?: boolean;
    'created_time'?: string;
    'last_modified_time'?: string;
    'mids'?: Array<string>;
    'name'?: string;
    'token'?: string;
}
export interface MerchantGroupUpdateRequest {
    'active'?: boolean;
    'mids'?: Set<string>;
    'name'?: string;
}
export interface MerchantResponseModel {
    'active'?: boolean;
    'address1'?: string;
    'address2'?: string;
    'city'?: string;
    'contact'?: string;
    'contact_email'?: string;
    'country'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'latitude'?: number;
    'longitude'?: number;
    'name': string;
    'partial_auth_flag'?: boolean;
    'phone'?: string;
    'province'?: string;
    'state'?: string;
    /**
     * The unique identifier of the merchant
     */
    'token'?: string;
    'zip'?: string;
}
/**
 * Defines the group of merchants to which the velocity control applies.  Populate no more than one field of the `merchant_scope` object. If no fields are populated, the velocity control applies to all merchants.
 */
export interface MerchantScope {
    /**
     * Merchant Category Code (MCC). Identifies the type of products or services provided by the merchant.  Enter a value to control spending on a particular type of product or service.
     */
    'mcc'?: string;
    /**
     * Token identifying a group of MCCs. Enter a value to control spending on a group of product or service types.  Send a `GET` request to `/mccgroups` to retrieve MCC group tokens.
     */
    'mcc_group'?: string;
    /**
     * Merchant identifier (MID). Identifies a specific merchant.  Enter a value to control spending with a particular merchant.
     */
    'mid'?: string;
}
/**
 * Method, either a flat amount or a percentage.  *NOTE:* Only `FLAT` is currently supported.
 */

export const Method = {
    Percentage: 'PERCENTAGE',
    Flat: 'FLAT'
} as const;

export type Method = typeof Method[keyof typeof Method];


/**
 * Represents an interest charge associated with (as of this writing) either a payment or dispute
 */
export interface MigrateDisputeInterestAdjustment {
    /**
     * The fee amount.  * `< 0 (Credit)` - The dispute is initiated. * `> 0 (Debit)` - The dispute is lost.
     */
    'amount': number;
    /**
     * Valid three-digit ISO 4217 currency code.
     */
    'currency_code': MigrateDisputeInterestAdjustmentCurrencyCodeEnum;
    'effective_date': string;
}

export const MigrateDisputeInterestAdjustmentCurrencyCodeEnum = {
    Usd: 'USD'
} as const;

export type MigrateDisputeInterestAdjustmentCurrencyCodeEnum = typeof MigrateDisputeInterestAdjustmentCurrencyCodeEnum[keyof typeof MigrateDisputeInterestAdjustmentCurrencyCodeEnum];

export interface MigrationResponse {
    'success'?: boolean;
}
export interface MinOffset {
    /**
     * specify if a value is provided; default is expiration_offset.unit
     */
    'unit'?: MinOffsetUnitEnum;
    /**
     * specify if unit is provided; default is expiration_offset.value
     */
    'value'?: number;
}

export const MinOffsetUnitEnum = {
    Years: 'YEARS',
    Months: 'MONTHS',
    Days: 'DAYS',
    Hours: 'HOURS',
    Minutes: 'MINUTES',
    Seconds: 'SECONDS'
} as const;

export type MinOffsetUnitEnum = typeof MinOffsetUnitEnum[keyof typeof MinOffsetUnitEnum];

export interface ModelError {
    'code'?: number;
    'message'?: string;
}
/**
 * Defines the original credit transaction (OCT) types that are subject to velocity control. Your request can contain either a `money_in_transaction` object or the `include_credits` field, not both.
 */
export interface MoneyInTransaction {
    /**
     * Specifies the types of credits to include in the original credit transaction (OCT).
     */
    'include_credits_types'?: Array<string>;
    /**
     * Indicates whether or not cash and check network load transactions will be subject to velocity control.
     */
    'include_network_load_types'?: Array<string>;
}
export interface Msa {
    'campaign_token': string;
    'reload_amount': number;
    'trigger_amount': number;
}
/**
 * Contains information from the card network about currency conversion, including the original currency of the transaction, the amount of the transaction in the original currency, and the conversion rate.
 */
export interface Network {
    /**
     * Conversion rate between the origination currency and the settlement currency.  Returned when the transaction currency is different from the origination currency.
     */
    'conversion_rate'?: number;
    /**
     * Indicates whether currency conversion was performed dynamically at the point of sale.
     */
    'dynamic_currency_conversion'?: boolean;
    /**
     * Amount of the transaction in the currency in which it originated.
     */
    'original_amount'?: number;
    /**
     * Currency type of the origination currency.
     */
    'original_currency_code'?: string;
    'settlement_data'?: SettlementData;
}
/**
 * Account intelligence score information, as provided by the Mastercard network.
 */
export interface NetworkAccountIntelligenceScore {
    /**
     * The name, as provided by the Mastercard network.
     */
    'name'?: string;
    /**
     * The service type, as provided by the Mastercard network.
     */
    'service_type'?: string;
    /**
     * The value, as provided by the Mastercard network.
     */
    'value'?: string;
}
/**
 * Contains card network fees assessed against the cardholder.
 */
export interface NetworkFeeModel {
    /**
     * Amount of the network fee.
     */
    'amount'?: number;
    /**
     * Indicates whether the fee is a credit or a debit.  * *C* indicates a credit * *D* indicates a debit
     */
    'credit_debit'?: NetworkFeeModelCreditDebitEnum;
    /**
     * Type of currency used when assessing a `CROSS_BORDER_ISSUER_FEE` or `INTERCHANGE_FEE` on Mastercard multi-currency transactions. Three-digit link:https://www.iso.org/iso-4217-currency-codes.html[ISO 4217 currency code, window=\"_blank\"].
     */
    'currency'?: string;
    /**
     * Type of fee assessed by the card network.
     */
    'type'?: NetworkFeeModelTypeEnum;
}

export const NetworkFeeModelCreditDebitEnum = {
    C: 'C',
    D: 'D'
} as const;

export type NetworkFeeModelCreditDebitEnum = typeof NetworkFeeModelCreditDebitEnum[keyof typeof NetworkFeeModelCreditDebitEnum];
export const NetworkFeeModelTypeEnum = {
    IssuerFee: 'ISSUER_FEE',
    SwitchFee: 'SWITCH_FEE',
    PindebitAssocFee: 'PINDEBIT_ASSOC_FEE',
    AcquirerFee: 'ACQUIRER_FEE',
    InterchangeFee: 'INTERCHANGE_FEE',
    CurConvCardholderFee: 'CUR_CONV_CARDHOLDER_FEE',
    CurConvIssuerFee: 'CUR_CONV_ISSUER_FEE',
    CrossBorderIssuerFee: 'CROSS_BORDER_ISSUER_FEE'
} as const;

export type NetworkFeeModelTypeEnum = typeof NetworkFeeModelTypeEnum[keyof typeof NetworkFeeModelTypeEnum];

/**
 * Contains network-provided information about fraud determinations.
 */
export interface NetworkFraudView {
    /**
     * _(Visa only)_ Account holder risk condition code evaluated by the card network. A higher score indicates a greater likelihood that the card number is compromised.
     */
    'account_risk_score'?: string;
    /**
     * _(Visa only)_ Unique code that describes the main driver of the `account_risk_score`.
     */
    'account_risk_score_reason_code'?: string;
    /**
     * _(Visa only)_ Visa-provided score ranking the risk of fraud for a card-not-present transaction. A higher score indicates higher risk. Useful for making authorization decisions.
     */
    'card_not_present_transaction_risk_score'?: string;
    /**
     * Mastercard Digital Identity Insights risk score, where `0` indicates the lowest risk and `9` indicates the highest risk.
     */
    'dii_score'?: string;
    /**
     * Mastercard Digital Identity Insights risk score reason code, where `AA` indicates the lowest risk, and `ZZ` indicates the highest risk.
     */
    'dii_score_reason_code'?: string;
    /**
     * _(Visa only)_ Visa-provided score ranking the risk of an account enumeration attack in a card-not-present transaction. A higher score indicates higher risk. A score of 00 indicates insufficient data to determine risk. Useful for making authorization decisions.
     */
    'transaction_account_attack_intelligence_score'?: string;
    /**
     * Network-provided risk score for the transaction. A higher score indicates higher risk. Useful for making authorization decisions.
     */
    'transaction_risk_score'?: number;
    /**
     * _(Mastercard only)_ Unique code that describes the main driver of the `transaction_risk_score`.
     */
    'transaction_risk_score_reason_code'?: string;
    /**
     * _(Mastercard only)_ Description of the `transaction_risk_score_reason_code`.
     */
    'transaction_risk_score_reason_description'?: string;
}
/**
 * Contains network-related metadata for the transaction, including details about the card program and the card product. Returned if provided by the card network
 */
export interface NetworkMetadata {
    'account_identification_1'?: string;
    /**
     * Network response code, as provided by the card network.  For example, Visa response code `59` indicates suspected fraud.
     */
    'incoming_response_code'?: string;
    /**
     * Transaction type indicator provided by the card network for original credit and account funding transactions.
     */
    'network_funding_txn_type'?: string;
    /**
     * Network response code, as provided by Marqeta.  For example, Visa response code `59` indicates suspected fraud.
     */
    'outgoing_response_code'?: string;
    /**
     * Product identification value assigned by the card network to each card product. Can be used to track card-level activity by individual account number for premium card products.
     */
    'product_id'?: string;
    /**
     * Program identification number used with `product_id` that identifies the programs associated with a card within a program registered by the issuer with the card network.
     */
    'program_id'?: string;
    /**
     * Indicates whether or not the base spend-assessment threshold defined by the card network has been met.
     */
    'spend_qualifier'?: string;
    /**
     * Name of the surcharge-free ATM network used to complete the transaction.
     */
    'surcharge_free_atm_network'?: string;
    'terminal_verification_results'?: string;
}
export interface OneTimeRequestModel {
    /**
     * Cardholder email address.  Required when neither the user token nor the admin access token is provided as the Basic Authentication password (case #3).
     */
    'email'?: string;
    /**
     * Password to the cardholder\'s user account on the Marqeta platform.  Required when neither the user token nor the admin access token is provided as the Basic Authentication password (case #3).
     */
    'password'?: string;
    /**
     * Identifies the cardholder whose data is accessed. Send a `GET` request to `/users` to retrieve cardholder tokens.  Required when the Basic Authentication password is set to an admin access token (case #2).
     */
    'user_token'?: string;
}
/**
 * Defines the balance threshold and reload amounts.
 */
export interface OrderScope {
    'gpa'?: Gpa;
}
/**
 * Contains information about an original credit transaction (OCT), which enables the cardholder to receive funds on the specified card from an external source via the card network.
 */
export interface OriginalCredit {
    'deferred_hold_by'?: OriginalCreditDeferredHoldByEnum;
    'entry_device_type'?: OriginalCreditEntryDeviceTypeEnum;
    /**
     * Indicates that Fast Funds are enabled for dual-message original credit transactions. If the value of this field is `true`, you must make the funds available to your cardholder within 30 minutes of the transaction.
     */
    'fast_funds_enabled'?: boolean;
    /**
     * Sender\'s account from which the OCT draws funds.
     */
    'funding_source'?: OriginalCreditFundingSourceEnum;
    'reference_id'?: string;
    /**
     * Sanctions screening score to assist with meeting Anti-Money Laundering (AML) obligations.  Higher scores indicate that the sender\'s data more closely resembles an entry on the regulatory watchlist.  A value of 999 means that no screening score is available.
     */
    'screening_score'?: string;
    'sender_account_number'?: string;
    /**
     * The type of account from which the OCT draws funds.
     */
    'sender_account_type'?: OriginalCreditSenderAccountTypeEnum;
    /**
     * Sender\'s street address.
     */
    'sender_address'?: string;
    /**
     * Sender\'s city.
     */
    'sender_city'?: string;
    /**
     * Sender\'s country.
     */
    'sender_country'?: string;
    'sender_date_of_birth'?: string;
    /**
     * Full name of the sender.
     */
    'sender_name'?: string;
    'sender_postal_code'?: string;
    /**
     * Sender\'s state.
     */
    'sender_state'?: string;
    /**
     * The purpose of the original credit transaction.
     */
    'transaction_purpose'?: string;
    /**
     * Type of original credit transaction.
     */
    'transaction_type'?: OriginalCreditTransactionTypeEnum;
}

export const OriginalCreditDeferredHoldByEnum = {
    Absent: 'absent',
    Visa: 'visa',
    Originator: 'originator',
    Payment: 'payment'
} as const;

export type OriginalCreditDeferredHoldByEnum = typeof OriginalCreditDeferredHoldByEnum[keyof typeof OriginalCreditDeferredHoldByEnum];
export const OriginalCreditEntryDeviceTypeEnum = {
    OffTheShelfMobileConsumer: 'OFF_THE_SHELF_MOBILE_CONSUMER'
} as const;

export type OriginalCreditEntryDeviceTypeEnum = typeof OriginalCreditEntryDeviceTypeEnum[keyof typeof OriginalCreditEntryDeviceTypeEnum];
export const OriginalCreditFundingSourceEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    Prepaid: 'PREPAID',
    DepositAccount: 'DEPOSIT_ACCOUNT',
    Cash: 'CASH',
    MobileMoneyAccount: 'MOBILE_MONEY_ACCOUNT',
    NonVisaCredit: 'NON_VISA_CREDIT',
    Check: 'CHECK',
    Ach: 'ACH'
} as const;

export type OriginalCreditFundingSourceEnum = typeof OriginalCreditFundingSourceEnum[keyof typeof OriginalCreditFundingSourceEnum];
export const OriginalCreditSenderAccountTypeEnum = {
    Other: 'OTHER',
    RtnBankAccount: 'RTN_BANK_ACCOUNT',
    Iban: 'IBAN',
    CardAccount: 'CARD_ACCOUNT',
    Email: 'EMAIL',
    PhoneNumber: 'PHONE_NUMBER',
    BankAccountNumberAndBankIdentificationCode: 'BANK_ACCOUNT_NUMBER_AND_BANK_IDENTIFICATION_CODE',
    WalletId: 'WALLET_ID',
    SocialNetworkId: 'SOCIAL_NETWORK_ID'
} as const;

export type OriginalCreditSenderAccountTypeEnum = typeof OriginalCreditSenderAccountTypeEnum[keyof typeof OriginalCreditSenderAccountTypeEnum];
export const OriginalCreditTransactionTypeEnum = {
    AccountToAccount: 'account_to_account',
    PersonToPerson: 'person_to_person',
    WalletTransfer: 'wallet_transfer',
    MoneyTransferByBank: 'money_transfer_by_bank',
    BusinessToBusiness: 'business_to_business',
    Disbursement: 'disbursement',
    GovernmentDisbursement: 'government_disbursement',
    GamblingPayout: 'gambling_payout',
    Loyalty: 'loyalty',
    MerchantDisbursement: 'merchant_disbursement',
    OnlineGamblingPayout: 'online_gambling_payout',
    PensionDisbursement: 'pension_disbursement',
    PrepaidLoads: 'prepaid_loads',
    CardBillPayment: 'card_bill_payment',
    BillPayment: 'bill_payment',
    CashClaim: 'cash_claim',
    CashIn: 'cash_in',
    CashOut: 'cash_out',
    MobileAirTimePayment: 'mobile_air_time_payment',
    MoneyTransferByMerchant: 'money_transfer_by_merchant',
    FaceToFaceMerchantPayment: 'face_to_face_merchant_payment',
    GovernmentPayment: 'government_payment',
    PaymentsGoodsServices: 'payments_goods_services',
    FundsTransfer: 'funds_transfer',
    GeneralBusinessToBusinessTransfer: 'general_business_to_business_transfer',
    BusinessToBusinessTransfer: 'business_to_business_transfer',
    CashDeposit: 'cash_deposit',
    PurchaseRepayment: 'purchase_repayment',
    AftOrOctEligibility: 'aft_or_oct_eligibility',
    ConsumerBillPayment: 'consumer_bill_payment',
    RequestToPay: 'request_to_pay',
    GamingPayment: 'gaming_payment',
    VisaAccept: 'visa_accept'
} as const;

export type OriginalCreditTransactionTypeEnum = typeof OriginalCreditTransactionTypeEnum[keyof typeof OriginalCreditTransactionTypeEnum];

export interface OriginalCreditSenderData {
    'deferred_hold_by'?: OriginalCreditSenderDataDeferredHoldByEnum;
    'fast_funds_enabled'?: boolean;
    'funding_source': OriginalCreditSenderDataFundingSourceEnum;
    'sender_account_number'?: string;
    'sender_account_type'?: OriginalCreditSenderDataSenderAccountTypeEnum;
    'sender_address'?: string;
    'sender_city'?: string;
    'sender_country'?: string;
    'sender_name'?: string;
    'sender_reference_number'?: string;
    'sender_state'?: string;
    'transaction_purpose'?: OriginalCreditSenderDataTransactionPurposeEnum;
    'unique_transaction_reference_number'?: string;
    'visa_transaction_purpose'?: string;
}

export const OriginalCreditSenderDataDeferredHoldByEnum = {
    Absent: 'absent',
    Visa: 'visa',
    Originator: 'originator',
    Payment: 'payment'
} as const;

export type OriginalCreditSenderDataDeferredHoldByEnum = typeof OriginalCreditSenderDataDeferredHoldByEnum[keyof typeof OriginalCreditSenderDataDeferredHoldByEnum];
export const OriginalCreditSenderDataFundingSourceEnum = {
    Credit: 'credit',
    Debit: 'debit',
    Prepaid: 'prepaid',
    DepositAccount: 'deposit_account',
    Cash: 'cash',
    MobileMoneyPayment: 'mobile_money_payment',
    NonVisaCredit: 'non_visa_credit',
    Check: 'check',
    Ach: 'ach'
} as const;

export type OriginalCreditSenderDataFundingSourceEnum = typeof OriginalCreditSenderDataFundingSourceEnum[keyof typeof OriginalCreditSenderDataFundingSourceEnum];
export const OriginalCreditSenderDataSenderAccountTypeEnum = {
    Other: 'other',
    RtnBankAccount: 'rtn_bank_account',
    Iban: 'iban',
    CardAccount: 'card_account',
    Email: 'email',
    PhoneNumber: 'phone_number',
    BankAccountNumberAndIdentificationCode: 'bank_account_number_and_identification_code',
    WalletId: 'wallet_id',
    SocialNetworkId: 'social_network_id'
} as const;

export type OriginalCreditSenderDataSenderAccountTypeEnum = typeof OriginalCreditSenderDataSenderAccountTypeEnum[keyof typeof OriginalCreditSenderDataSenderAccountTypeEnum];
export const OriginalCreditSenderDataTransactionPurposeEnum = {
    FamilySupport: 'family_support',
    LaborTransfers: 'labor_transfers',
    Travel: 'travel',
    Education: 'education',
    MedicalTreatment: 'medical_treatment',
    EmergencyNeed: 'emergency_need',
    Savings: 'savings',
    Gifts: 'gifts',
    Other: 'other',
    Salary: 'salary',
    Lending: 'lending',
    CryptoCurrency: 'crypto_currency'
} as const;

export type OriginalCreditSenderDataTransactionPurposeEnum = typeof OriginalCreditSenderDataTransactionPurposeEnum[keyof typeof OriginalCreditSenderDataTransactionPurposeEnum];

/**
 * Original Currency
 */
export interface OriginalCurrency {
    /**
     * original amount
     */
    'amount'?: number;
    /**
     * Currency code, such as EUR or USD.
     */
    'code'?: string;
}
export interface OrignalcreditRequestModel {
    'amount': number;
    'card_acceptor'?: CardAcceptorModel;
    'card_token': string;
    'mid': string;
    'screening_score'?: string;
    'sender_data'?: OriginalCreditSenderData;
    'transactionPurpose'?: string;
    'type': OrignalcreditRequestModelTypeEnum;
    'webhook'?: Webhook;
}

export const OrignalcreditRequestModelTypeEnum = {
    AccountToAccount: 'account_to_account',
    PersonToPerson: 'person_to_person',
    Prepaid: 'prepaid',
    WalletTransfer: 'wallet_transfer',
    MoneyTransferByBank: 'money_transfer_by_bank',
    BusinessToBusiness: 'business_to_business',
    Disbursement: 'disbursement',
    GovernmentDisbursement: 'government_disbursement',
    GamblingPayout: 'gambling_payout',
    Loyalty: 'loyalty',
    MerchantDisbursement: 'merchant_disbursement',
    OnlineGamblingPayout: 'online_gambling_payout',
    PensionDisbursement: 'pension_disbursement',
    PrepaidLoads: 'prepaid_loads',
    CardBillPayment: 'card_bill_payment',
    BillPayment: 'bill_payment',
    CashClaim: 'cash_claim',
    CashIn: 'cash_in',
    CashOut: 'cash_out',
    MobileAirTimePayment: 'mobile_air_time_payment',
    MoneyTransferByMerchant: 'money_transfer_by_merchant',
    FaceToFaceMerchantPayment: 'face_to_face_merchant_payment',
    GovernmentPayment: 'government_payment',
    PaymentsGoodsServices: 'payments_goods_services',
    PurchaseRepayment: 'purchase_repayment',
    VisaAccept: 'visa_accept'
} as const;

export type OrignalcreditRequestModelTypeEnum = typeof OrignalcreditRequestModelTypeEnum[keyof typeof OrignalcreditRequestModelTypeEnum];

export interface OtherPoi {
    'allow'?: boolean;
    /**
     * Default = false
     */
    'card_presence_required'?: boolean;
    /**
     * Default = false
     */
    'cardholder_presence_required'?: boolean;
    'track1_discretionary_data'?: string;
    'track2_discretionary_data'?: string;
    'use_static_pin'?: boolean;
}
export interface PTCAddress {
    'city': string;
    'country'?: string;
    'county': string;
    'line1': string;
    'line2'?: string;
    'postal_code': string;
    'state': string;
}
export interface PTCPhone {
    'country_code'?: string;
    'number': string;
}
export interface PTCSoftDescriptor {
    'address': PTCAddress;
    'email'?: string;
    'name': string;
    'phone'?: PTCPhone;
}
export interface PanRequest {
    'cvv_number'?: string;
    'expiration'?: string;
    'pan': string;
}
export interface PanResponse {
    /**
     * The unique identifier of the card
     */
    'card_token': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    /**
     * The unique identifier of the cardholder
     */
    'user_token': string;
}
export interface PasswordUpdateModel {
    /**
     * Current password to the cardholder\'s user account on the Marqeta platform.
     */
    'current_password': string;
    /**
     * New password to the cardholder\'s user account on the Marqeta platform.  * Must contain at least one numeral + * Must contain at least one lowercase letter + * Must contain at least one uppercase letter + * Must contain at least one of these symbols:   +  `@` `#` `$` `%` `!` `^` `&` `*` `(` `)`   +  `\\` `_` `+` `~` `-` `=` `[` `]` `{` `}`   +  `,` `;` `:` `\'` `\"` `.` `/` `<` `>` `?` ```
     */
    'new_password': string;
}
/**
 * Ordered list of balance types to which payments are allocated, from first to last.
 */

export const PaymentAllocationOrderEnum = {
    Interest: 'INTEREST',
    Fees: 'FEES',
    Principal: 'PRINCIPAL'
} as const;

export type PaymentAllocationOrderEnum = typeof PaymentAllocationOrderEnum[keyof typeof PaymentAllocationOrderEnum];


/**
 * Object containing payment allocation information.
 */
export interface PaymentAllocationResponse {
    /**
     * Total amount of the payment allocation.
     */
    'amount': number;
    /**
     * Category to which a portion of the payment is allocated.
     */
    'bucket': PaymentAllocationResponseBucketEnum;
}

export const PaymentAllocationResponseBucketEnum = {
    Principal: 'PRINCIPAL',
    Interest: 'INTEREST',
    Fees: 'FEES'
} as const;

export type PaymentAllocationResponseBucketEnum = typeof PaymentAllocationResponseBucketEnum[keyof typeof PaymentAllocationResponseBucketEnum];

export interface PaymentCardFundingSourceModel extends FundingSourceModel {
    'account_suffix': string;
    'account_type': string;
    /**
     * Required if \'user_token\' is null
     */
    'business_token'?: string;
    'exp_date': string;
    /**
     * Required if \'business_token\' is null
     */
    'user_token'?: string;
}
export interface PaymentCardResponseModel {
    'account_suffix': string;
    'account_type': string;
    'active': boolean;
    /**
     * Required if \'user_token\' is not present
     */
    'business_token'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'exp_date': string;
    'is_default_account': boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'token': string;
    'type': string;
    /**
     * Required if \'business_token\' is not present
     */
    'user_token'?: string;
}
/**
 * Object that is created when a user pays a portion or all of their statement balance.  Applies to immediate payments only. Once the value is set to `ACTIVE`, it cannot be edited or deleted.
 */
export interface PaymentCreateReq {
    /**
     * Amount of the payment.
     */
    'amount': number;
    'currency_code': CurrencyCode;
    /**
     * Description of the payment.
     */
    'description': string;
    /**
     * Overrides the configured default number of days for which to hold ACH and check payments.
     */
    'hold_days'?: number;
    /**
     * Date and time when the payment impacts the account balance and fee calculations.
     */
    'impact_time'?: string;
    /**
     * Customer-defined additional information about the payment (for example, a check number).
     */
    'metadata'?: string;
    /**
     * Method of payment.
     */
    'method': PaymentCreateReqMethodEnum;
    /**
     * Unique identifier of the payment source. Required for ACH payments.
     */
    'payment_source_token'?: string;
    /**
     * Unique identifier of the payment.
     */
    'token'?: string;
}

export const PaymentCreateReqMethodEnum = {
    Ach: 'ACH',
    Check: 'CHECK',
    Debit: 'DEBIT',
    Cash: 'CASH',
    SecureCard: 'SECURE_CARD'
} as const;

export type PaymentCreateReqMethodEnum = typeof PaymentCreateReqMethodEnum[keyof typeof PaymentCreateReqMethodEnum];

/**
 * Response containing payment details with transition history.
 */
export interface PaymentDetailResponse {
    /**
     * Unique identifier of the credit account on which the payment is made.
     */
    'account_token': string;
    /**
     * List of objects that contain information about how a payment is allocated.
     */
    'allocations'?: Array<PaymentAllocationResponse>;
    /**
     * Total amount of the payment.
     */
    'amount': number;
    /**
     * Date and time when the payment was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    'currency_code': CurrencyCode;
    /**
     * Description of the payment.
     */
    'description': string;
    /**
     * After a payment completes, the number of days to hold the available credit on the account before increasing it.
     */
    'hold_days': number;
    /**
     * Date and time when the available credit hold is released.
     */
    'hold_end_time'?: string;
    /**
     * Whether the available credit hold was manually released for this payment.
     */
    'is_manually_released'?: boolean;
    /**
     * Customer-defined additional information about the payment (for example, a check number).
     */
    'metadata'?: string;
    /**
     * Method of payment.
     */
    'method': PaymentDetailResponseMethodEnum;
    /**
     * Whether the available credit is on hold for this payment.
     */
    'on_hold'?: boolean;
    /**
     * Unique identifier of the payment schedule.
     */
    'payment_schedule_token'?: string;
    /**
     * Unique identifier of the payment source.  Required for ACH payments.
     */
    'payment_source_token'?: string;
    /**
     * Date and time when the statement summary was migrated to Marqeta\'s credit platform, in UTC.  The value of this field is `null` if it has not been migrated.
     */
    'program_migration_time'?: string;
    'refund_details'?: RefundDetailsResponse | null;
    'returned_details'?: ReturnedDetails | null;
    'status': PaymentStatus;
    /**
     * Unique identifier of the payment.  If in the `detail_object`, unique identifier of the detail object.
     */
    'token': string;
    /**
     * Contains one or more `transitions` objects, which contain information about a payment status transition.
     */
    'transitions': Array<PaymentTransitionResponse>;
    /**
     * Date and time when the payment was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time': string;
    /**
     * A value of `true` indicates that a returned payment fee should not be applied. The default value of this field is `false`.  This field is only considered when transitioning the status of the fee to `REFUNDED`.
     */
    'waive_returned_payment_fee'?: boolean;
}

export const PaymentDetailResponseMethodEnum = {
    Ach: 'ACH',
    Check: 'CHECK',
    Debit: 'DEBIT',
    Cash: 'CASH',
    SecureCard: 'SECURE_CARD'
} as const;

export type PaymentDetailResponseMethodEnum = typeof PaymentDetailResponseMethodEnum[keyof typeof PaymentDetailResponseMethodEnum];

/**
 * Information about the payment facilitator of an account funding or original credit transaction.
 */
export interface PaymentFacilitatorModel {
    /**
     * Payment facilitator\'s city.
     */
    'city'?: string;
    /**
     * Payment facilitator\'s country code.
     */
    'country_code'?: string;
    /**
     * Payment facilitator\'s postal code.
     */
    'postal_code'?: string;
    /**
     * Payment facilitator\'s state location.
     */
    'state'?: string;
    /**
     * Payment facilitator\'s street address.
     */
    'street_address'?: string;
}
/**
 * Return payment reminders.
 */
export interface PaymentReminderPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains payment reminders on a credit account statement. Can be zero if none exist for the given statement.
     */
    'data': Array<PaymentReminderResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Details of a payment reminder.
 */
export interface PaymentReminderResponse {
    /**
     * Token of the associated account.
     */
    'account_token'?: string;
    /**
     * Date and time when the Billing Cycle was created on Marqeta\'s credit platform
     */
    'created_time'?: string;
    /**
     * Days until payment cutoff date
     */
    'days_until_due'?: number;
    /**
     * Last day a payment can be made before interest and fees are charged to the account.
     */
    'payment_cutoff_date'?: string;
    /**
     * Payment due date, based on the credit account settings.
     */
    'payment_due_date'?: string;
    /**
     * Amount remaining on the latest statement\'s minimum payment, after it\'s adjusted for payments, returned payments, and applicable credits that occurred after the latest statement\'s closing date.
     */
    'remaining_minimum_payment_due'?: number;
    /**
     * Token of the associated statement summary
     */
    'statement_summary_token'?: string;
    /**
     * Token of the payment reminder
     */
    'token'?: string;
}
/**
 * A category used to determine the actual payment amount.
 */

export const PaymentScheduleAmountCategory = {
    Fixed: 'FIXED',
    MinimumPayment: 'MINIMUM_PAYMENT',
    RemainingStatementBalance: 'REMAINING_STATEMENT_BALANCE',
    CurrentBalance: 'CURRENT_BALANCE'
} as const;

export type PaymentScheduleAmountCategory = typeof PaymentScheduleAmountCategory[keyof typeof PaymentScheduleAmountCategory];


/**
 * Information to create a payment schedule.
 */
export interface PaymentScheduleCreateReq {
    /**
     * Amount of the payment.  Required if `amount_category` is `FIXED`.
     */
    'amount'?: number;
    'amount_category': PaymentScheduleAmountCategory;
    'currency_code': CurrencyCode;
    /**
     * Description of the payment schedule.
     */
    'description'?: string;
    'frequency': PaymentScheduleFrequency;
    /**
     * Date to make a one-time payment.  Required if frequency is `ONCE`.
     */
    'next_payment_impact_date'?: string;
    /**
     * Day on which monthly payments are made.  Required if `frequency` is `MONTHLY`.
     */
    'payment_day'?: PaymentScheduleCreateReqPaymentDayEnum;
    /**
     * Unique identifier of the payment source.
     */
    'payment_source_token': string;
    /**
     * Unique identifier of the payment schedule.
     */
    'token'?: string;
}

export const PaymentScheduleCreateReqPaymentDayEnum = {
    PaymentDueDay: 'PAYMENT_DUE_DAY'
} as const;

export type PaymentScheduleCreateReqPaymentDayEnum = typeof PaymentScheduleCreateReqPaymentDayEnum[keyof typeof PaymentScheduleCreateReqPaymentDayEnum];

/**
 * Defines how often to make a scheduled payment.
 */

export const PaymentScheduleFrequency = {
    Once: 'ONCE',
    Monthly: 'MONTHLY'
} as const;

export type PaymentScheduleFrequency = typeof PaymentScheduleFrequency[keyof typeof PaymentScheduleFrequency];


/**
 * Returns paginated information for multiple payment schedules.
 */
export interface PaymentSchedulePage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * List of payment schedules.
     */
    'data': Array<PaymentScheduleResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * A future one-time or recurring payment schedule.
 */
export interface PaymentScheduleResponse {
    /**
     * Unique identifier of the credit account on which the payment schedule is made.
     */
    'account_token': string;
    /**
     * Amount of the payment.  Returned if the `amount_category` is `FIXED`.
     */
    'amount'?: number | null;
    'amount_category': PaymentScheduleAmountCategory;
    /**
     * Date and time when the payment schedule was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    'currency_code': CurrencyCode;
    /**
     * Description of the payment schedule.
     */
    'description'?: string;
    'frequency': PaymentScheduleFrequency;
    /**
     * Date to make a one-time payment.  Returned if `frequency` is `ONCE`.
     */
    'next_payment_impact_date'?: string;
    /**
     * Day on which monthly payments are made.  Returned if the `frequency` is `MONTHLY`.
     */
    'payment_day'?: PaymentScheduleResponsePaymentDayEnum;
    /**
     * Unique identifier of a payment source.
     */
    'payment_source_token': string;
    'status': PaymentScheduleStatus;
    /**
     * Unique identifier of the payment schedule.
     */
    'token': string;
    /**
     * Date and time when the payment schedule was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}

export const PaymentScheduleResponsePaymentDayEnum = {
    PaymentDueDay: 'PAYMENT_DUE_DAY'
} as const;

export type PaymentScheduleResponsePaymentDayEnum = typeof PaymentScheduleResponsePaymentDayEnum[keyof typeof PaymentScheduleResponsePaymentDayEnum];

/**
 * Status of the payment schedule.
 */

export const PaymentScheduleStatus = {
    Active: 'ACTIVE',
    Completed: 'COMPLETED',
    Terminated: 'TERMINATED'
} as const;

export type PaymentScheduleStatus = typeof PaymentScheduleStatus[keyof typeof PaymentScheduleStatus];


/**
 * Details to create a payment schedule transition
 */
export interface PaymentScheduleTransitionCreateReq {
    'status': PaymentScheduleStatus;
    /**
     * Unique identifier of the payment schedule transition.
     */
    'token'?: string;
}


/**
 * Returns paginated information for multiple payment schedule transitions.
 */
export interface PaymentScheduleTransitionPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * List of payment schedule transitions.
     */
    'data': Array<PaymentScheduleTransitionResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * A payment schedule transition on a credit account.
 */
export interface PaymentScheduleTransitionResponse {
    /**
     * Unique identifier of the credit account on which to transition a payment schedule.  Send a `GET` request to `/credit/accounts` to retrieve existing credit account tokens.
     */
    'account_token'?: string;
    /**
     * Date and time when the payment schedule transition was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Unique identifier of the payment schedule whose status is to transition.  Send a `GET` request to `/credit/accounts/{account_token}/paymentschedules` to retrieve existing payment schedule tokens.
     */
    'payment_schedule_token'?: string;
    'status'?: PaymentScheduleStatus;
    /**
     * Unique identifier of the payment schedule transition.
     */
    'token'?: string;
    /**
     * Date and time when the payment schedule transition was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}


/**
 * Contains information about a payment source.
 */
export interface PaymentSourceCreateReq {
    /**
     * Account number of the payment source.
     */
    'account_number': string;
    /**
     * Unique identifier of the credit account receiving the payment.
     */
    'account_token': string;
    /**
     * Name of the bank associated with the routing number.
     */
    'bank_name'?: string | null;
    /**
     * Unique identifier of the business making the payment.
     */
    'business_token'?: string;
    /**
     * Name of the individual or business who owns the payment source.
     */
    'name': string;
    /**
     * Type of payment source owner.
     */
    'owner'?: PaymentSourceCreateReqOwnerEnum;
    /**
     * Routing number of the payment source.
     */
    'routing_number': string;
    /**
     * Type of payment source.
     */
    'source_type': PaymentSourceCreateReqSourceTypeEnum;
    /**
     * Unique identifier of the payment source.
     */
    'token'?: string;
    /**
     * Unique identifier of the user making the payment.
     */
    'user_token'?: string;
    /**
     * Additional information on the verification.
     */
    'verification_notes'?: string;
    /**
     * Whether to override the verification process.
     */
    'verification_override': boolean;
}

export const PaymentSourceCreateReqOwnerEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS'
} as const;

export type PaymentSourceCreateReqOwnerEnum = typeof PaymentSourceCreateReqOwnerEnum[keyof typeof PaymentSourceCreateReqOwnerEnum];
export const PaymentSourceCreateReqSourceTypeEnum = {
    Checking: 'CHECKING',
    Savings: 'SAVINGS',
    SecureAccountFund: 'SECURE_ACCOUNT_FUND',
    Other: 'OTHER',
    External: 'EXTERNAL'
} as const;

export type PaymentSourceCreateReqSourceTypeEnum = typeof PaymentSourceCreateReqSourceTypeEnum[keyof typeof PaymentSourceCreateReqSourceTypeEnum];

/**
 * Returns paginated information for multiple payment sources.
 */
export interface PaymentSourcePage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * List of payment sources.
     */
    'data': Array<PaymentSourceResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information about a payment source.
 */
export interface PaymentSourceResponse {
    /**
     * Last four digits of the payment source account number.
     */
    'account_suffix'?: string;
    /**
     * Unique identifier of the credit account receiving the payment.
     */
    'account_token'?: string;
    /**
     * Name of the bank associated with the routing number.
     */
    'bank_name'?: string | null;
    /**
     * Unique identifier of the business making the payment.
     */
    'business_token'?: string;
    /**
     * Date and time when the payment source was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Date and time when the payment source was last updated on Marqeta\'s credit platform, in UTC.
     */
    'last_modified_time'?: string;
    /**
     * Name of the individual or business who owns the payment source.
     */
    'name'?: string;
    /**
     * Type of payment source owner.
     */
    'owner'?: PaymentSourceResponseOwnerEnum;
    /**
     * Routing number of the payment source.
     */
    'routing_number'?: string;
    /**
     * Type of payment source.
     */
    'source_type'?: PaymentSourceResponseSourceTypeEnum;
    'status'?: PaymentSourceStatusEnum;
    /**
     * Unique identifier of the payment source.
     */
    'token'?: string;
    /**
     * Unique identifier of the user making the payment.
     */
    'user_token'?: string;
    /**
     * Additional information on the verification (for example, an external verification identifier that\'s outside Marqeta\'s credit platform).
     */
    'verification_notes'?: string;
    /**
     * Status of the verification for the payment source.
     */
    'verification_status'?: PaymentSourceResponseVerificationStatusEnum;
}

export const PaymentSourceResponseOwnerEnum = {
    Individual: 'INDIVIDUAL',
    Business: 'BUSINESS'
} as const;

export type PaymentSourceResponseOwnerEnum = typeof PaymentSourceResponseOwnerEnum[keyof typeof PaymentSourceResponseOwnerEnum];
export const PaymentSourceResponseSourceTypeEnum = {
    Checking: 'CHECKING',
    Savings: 'SAVINGS',
    SecureAccountFund: 'SECURE_ACCOUNT_FUND',
    Other: 'OTHER',
    External: 'EXTERNAL'
} as const;

export type PaymentSourceResponseSourceTypeEnum = typeof PaymentSourceResponseSourceTypeEnum[keyof typeof PaymentSourceResponseSourceTypeEnum];
export const PaymentSourceResponseVerificationStatusEnum = {
    AchVerified: 'ACH_VERIFIED',
    Pending: 'PENDING'
} as const;

export type PaymentSourceResponseVerificationStatusEnum = typeof PaymentSourceResponseVerificationStatusEnum[keyof typeof PaymentSourceResponseVerificationStatusEnum];

/**
 * Current status of the payment source.
 */

export const PaymentSourceStatusEnum = {
    Active: 'ACTIVE',
    Pending: 'PENDING',
    Inactive: 'INACTIVE'
} as const;

export type PaymentSourceStatusEnum = typeof PaymentSourceStatusEnum[keyof typeof PaymentSourceStatusEnum];


/**
 * Request used to update the status of a payment source.
 */
export interface PaymentSourceUpdateReq {
    'status': PaymentSourceStatusEnum;
}


/**
 * Current status of the payment or refund.
 */

export const PaymentStatus = {
    Initiated: 'INITIATED',
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Cancelled: 'CANCELLED',
    Completed: 'COMPLETED',
    Returned: 'RETURNED',
    Refunded: 'REFUNDED',
    SysError: 'SYS_ERROR',
    AchError: 'ACH_ERROR'
} as const;

export type PaymentStatus = typeof PaymentStatus[keyof typeof PaymentStatus];


/**
 * Request used to transition the status of a payment.
 */
export interface PaymentTransitionReq {
    'refund_details'?: RefundDetails;
    'status': PaymentStatus;
    /**
     * Unique identifier of the payment status transition.
     */
    'token'?: string;
    /**
     * A value of `true` indicates that a returned payment fee should not be applied if one is applicable. This is false by default. This field is only considered during a transition to `REFUNDED`
     */
    'waive_returned_payment_fee'?: boolean;
}


/**
 * Response containing payment transition information.
 */
export interface PaymentTransitionResponse {
    /**
     * Unique identifier of the credit account on which you want to transition a payment status.
     */
    'account_token': string;
    /**
     * Date and time when the payment transition was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Unique identifier of the payment whose status you want to transition.
     */
    'payment_token': string;
    'status': PaymentStatus;
    /**
     * Unique identifier of the payment status transition.
     */
    'token': string;
}


/**
 * Returns paginated payments
 */
export interface PaymentsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more payments on a credit account.
     */
    'data': Array<PaymentDetailResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
export interface PeerTransferRequest {
    'amount': number;
    'currency_code': string;
    'memo'?: string;
    /**
     * Required if \'recipient_business_token\' is null
     */
    'recipient_business_token'?: string;
    /**
     * Required if \'recipient_business_token\' is null
     */
    'recipient_user_token'?: string;
    /**
     * Required if \'send_user_token\' is null
     */
    'sender_business_token'?: string;
    /**
     * Required if \'send_business_token\' is null
     */
    'sender_user_token'?: string;
    'tags'?: string;
    'token'?: string;
}
/**
 * Contains information about an intra-account transfer, including sender and recipient tokens, transfer amount, and currency code.
 */
export interface PeerTransferResponse {
    /**
     * Amount of the transfer.
     */
    'amount': number;
    'created_time': string;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * Additional descriptive text about the intra-account transfer.
     */
    'memo'?: string;
    /**
     * Specifies the business account holder that receives funds.
     */
    'recipient_business_token'?: string;
    /**
     * Specifies the user account holder that receives funds.
     */
    'recipient_user_token'?: string;
    /**
     * Specifies the business account holder that sends funds.
     */
    'sender_business_token'?: string;
    /**
     * Specifies the user account holder that sends funds.
     */
    'sender_user_token'?: string;
    /**
     * Metadata about the intra-account transfer.
     */
    'tags'?: string;
    /**
     * Unique identifier of the intra-account transfer request.
     */
    'token': string;
}
/**
 * periodic fee schedules on account
 */
export interface PeriodicFeeSchedule {
    /**
     * fee amount
     */
    'amount'?: number;
    /**
     * date the fee becomes effective
     */
    'effective_date'?: string;
    /**
     * date of the next time fee will be charged
     */
    'next_fee_impact_date'?: string;
    /**
     * type of fee to be charged
     */
    'type'?: PeriodicFeeScheduleTypeEnum;
}

export const PeriodicFeeScheduleTypeEnum = {
    AnnualFee: 'ANNUAL_FEE',
    MonthlyFee: 'MONTHLY_FEE'
} as const;

export type PeriodicFeeScheduleTypeEnum = typeof PeriodicFeeScheduleTypeEnum[keyof typeof PeriodicFeeScheduleTypeEnum];

/**
 * Return paginated periodic fee schedules on a credit account.
 */
export interface PeriodicFeeSchedulePage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * List of account periodic fee schedules.
     */
    'data': Array<PeriodicFeeSchedule>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
export interface PinRequest {
    /**
     * Unique value generated as a result of issuing a `POST` request to the `/pins/controltoken` endpoint. This value cannot be updated.
     */
    'control_token': string;
    /**
     * Four-digit number to associate with the card.
     */
    'pin': string;
}
export interface PinRevealRequest {
    /**
     * The supplemental method used to verify the cardholder\'s identity before revealing the card\'s personal identification number (PIN).  The possible cardholder verification methods are:  * *BIOMETRIC_FACE:* In-app authentication via facial recognition * *BIOMETRIC_FINGERPRINT:* In-app authentication via biometric fingerprint * *EXP_CVV:* In-app authentication by entering the card\'s expiration date and card verification value (CVV) * *LOGIN:* In-app authentication by re-entering the app password * *OTP:* Two-factor authentication involving a one-time password (OTP) * *OTP_CVV:* Two-factor authentication involving the card\'s CVV and an OTP * *OTHER:* Authentication that relies on other secure methods
     */
    'cardholder_verification_method': PinRevealRequestCardholderVerificationMethodEnum;
    /**
     * Unique value generated as a result of issuing a `POST` request to the `/pins/controltoken` endpoint. This value cannot be updated.
     */
    'control_token': string;
}

export const PinRevealRequestCardholderVerificationMethodEnum = {
    BiometricFace: 'BIOMETRIC_FACE',
    BiometricFingerprint: 'BIOMETRIC_FINGERPRINT',
    Login: 'LOGIN',
    ExpCvv: 'EXP_CVV',
    OtpCvv: 'OTP_CVV',
    Otp: 'OTP',
    Other: 'OTHER'
} as const;

export type PinRevealRequestCardholderVerificationMethodEnum = typeof PinRevealRequestCardholderVerificationMethodEnum[keyof typeof PinRevealRequestCardholderVerificationMethodEnum];

export interface PingResponse {
    'env'?: string;
    'id'?: string;
    'revision'?: string;
    'success'?: boolean;
    'timestamp'?: string;
    'version'?: string;
}
export interface Poi {
    /**
     * Default = false
     */
    'atm'?: boolean;
    'ecommerce'?: boolean;
    'other'?: OtherPoi;
}
/**
 * List response details for paginated document policies.
 */
export interface PoliciesDocumentPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * One or more document policies.
     */
    'data': Array<PolicyDocumentResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * List response details for product policies.
 */
export interface PoliciesProductPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * One or more credit product policies.
     */
    'data': Array<PolicyProductResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Request details for an APR policy.
 */
export interface PolicyAprCreateReq {
    /**
     * Description of the APR policy.
     */
    'description'?: string;
    /**
     * Name of the APR policy.
     */
    'name': string;
    'purchases': PolicyAprPurchaseReq;
    /**
     * Unique identifier of the APR policy.
     */
    'token'?: string;
}
/**
 * Contains information on the pricing strategy for purchases.
 */
export interface PolicyAprPurchaseReq {
    /**
     * Unique identifier of the external pricing strategy for the credit program.
     */
    'external_token'?: string;
    /**
     * Name of the pricing strategy.
     */
    'name'?: string;
    /**
     * One or more risk tiers for a pricing strategy.
     */
    'tiers': Array<PolicyAprTierReq>;
}
/**
 * Contains information on the pricing strategy for purchases.
 */
export interface PolicyAprPurchaseResponse {
    /**
     * Unique identifier of the pricing strategy on a credit program.
     */
    'external_token'?: string;
    /**
     * Name of the pricing strategy.
     */
    'name'?: string;
    /**
     * One or more risk tiers for a pricing strategy.
     */
    'tiers'?: Array<PolicyAprTierResponse>;
}
/**
 * Contains information on an APR policy.
 */
export interface PolicyAprResponse {
    /**
     * Date and time when the APR policy was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Description of the APR policy.
     */
    'description'?: string;
    /**
     * Date the APR goes into effect, in UTC.
     */
    'effective_date'?: string;
    /**
     * Name of the APR policy.
     */
    'name'?: string;
    'purchases'?: PolicyAprPurchaseResponse;
    /**
     * Unique identifier of the APR policy.
     */
    'token'?: string;
    /**
     * Date and time when the APR policy was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}
/**
 * Request details for the APR for a risk tier.
 */
export interface PolicyAprTierReq {
    /**
     * Number of percentage points added to the prime rate, used to calculate a variable APR value.
     */
    'margin_rate': number;
}
/**
 * Response details for the APR for a risk tier.
 */
export interface PolicyAprTierResponse {
    /**
     * Value of the APR.
     */
    'apr'?: number;
    /**
     * Margin rate for the risk tier for a pricing strategy.
     */
    'margin_rate'?: number;
}
/**
 * Request details for an APR policy.
 */
export interface PolicyAprUpdateReq {
    /**
     * Description of the APR policy.
     */
    'description'?: string;
    /**
     * Name of the APR policy.
     */
    'name': string;
    'purchases'?: PolicyAprPurchaseReq;
    /**
     * Unique identifier of the APR policy.
     */
    'token'?: string;
}
/**
 * List response details for paginated APR policies.
 */
export interface PolicyAprsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * One or more APR policies.
     */
    'data': Array<PolicyAprResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Request details for a specific asset and the template on which it was based.
 */
export interface PolicyDocumentAssetAndTemplateReq {
    /**
     * Unique identifier of the asset, which is the version of a document that is based on the template and contains finalized values. The values are finalized when the bundle containing the document is created.
     */
    'asset_token': string;
    /**
     * Unique identifier of the template, which is the version of a document that serves as an initial disclosure but does not contain finalized values. The values are finalized in the asset version of the document.
     */
    'template_token': string;
}
/**
 * Return details for a specific asset and the template on which it was based.
 */
export interface PolicyDocumentAssetAndTemplateResponse {
    /**
     * Date and time when the asset was created.
     */
    'asset_created_time'?: string;
    /**
     * Unique identifier of the asset, which is the version of a document that is based on the template and contains finalized values. The values are finalized when the bundle containing the document is created.
     */
    'asset_token'?: string;
    'asset_urls'?: PolicyDocumentAssetURLs;
    /**
     * Date and time when the template was created.
     */
    'template_created_time'?: string;
    /**
     * Unique identifier of the template, which is the version of a document that serves as an initial disclosure but does not contain finalized values. Values are finalized in the asset version of the document.
     */
    'template_token'?: string;
    'template_urls'?: PolicyDocumentTemplateURLs;
}
/**
 * Request details for a specific asset.
 */
export interface PolicyDocumentAssetReq {
    /**
     * Unique identifier of the asset, which is a type of document that contains finalized values. The values are finalized when the bundle containing the document is created.
     */
    'asset_token': string;
}
/**
 * Return details for a specific asset.
 */
export interface PolicyDocumentAssetResponse {
    /**
     * Date and time when the asset was created.
     */
    'asset_created_time'?: string;
    /**
     * Unique identifier of the asset, which is a type of document that contains finalized values. The values are finalized when the bundle containing the document is created.
     */
    'asset_token'?: string;
    'asset_urls'?: PolicyDocumentAssetURLs;
}
/**
 * Contains one or more URLs for an asset.
 */
export interface PolicyDocumentAssetURLs {
    /**
     * URL to the HTML version of the asset.
     */
    'html': string;
    /**
     * URL to the PDF version of the asset.
     */
    'pdf': string;
    /**
     * URL to the PNG version of the asset.
     */
    'png': string;
}
/**
 * Contains information on a document policy.
 */
export interface PolicyDocumentCreateReq {
    'account_statement': PolicyDocumentTemplateReq;
    'benefits_disclosure_premium': PolicyDocumentAssetReq;
    'benefits_disclosure_traditional': PolicyDocumentAssetReq;
    'card_member_agreement': PolicyDocumentAssetReq;
    'e_disclosure': PolicyDocumentAssetReq;
    /**
     * Name of the document policy.
     */
    'name': string;
    'noaa_multiple_reason_with_dodd_frank': PolicyDocumentTemplateReq;
    'noaa_single_reason': PolicyDocumentTemplateReq;
    'noaa_single_reason_with_dodd_frank': PolicyDocumentTemplateReq;
    'pre_qualification_disclosure'?: PolicyDocumentAssetAndTemplateReq;
    'privacy_policy': PolicyDocumentAssetReq;
    'rewards_disclosure'?: PolicyDocumentAssetAndTemplateReq;
    'summary_of_credit_terms': PolicyDocumentAssetAndTemplateReq;
    'terms_schedule': PolicyDocumentTemplateReq;
    /**
     * Unique identifier of the document policy.
     */
    'token'?: string;
}
/**
 * Contains information on a document policy.
 */
export interface PolicyDocumentResponse {
    'account_statement'?: PolicyDocumentTemplateResponse;
    'benefits_disclosure_premium'?: PolicyDocumentAssetResponse;
    'benefits_disclosure_traditional'?: PolicyDocumentAssetResponse;
    'card_member_agreement'?: PolicyDocumentAssetResponse;
    /**
     * Date and time when the document policy was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    'e_disclosure'?: PolicyDocumentAssetResponse;
    /**
     * Name of the document policy.
     */
    'name'?: string;
    'noaa_multiple_reason_with_dodd_frank'?: PolicyDocumentTemplateResponse;
    'noaa_single_reason'?: PolicyDocumentTemplateResponse;
    'noaa_single_reason_with_dodd_frank'?: PolicyDocumentTemplateResponse;
    'pre_qualification_disclosure'?: PolicyDocumentAssetAndTemplateResponse;
    'privacy_policy'?: PolicyDocumentAssetResponse;
    'rewards_disclosure'?: PolicyDocumentAssetAndTemplateResponse;
    'summary_of_credit_terms'?: PolicyDocumentAssetAndTemplateResponse;
    'terms_schedule'?: PolicyDocumentTemplateResponse;
    /**
     * Unique identifier of the document policy.
     */
    'token'?: string;
    /**
     * Date and time when the document policy was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}
/**
 * Request details for a template.
 */
export interface PolicyDocumentTemplateReq {
    /**
     * Unique identifier of a template, which is a document that serves as an initial disclosure but does not contain finalized values.
     */
    'template_token': string;
}
/**
 * Response details for a template.
 */
export interface PolicyDocumentTemplateResponse {
    /**
     * Date and time when the template was created.
     */
    'template_created_time'?: string;
    /**
     * Unique identifier of a template, which is a document that serves as an initial disclosure but does not contain finalized values.
     */
    'template_token'?: string;
    'template_urls'?: PolicyDocumentTemplateURLs;
}
/**
 * Contains one or more URLs for a template.
 */
export interface PolicyDocumentTemplateURLs {
    /**
     * URL to the HTML version of the document template.
     */
    'html': string;
}
/**
 * Request details to update a document policy.
 */
export interface PolicyDocumentUpdateReq {
    'account_statement': PolicyDocumentTemplateReq;
    'benefits_disclosure_premium': PolicyDocumentAssetReq;
    'benefits_disclosure_traditional': PolicyDocumentAssetReq;
    'card_member_agreement': PolicyDocumentAssetReq;
    'e_disclosure': PolicyDocumentAssetReq;
    /**
     * Name of the document policy.
     */
    'name': string;
    'noaa_multiple_reason_with_dodd_frank': PolicyDocumentTemplateReq;
    'noaa_single_reason': PolicyDocumentTemplateReq;
    'noaa_single_reason_with_dodd_frank': PolicyDocumentTemplateReq;
    'pre_qualification_disclosure'?: PolicyDocumentAssetAndTemplateReq;
    'privacy_policy': PolicyDocumentAssetReq;
    'rewards_disclosure'?: PolicyDocumentAssetAndTemplateReq;
    'summary_of_credit_terms': PolicyDocumentAssetAndTemplateReq;
    'terms_schedule': PolicyDocumentTemplateReq;
}
/**
 * Contains information on the fees in an account\'s fee policy.
 */
export interface PolicyFeeAccount {
    'annual_fee'?: PolicyFeePeriodic;
    'foreign_transaction_fee'?: PolicyFeeForeignTransaction;
    'late_payment'?: PolicyFeePayment;
    'monthly_fee'?: PolicyFeePeriodic;
    'returned_payment'?: PolicyFeePayment;
}
/**
 * Request details for a fee policy.
 */
export interface PolicyFeeCreateReq {
    'account': PolicyFeeAccount;
    /**
     * Description of the fee policy.
     */
    'description'?: string;
    /**
     * Name of the fee policy.
     */
    'name': string;
    /**
     * Unique identifier of the fee policy.
     */
    'token'?: string;
}
/**
 * Contains information on a specific fee in a fee policy.
 */
export interface PolicyFeeForeignTransaction {
    /**
     * Method used to calculate the fee value.
     */
    'default_method'?: PolicyFeeForeignTransactionDefaultMethodEnum;
    /**
     * Percentage value for the foreign transaction fee.
     */
    'default_value'?: number;
}

export const PolicyFeeForeignTransactionDefaultMethodEnum = {
    Percentage: 'PERCENTAGE'
} as const;

export type PolicyFeeForeignTransactionDefaultMethodEnum = typeof PolicyFeeForeignTransactionDefaultMethodEnum[keyof typeof PolicyFeeForeignTransactionDefaultMethodEnum];

/**
 * Contains information on a specific fee in a fee policy.
 */
export interface PolicyFeePayment {
    /**
     * Method used to calculate the fee value.
     */
    'default_method'?: PolicyFeePaymentDefaultMethodEnum;
    /**
     * Amount of the fee.
     */
    'default_value'?: number;
}

export const PolicyFeePaymentDefaultMethodEnum = {
    Flat: 'FLAT'
} as const;

export type PolicyFeePaymentDefaultMethodEnum = typeof PolicyFeePaymentDefaultMethodEnum[keyof typeof PolicyFeePaymentDefaultMethodEnum];

/**
 * Contains information on a specific periodic fee in a fee policy.
 */
export interface PolicyFeePeriodic {
    /**
     * Whether the periodic fee is excluded from interest calculation.
     */
    'exclude_from_interest_calc'?: boolean;
    /**
     * Amount of the fee.
     */
    'fee_amount'?: number;
    /**
     * Number of days after an account is activated that the initial fee is charged. For example, if the value in this field is `30`, then the initial fee is charged 30 days after an account is activated.
     */
    'number_of_days_post_activation'?: number;
}
/**
 * Contains information on a fee policy.
 */
export interface PolicyFeeResponse {
    'account'?: PolicyFeeAccount;
    /**
     * Date and time when the fee policy was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Description of the fee policy.
     */
    'description'?: string;
    /**
     * Name of the fee policy.
     */
    'name'?: string;
    /**
     * Unique identifier of the fee policy.
     */
    'token'?: string;
    /**
     * Date and time when the fee policy was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}
/**
 * Response details to update a fee policy.
 */
export interface PolicyFeeUpdateReq {
    'account'?: PolicyFeeAccount;
    /**
     * Description of the fee policy.
     */
    'description'?: string;
    /**
     * Name of the fee policy.
     */
    'name': string;
    'periodic'?: PolicyFeePeriodic;
}
/**
 * List response details for fee policies.
 */
export interface PolicyFeesPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * One or more fee policies.
     */
    'data': Array<PolicyFeeResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information on an offer policy.
 */
export interface PolicyOfferResponse {
    /**
     * Date and time when the offer policy was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Description of the offer policy.
     */
    'description'?: string;
    /**
     * Name of the offer policy.
     */
    'name'?: string;
    /**
     * Unique identifier of the offer policy.
     */
    'token'?: string;
    /**
     * Date and time when the offer policy was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}
/**
 * Level of the card product.
 */

export const PolicyProductCardProductLevel = {
    Premium: 'PREMIUM',
    Traditional: 'TRADITIONAL'
} as const;

export type PolicyProductCardProductLevel = typeof PolicyProductCardProductLevel[keyof typeof PolicyProductCardProductLevel];


/**
 * Contains information on the card products associated with the credit product policy.
 */
export interface PolicyProductCardProductReq {
    'level': PolicyProductCardProductLevel;
    /**
     * Unique identifier of the card product.
     */
    'token': string;
}


/**
 * Contains information on the card products associated with the credit product policy.
 */
export interface PolicyProductCardProductResponse {
    'level'?: PolicyProductCardProductLevel;
    /**
     * Name of the card network.
     */
    'network'?: PolicyProductCardProductResponseNetworkEnum;
    /**
     * Unique identifier of the card product.
     */
    'token'?: string;
}

export const PolicyProductCardProductResponseNetworkEnum = {
    Visa: 'VISA',
    Mastercard: 'MASTERCARD',
    Sandbox: 'SANDBOX'
} as const;

export type PolicyProductCardProductResponseNetworkEnum = typeof PolicyProductCardProductResponseNetworkEnum[keyof typeof PolicyProductCardProductResponseNetworkEnum];

/**
 * Request details for a credit product policy.
 */
export interface PolicyProductCreateReq {
    /**
     * One or more card products associated with the credit product policy.
     */
    'card_products': Array<PolicyProductCardProductReq>;
    'classification': ProductClassification;
    'credit_line': ProductCreditLine;
    'currency_code': CurrencyCode;
    /**
     * Description of the credit product policy.
     */
    'description'?: string;
    'interest_calculation': InterestCalculation;
    /**
     * Name of the credit product policy.
     */
    'name': string;
    'payments': PolicyProductPaymentConfiguration;
    'product_sub_type': ProductSubType;
    'product_type': ProductType;
    /**
     * Unique identifier of the credit product policy.
     */
    'token'?: string;
    /**
     * One or more usage types for the credit product policy.
     */
    'usage': Array<BalanceType>;
}


/**
 * Contains information used to calculate the minimum payment amount on a credit product policy.
 */
export interface PolicyProductMinPaymentCalculation {
    /**
     * Whether to include the overlimit amount when calculating the minimum payment.
     */
    'include_overlimit_amount': boolean;
    /**
     * Whether to include the past due amount when calculating the minimum payment.
     */
    'include_past_due_amount': boolean;
    /**
     * Minimum payment, expressed as a flat amount, due on the payment due day.
     */
    'min_payment_flat_amount'?: number;
    'min_payment_percentage'?: PolicyProductMinPaymentPercentage;
}
/**
 * Contains information used to calculate the minimum payment amount when expressed as a percentage.
 */
export interface PolicyProductMinPaymentPercentage {
    /**
     * Whether to include all fees charged when calculating the minimum payment.
     */
    'include_all_fees_charged'?: boolean;
    /**
     * Whether to include the amount of interest charged when calculating the minimum payment.
     */
    'include_interest_charged': boolean;
    /**
     * Minimum payment, expressed as a percentage of the total statement balance, due on the payment due day.
     */
    'percentage_of_balance': number;
}
/**
 * Contains the configurations for billing cycle day, payment due day, and fees.
 */
export interface PolicyProductPaymentConfiguration {
    /**
     * Ordered list of balance types to which payments are allocated, from first to last.
     */
    'allocation_order': Array<PaymentAllocationOrderEnum>;
    /**
     * Day of the month when the billing cycle starts.
     */
    'billing_cycle_day': number;
    /**
     * Determines if the billing cycle day is manually set or determined dynamically during account creation based on cycling logic.
     */
    'billing_cycle_day_strategy'?: PolicyProductPaymentConfigurationBillingCycleDayStrategyEnum;
    /**
     * Frequency at which the account is billed.
     */
    'billing_cycle_frequency'?: PolicyProductPaymentConfigurationBillingCycleFrequencyEnum;
    /**
     * Day of month the payment for the previous billing cycle is due.  This field is being deprecated and replaced by `payment_due_interval` of a product policy. To retrieve `payment_due_interval`, see <</core-api/credit-policies#retrieveProductPolicy, Retrieve credit product policy, payments.payment_due_interval>>.
     * @deprecated
     */
    'due_day'?: number;
    'min_payment_calculation': PolicyProductMinPaymentCalculation;
    /**
     * Specifies the payment due interval that is used to determine the payment due date for a billing cycle. A value of -1 indicates one day prior to the next billing cycle date.  For consumer programs, a minimum gap of 21 days is required between when a statement is delivered and the payment due date.
     */
    'payment_due_interval'?: number;
}

export const PolicyProductPaymentConfigurationBillingCycleDayStrategyEnum = {
    Manual: 'MANUAL'
} as const;

export type PolicyProductPaymentConfigurationBillingCycleDayStrategyEnum = typeof PolicyProductPaymentConfigurationBillingCycleDayStrategyEnum[keyof typeof PolicyProductPaymentConfigurationBillingCycleDayStrategyEnum];
export const PolicyProductPaymentConfigurationBillingCycleFrequencyEnum = {
    Monthly: 'MONTHLY'
} as const;

export type PolicyProductPaymentConfigurationBillingCycleFrequencyEnum = typeof PolicyProductPaymentConfigurationBillingCycleFrequencyEnum[keyof typeof PolicyProductPaymentConfigurationBillingCycleFrequencyEnum];

/**
 * Contains information on the credit product policy.
 */
export interface PolicyProductResponse {
    /**
     * One or more card products associated with the credit product policy.
     */
    'card_products'?: Array<PolicyProductCardProductResponse>;
    'classification'?: ProductClassification;
    /**
     * Date and time when the credit product policy was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    'credit_line'?: ProductCreditLine;
    'currency_code'?: CurrencyCode;
    /**
     * Description of the credit product policy.
     */
    'description'?: string;
    'interest_calculation'?: InterestCalculation;
    /**
     * Name of the credit product policy.
     */
    'name'?: string;
    'payments'?: PolicyProductPaymentConfiguration;
    'product_sub_type'?: ProductSubType;
    'product_type'?: ProductType;
    /**
     * Unique identifier of the credit product policy.
     */
    'token'?: string;
    /**
     * Date and time when the credit product policy was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
    /**
     * One or more usage types for the credit product policy.
     */
    'usage'?: Array<BalanceType>;
}


/**
 * Request details to update a credit product policy.
 */
export interface PolicyProductUpdateReq {
    /**
     * One or more card products associated with the credit product policy.
     */
    'card_products': Array<PolicyProductCardProductReq>;
    'classification': ProductClassification;
    'credit_line': ProductCreditLine;
    'currency_code': CurrencyCode;
    /**
     * Description of the credit product policy.
     */
    'description'?: string;
    'interest_calculation': InterestCalculation;
    /**
     * Name of the credit product policy.
     */
    'name': string;
    'payments': PolicyProductPaymentConfiguration;
    'product_sub_type': ProductSubType;
    'product_type': ProductType;
    /**
     * One or more usage types for the credit product policy.
     */
    'usage': Array<BalanceType>;
}


/**
 * Reward accrual strategy for a credit program. If no value for `accrual_strategy` is set, the default value of this field is `DEFAULT`.
 */

export const PolicyRewardAccrualType = {
    Default: 'DEFAULT',
    Payment: 'PAYMENT'
} as const;

export type PolicyRewardAccrualType = typeof PolicyRewardAccrualType[keyof typeof PolicyRewardAccrualType];


/**
 * Defines the conversion properties intended for a reward policy.
 */
export interface PolicyRewardConversion {
    /**
     * The static amount to reward if the rule conditions are met.
     */
    'conversion_increment': number;
    /**
     * The rate that points are worth with converting the REDEMPTION_TYPE indicated.
     */
    'conversion_rate': number;
    /**
     * Type of currency used with the conversion rate.
     */
    'currency'?: string;
    'type': PolicyRewardConversionType;
}


/**
 * Type of conversion.
 */

export const PolicyRewardConversionType = {
    StatementCredit: 'STATEMENT_CREDIT'
} as const;

export type PolicyRewardConversionType = typeof PolicyRewardConversionType[keyof typeof PolicyRewardConversionType];


/**
 * Defines what merchant category codes (MCCs) are excluded from earning rewards. MCCs must be a four-digit number, or a range of two four-digit numbers separated by a hyphen.
 */
export interface PolicyRewardExclusions {
    /**
     * List of merchant category codes (MCCs). MCCs must be a four-digit number, or a range of two four-digit numbers separated by a hyphen.
     */
    'custom_exclusions'?: Array<string>;
    /**
     * Indicates whether to use the default exclusion list.  * If `true`, the default exclusion list is used. * If `false`, the custom exclusion list is used, if custom exclusions are included.
     */
    'use_default_exclusions'?: boolean;
}
/**
 * List of response details for reward policies.
 */
export interface PolicyRewardPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * List of one or more reward policies.
     */
    'data': Array<PolicyRewardResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Defines the rules intended for a reward policy.
 */
export interface PolicyRewardPlatformRule {
    /**
     * The static amount to reward if the rule conditions are met.
     */
    'amount'?: number | null;
    'attributes'?: PolicyRewardRuleAttributes;
    /**
     * Type of calculation to use to evaluate if a rule has been satisfied.
     */
    'calculation_type'?: PolicyRewardPlatformRuleCalculationTypeEnum;
    /**
     * The description of the rule.
     */
    'description': string;
    /**
     * The reward multiplier to apply the transaction, where \'1\' means 1x transaction amount.
     */
    'multiplier'?: number | null;
    /**
     * Type of rule.
     */
    'type': PolicyRewardPlatformRuleTypeEnum;
}

export const PolicyRewardPlatformRuleCalculationTypeEnum = {
    PerTransaction: 'PER_TRANSACTION'
} as const;

export type PolicyRewardPlatformRuleCalculationTypeEnum = typeof PolicyRewardPlatformRuleCalculationTypeEnum[keyof typeof PolicyRewardPlatformRuleCalculationTypeEnum];
export const PolicyRewardPlatformRuleTypeEnum = {
    MultiplierPerTransaction: 'MULTIPLIER_PER_TRANSACTION'
} as const;

export type PolicyRewardPlatformRuleTypeEnum = typeof PolicyRewardPlatformRuleTypeEnum[keyof typeof PolicyRewardPlatformRuleTypeEnum];

/**
 * Request details for a reward policy.
 */
export interface PolicyRewardReq {
    'accrual_strategy'?: PolicyRewardAccrualType;
    /**
     * List of one or more reward conversions.
     */
    'conversions': Array<PolicyRewardConversion>;
    /**
     * Description of the reward policy.
     */
    'description'?: string;
    'exclusions': PolicyRewardExclusions;
    /**
     * Name of the reward policy.
     */
    'name': string;
    /**
     * List of one or more reward rules.
     */
    'rules': Array<PolicyRewardPlatformRule>;
    'settlement_strategy': PolicyRewardSettlementType;
    /**
     * Unique identifier of the reward policy.
     */
    'token'?: string;
}


/**
 * Contains information on a reward policy.
 */
export interface PolicyRewardResponse {
    'accrual_strategy'?: PolicyRewardAccrualType;
    /**
     * List of one or more reward conversions.
     */
    'conversions'?: Array<PolicyRewardConversion>;
    /**
     * Date and time when the reward policy was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Description of the reward policy.
     */
    'description'?: string;
    'exclusions'?: PolicyRewardExclusions;
    /**
     * Name of the reward policy.
     */
    'name'?: string;
    /**
     * A list of one or more reward rules.
     */
    'rules'?: Array<PolicyRewardPlatformRule>;
    'settlement_strategy'?: PolicyRewardSettlementType;
    /**
     * Unique identifier of the reward policy.
     */
    'token'?: string;
    /**
     * Date and time when the reward policy was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}


/**
 * Additional properties for which the rule can be used to determine reward accrual eligibility for a transaction.
 */
export interface PolicyRewardRuleAttributes {
    /**
     * Maximum spend amount.
     */
    'max_spend'?: number;
    /**
     * List of merchant category codes (MCCs). MCCs must be a four-digit number, or a range of two four-digit numbers separated by a hyphen.
     */
    'mcc'?: Array<string>;
    /**
     * Merchant ID for the rule.
     */
    'mid'?: string;
    /**
     * Minimum spend amount.
     */
    'min_spend'?: number;
    /**
     * Total spend amount.
     */
    'spend_total'?: number;
}
/**
 * Reward settlement strategy for a credit program.
 */

export const PolicyRewardSettlementType = {
    Statement: 'STATEMENT',
    Live: 'LIVE'
} as const;

export type PolicyRewardSettlementType = typeof PolicyRewardSettlementType[keyof typeof PolicyRewardSettlementType];


/**
 * Type of policy.
 */

export const PolicyType = {
    Apr: 'APR',
    Document: 'DOCUMENT',
    Fee: 'FEE',
    Offer: 'OFFER',
    Product: 'PRODUCT',
    Reward: 'REWARD',
    All: 'ALL'
} as const;

export type PolicyType = typeof PolicyType[keyof typeof PolicyType];


/**
 * Contains information about the point of sale, including details on how the card was presented.  Returned if provided by the card network, and the request uses Transaction Model v2 of the Marqeta Core API. Not returned for Transaction Model v1 requests.
 */
export interface Pos {
    /**
     * How the terminal accepts card data.
     */
    'card_data_input_capability'?: PosCardDataInputCapabilityEnum;
    /**
     * Whether the cardholder was present during the transaction.
     */
    'card_holder_presence'?: boolean;
    /**
     * Whether the card was present during the transaction.
     */
    'card_presence'?: boolean;
    /**
     * Method used to authenticate the cardholder.
     */
    'cardholder_authentication_method'?: PosCardholderAuthenticationMethodEnum;
    /**
     * Country code of the card acceptor or terminal.
     */
    'country_code'?: string;
    /**
     * County of the card acceptor or terminal.
     */
    'county'?: string;
    /**
     * Whether the transaction is an installment payment.
     */
    'is_installment'?: boolean;
    /**
     * Whether the transaction is recurring.
     */
    'is_recurring'?: boolean;
    /**
     * Method used for capturing the card primary account number (PAN) during the transaction.
     */
    'pan_entry_mode'?: PosPanEntryModeEnum;
    /**
     * Indicates whether the card acceptor or terminal supports partial-approval transactions.
     */
    'partial_approval_capable'?: boolean;
    /**
     * Indicates whether the card acceptor or terminal can capture card personal identification numbers (PINs).  *NOTE:* This field does not indicate whether a PIN was entered.
     */
    'pin_entry_mode'?: PosPinEntryModeEnum;
    /**
     * Indicates whether the cardholder entered a PIN during the transaction.
     */
    'pin_present'?: boolean;
    /**
     * Indicates whether the card acceptor or terminal supports purchase-only approvals.
     */
    'purchase_amount_only'?: boolean;
    /**
     * Indicates a higher-risk operation, such as a quasi-cash or cryptocurrency transaction.  These transactions typically involve non-financial institutions.
     */
    'special_condition_indicator'?: PosSpecialConditionIndicatorEnum;
    /**
     * State, province, or territory of the card acceptor or terminal.
     */
    'state'?: string;
    /**
     * Whether the card acceptor/terminal was attended.
     */
    'terminal_attendance'?: PosTerminalAttendanceEnum;
    /**
     * Card acceptor or terminal identification number.
     */
    'terminal_id'?: string;
    /**
     * Location of the card acceptor/terminal.
     */
    'terminal_location'?: PosTerminalLocationEnum;
    /**
     * Type of card acceptor/terminal.
     */
    'terminal_type'?: PosTerminalTypeEnum;
    /**
     * Specifies the initiator of the transaction.
     */
    'transaction_initiated_by'?: PosTransactionInitiatedByEnum;
    /**
     * Specifies the category of a point-of-sale transaction.
     */
    'transaction_initiated_category'?: PosTransactionInitiatedCategoryEnum;
    /**
     * United States ZIP code of the card acceptor or terminal.
     */
    'zip'?: string;
}

export const PosCardDataInputCapabilityEnum = {
    Unknown: 'UNKNOWN',
    NoTerminal: 'NO_TERMINAL',
    MagStripe: 'MAG_STRIPE',
    MagStripeContactless: 'MAG_STRIPE_CONTACTLESS',
    MagStripeKeyEntry: 'MAG_STRIPE_KEY_ENTRY',
    Chip: 'CHIP',
    ChipContactless: 'CHIP_CONTACTLESS',
    ChipMagStripe: 'CHIP_MAG_STRIPE',
    ChipMagStripeKeyEntry: 'CHIP_MAG_STRIPE_KEY_ENTRY',
    KeyEntry: 'KEY_ENTRY',
    Ocr: 'OCR',
    Micr: 'MICR',
    BarCode: 'BAR_CODE',
    CredentialsOnFile: 'CREDENTIALS_ON_FILE'
} as const;

export type PosCardDataInputCapabilityEnum = typeof PosCardDataInputCapabilityEnum[keyof typeof PosCardDataInputCapabilityEnum];
export const PosCardholderAuthenticationMethodEnum = {
    Unspecified: 'UNSPECIFIED',
    NonAuthenticated: 'NON_AUTHENTICATED',
    Signature: 'SIGNATURE',
    Pin: 'PIN',
    IdVerified: 'ID_VERIFIED',
    ElectronicSignature: 'ELECTRONIC_SIGNATURE',
    Biometric: 'BIOMETRIC',
    Biographic: 'BIOGRAPHIC',
    ManualSignature: 'MANUAL_SIGNATURE',
    ElectronicTicketEnvironment: 'ELECTRONIC_TICKET_ENVIRONMENT'
} as const;

export type PosCardholderAuthenticationMethodEnum = typeof PosCardholderAuthenticationMethodEnum[keyof typeof PosCardholderAuthenticationMethodEnum];
export const PosPanEntryModeEnum = {
    Unknown: 'UNKNOWN',
    Manual: 'MANUAL',
    MagStripe: 'MAG_STRIPE',
    MagStripeContactless: 'MAG_STRIPE_CONTACTLESS',
    BarCode: 'BAR_CODE',
    Ocr: 'OCR',
    Micr: 'MICR',
    Chip: 'CHIP',
    ChipContactless: 'CHIP_CONTACTLESS',
    CardOnFile: 'CARD_ON_FILE',
    ChipFallback: 'CHIP_FALLBACK',
    Other: 'OTHER',
    KeyEntered: 'KEY_ENTERED',
    CredentialsOnFile: 'CREDENTIALS_ON_FILE',
    KeyedCardPcsc: 'KEYED_CARD_PCSC',
    MagStripeReadKeyedPcsc: 'MAG_STRIPE_READ_KEYED_PCSC'
} as const;

export type PosPanEntryModeEnum = typeof PosPanEntryModeEnum[keyof typeof PosPanEntryModeEnum];
export const PosPinEntryModeEnum = {
    Unknown: 'UNKNOWN',
    True: 'TRUE',
    False: 'FALSE',
    Defective: 'DEFECTIVE'
} as const;

export type PosPinEntryModeEnum = typeof PosPinEntryModeEnum[keyof typeof PosPinEntryModeEnum];
export const PosSpecialConditionIndicatorEnum = {
    Unspecified: 'UNSPECIFIED',
    CryptocurrencyPurchase: 'CRYPTOCURRENCY_PURCHASE',
    QuasiCash: 'QUASI_CASH',
    DebtPayment: 'DEBT_PAYMENT',
    CentralBankDigitalCurrencyPurchase: 'CENTRAL_BANK_DIGITAL_CURRENCY_PURCHASE',
    StablecoinPurchase: 'STABLECOIN_PURCHASE',
    BlockchainNativeTokenPurchase: 'BLOCKCHAIN_NATIVE_TOKEN_PURCHASE',
    NonFungibleTokenPurchase: 'NON_FUNGIBLE_TOKEN_PURCHASE'
} as const;

export type PosSpecialConditionIndicatorEnum = typeof PosSpecialConditionIndicatorEnum[keyof typeof PosSpecialConditionIndicatorEnum];
export const PosTerminalAttendanceEnum = {
    Unspecified: 'UNSPECIFIED',
    Attended: 'ATTENDED',
    Unattended: 'UNATTENDED',
    NoTerminal: 'NO_TERMINAL',
    MobileRemote: 'MOBILE_REMOTE',
    TransitAccessTerminal: 'TRANSIT_ACCESS_TERMINAL'
} as const;

export type PosTerminalAttendanceEnum = typeof PosTerminalAttendanceEnum[keyof typeof PosTerminalAttendanceEnum];
export const PosTerminalLocationEnum = {
    OnPremise: 'ON_PREMISE',
    OnPremiseCardholder: 'ON_PREMISE_CARDHOLDER',
    OffPremiseCardholder: 'OFF_PREMISE_CARDHOLDER',
    OnPremiseMerchant: 'ON_PREMISE_MERCHANT',
    OffPremiseMerchant: 'OFF_PREMISE_MERCHANT',
    NoTerminal: 'NO_TERMINAL',
    MobileRemote: 'MOBILE_REMOTE',
    TransitAccessTerminal: 'TRANSIT_ACCESS_TERMINAL',
    Unspecified: 'UNSPECIFIED'
} as const;

export type PosTerminalLocationEnum = typeof PosTerminalLocationEnum[keyof typeof PosTerminalLocationEnum];
export const PosTerminalTypeEnum = {
    AutoDispenserWithPin: 'AUTO_DISPENSER_WITH_PIN',
    SelfService: 'SELF_SERVICE',
    LimitedAmount: 'LIMITED_AMOUNT',
    InFlight: 'IN_FLIGHT',
    Ecommerce: 'ECOMMERCE',
    Transponder: 'TRANSPONDER'
} as const;

export type PosTerminalTypeEnum = typeof PosTerminalTypeEnum[keyof typeof PosTerminalTypeEnum];
export const PosTransactionInitiatedByEnum = {
    Consumer: 'CONSUMER',
    Merchant: 'MERCHANT',
    Unknown: 'UNKNOWN',
    Marqeta: 'MARQETA',
    Network: 'NETWORK'
} as const;

export type PosTransactionInitiatedByEnum = typeof PosTransactionInitiatedByEnum[keyof typeof PosTransactionInitiatedByEnum];
export const PosTransactionInitiatedCategoryEnum = {
    CardOnFile: 'CARD_ON_FILE',
    RecurringVarAmtFixedFreq: 'RECURRING_VAR_AMT_FIXED_FREQ',
    RecurringPayment: 'RECURRING_PAYMENT',
    InstallmentPayment: 'INSTALLMENT_PAYMENT',
    UnscheduledPayment: 'UNSCHEDULED_PAYMENT',
    PartialShipment: 'PARTIAL_SHIPMENT',
    DelayedPayment: 'DELAYED_PAYMENT',
    NoShow: 'NO_SHOW',
    Resubmission: 'RESUBMISSION',
    DeferredBilling: 'DEFERRED_BILLING',
    AccountInquiry: 'ACCOUNT_INQUIRY',
    IncrementalAuthorization: 'INCREMENTAL_AUTHORIZATION',
    Reauthorization: 'REAUTHORIZATION'
} as const;

export type PosTransactionInitiatedCategoryEnum = typeof PosTransactionInitiatedCategoryEnum[keyof typeof PosTransactionInitiatedCategoryEnum];

export interface PostTokenizationAuthenticationDecisionRequest {
    /**
     * Correlates multiple authentication requests.
     */
    'authRequestCorrelationId'?: string;
    /**
     * Authentication method used to verify the cardholder.
     */
    'authenticationMethod': PostTokenizationAuthenticationDecisionRequestAuthenticationMethodEnum;
    /**
     * Optional comment related to the decision.
     */
    'commentText'?: string;
    /**
     * Issuer decision after cardholder authentication.
     */
    'decision': PostTokenizationAuthenticationDecisionRequestDecisionEnum;
    /**
     * Unique identifier of the token allocated to the card.
     */
    'tokenUniqueReference': string;
}

export const PostTokenizationAuthenticationDecisionRequestAuthenticationMethodEnum = {
    IssuerApplication: 'Issuer Application',
    WebPortal: 'Web Portal'
} as const;

export type PostTokenizationAuthenticationDecisionRequestAuthenticationMethodEnum = typeof PostTokenizationAuthenticationDecisionRequestAuthenticationMethodEnum[keyof typeof PostTokenizationAuthenticationDecisionRequestAuthenticationMethodEnum];
export const PostTokenizationAuthenticationDecisionRequestDecisionEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type PostTokenizationAuthenticationDecisionRequestDecisionEnum = typeof PostTokenizationAuthenticationDecisionRequestDecisionEnum[keyof typeof PostTokenizationAuthenticationDecisionRequestDecisionEnum];

export interface PostTokenizationAuthenticationDecisionResponse {
    /**
     * Human-readable description of the outcome.
     */
    'message': string;
    /**
     * Indicates if the operation was successful.
     */
    'status': PostTokenizationAuthenticationDecisionResponseStatusEnum;
}

export const PostTokenizationAuthenticationDecisionResponseStatusEnum = {
    Success: 'SUCCESS',
    Failed: 'FAILED'
} as const;

export type PostTokenizationAuthenticationDecisionResponseStatusEnum = typeof PostTokenizationAuthenticationDecisionResponseStatusEnum[keyof typeof PostTokenizationAuthenticationDecisionResponseStatusEnum];

export interface PreKycControls {
    /**
     * Minimum is 0
     */
    'balance_max'?: number;
    'cash_access_enabled'?: boolean;
    'enable_non_program_loads'?: boolean;
    'international_enabled'?: boolean;
    'is_reloadable_pre_kyc'?: boolean;
}
/**
 * Returned for `authorization.clearing` transaction types following a financial advice.  Contains information about the preceding transaction.
 */
export interface PrecedingTransaction {
    /**
     * Amount of the preceding transaction.
     */
    'amount'?: number;
    /**
     * Unique identifier of the preceding transaction.
     */
    'token'?: string;
}
export interface PrimaryContactInfoModel {
    'department'?: string;
    'email'?: string;
    'extension'?: string;
    'fax'?: string;
    'full_name'?: string;
    'mobile'?: string;
    'phone'?: string;
    'title'?: string;
}
/**
 * Specifies for whom the credit product is intended.  * `CONSUMER` - The credit product is intended for individual consumers. * `SMALL_AND_MEDIUM_BUSINESS` - The credit product is intended for small and medium business.
 */

export const ProductClassification = {
    Consumer: 'CONSUMER',
    SmallAndMediumBusiness: 'SMALL_AND_MEDIUM_BUSINESS'
} as const;

export type ProductClassification = typeof ProductClassification[keyof typeof ProductClassification];


/**
 * Contains information on configurations for billing cycle day, payment due day, and fees.
 */
export interface ProductConfig {
    /**
     * Day of the month when the billing cycle starts.
     */
    'billing_cycle_day': number;
    /**
     * Determines if the billing cycle day is manually set or determined dynamically during account creation based on cycling logic.
     */
    'billing_cycle_day_strategy'?: ProductConfigBillingCycleDayStrategyEnum;
    /**
     * Frequency at which the account is billed.
     */
    'billing_cycle_frequency'?: ProductConfigBillingCycleFrequencyEnum;
    /**
     * One or more fee types.
     */
    'fees'?: Array<ProductFeeType>;
    /**
     * Day of month the payment for the previous billing cycle is due.  This field is deprecated. Use the `product.payment_due_interval` field instead. To retrieve `payment_due_interval`, see <</core-api/credit-products#retrieveProduct, Retrieve credit product, config.payment_due_interval>>.
     * @deprecated
     */
    'payment_due_day'?: number;
    /**
     * Specifies the payment due interval that is used to determine the payment due date for a billing cycle. A value of -1 indicates one day prior to the next billing cycle date.  For consumer programs, a minimum gap of 21 days is required between when a statement is delivered and the payment due date.
     */
    'payment_due_interval'?: number;
    /**
     * Contains one or more periodic fees.
     */
    'periodic_fees'?: Array<ProductConfigPeriodicFeesInner>;
}

export const ProductConfigBillingCycleDayStrategyEnum = {
    Manual: 'MANUAL'
} as const;

export type ProductConfigBillingCycleDayStrategyEnum = typeof ProductConfigBillingCycleDayStrategyEnum[keyof typeof ProductConfigBillingCycleDayStrategyEnum];
export const ProductConfigBillingCycleFrequencyEnum = {
    Monthly: 'MONTHLY'
} as const;

export type ProductConfigBillingCycleFrequencyEnum = typeof ProductConfigBillingCycleFrequencyEnum[keyof typeof ProductConfigBillingCycleFrequencyEnum];

/**
 * Contains information on a periodic fee.
 */
export interface ProductConfigPeriodicFeesInner {
    /**
     * How frequently the fee is charged.
     */
    'frequency': ProductConfigPeriodicFeesInnerFrequencyEnum;
    /**
     * Number of days after an account is activated that the initial fee is charged. For example, if the value in this field is `30`, then the initial fee is charged 30 days after an account is activated.
     */
    'number_of_days_post_activation': number;
}

export const ProductConfigPeriodicFeesInnerFrequencyEnum = {
    Annual: 'ANNUAL',
    Monthly: 'MONTHLY'
} as const;

export type ProductConfigPeriodicFeesInnerFrequencyEnum = typeof ProductConfigPeriodicFeesInnerFrequencyEnum[keyof typeof ProductConfigPeriodicFeesInnerFrequencyEnum];

/**
 * Specifies shared details for a credit program.  Once set to `ACTIVE`, cannot be edited or deleted.
 */
export interface ProductCreateReq {
    /**
     * One or more associated card product tokens.
     */
    'card_product_tokens': Array<string>;
    'classification': ProductClassification;
    'config': ProductConfig;
    'credit_line': ProductCreditLine;
    'currency_code': CurrencyCode;
    /**
     * Description of the credit product.
     */
    'description'?: string;
    'interest_calculation': InterestCalculation;
    'min_payment_calculation'?: ProductMinPaymentCalculation;
    /**
     * Minimum payment, expressed as a flat amount, due on the payment due day.
     */
    'min_payment_flat_amount': number;
    /**
     * Minimum payment, expressed as a percentage of the total statement balance, due on the payment due day.
     */
    'min_payment_percentage': number;
    /**
     * Name of the credit product.
     */
    'name': string;
    /**
     * Ordered list of balance types to which payments are allocated, from first to last.
     */
    'payment_allocation_order': Array<PaymentAllocationOrderEnum>;
    'product_sub_type': ProductSubType;
    'product_type': ProductType;
    'status'?: ResourceStatus;
    /**
     * Unique identifier of the credit product.
     */
    'token'?: string;
    /**
     * One or more usage types for the credit product.
     */
    'usage': Array<BalanceType>;
}


/**
 * Contains information on the credit line range.
 */
export interface ProductCreditLine {
    /**
     * Maximum credit limit.
     */
    'max': number;
    /**
     * Minimum credit limit.
     */
    'min': number;
}
/**
 * Type of fee.
 */

export const ProductFeeType = {
    LatePaymentFee: 'LATE_PAYMENT_FEE',
    ReturnedPaymentFee: 'RETURNED_PAYMENT_FEE',
    ForeignTransactionFee: 'FOREIGN_TRANSACTION_FEE'
} as const;

export type ProductFeeType = typeof ProductFeeType[keyof typeof ProductFeeType];


/**
 * Contains information used to calculate the minimum payment amount.
 */
export interface ProductMinPaymentCalculation {
    /**
     * Whether to include the past due amount when calculating the minimum payment.
     */
    'include_past_due_amount': boolean;
    /**
     * Minimum payment, expressed as a flat amount, due on the payment due day.
     */
    'min_payment_flat_amount': number;
    'min_payment_percentage': ProductMinPaymentPercentage;
}
/**
 * Contains information used to calculate the minimum payment percentage.
 */
export interface ProductMinPaymentPercentage {
    /**
     * Whether to include all fees charged when calculating the minimum payments.
     */
    'include_all_fees_charged'?: boolean;
    /**
     * One or more fee types to include when calculating the minimum payment.
     */
    'include_fees_charged': Array<ProductFeeType>;
    /**
     * Minimum payment, expressed as a percentage of the total statement balance, due on the payment due day.
     */
    'percentage_of_balance': number;
}
/**
 * Specifies shared details for a credit program.  Once set to `ACTIVE`, cannot be edited or deleted.
 */
export interface ProductResponse {
    /**
     * One or more associated card product tokens.
     */
    'card_product_tokens'?: Array<string>;
    'classification'?: ProductClassification;
    'config'?: ProductConfig;
    /**
     * Date and time when the credit product was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    'credit_line'?: ProductCreditLine;
    'currency_code'?: CurrencyCode;
    /**
     * Description of the credit product.
     */
    'description'?: string;
    'interest_calculation'?: InterestCalculation;
    'min_payment_calculation'?: ProductMinPaymentCalculation;
    /**
     * Minimum payment, expressed as a flat amount, due on the payment due day.
     */
    'min_payment_flat_amount'?: number;
    /**
     * Minimum payment, expressed as a percentage of the total statement balance, due on the payment due day.
     */
    'min_payment_percentage'?: number;
    /**
     * Name of the credit product.
     */
    'name'?: string;
    /**
     * Unique identifier of the parent credit product.
     */
    'parent_product_token'?: string;
    /**
     * Ordered list of balance types to which payments are allocated, from first to last.
     */
    'payment_allocation_order'?: Array<PaymentAllocationOrderEnum>;
    'product_sub_type'?: ProductSubType;
    'product_type'?: ProductType;
    'status'?: ResourceStatus;
    /**
     * Unique identifier of the credit product.
     */
    'token'?: string;
    /**
     * Date and time when the credit product was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
    /**
     * One or more usage types for the credit product.
     */
    'usage'?: Array<BalanceType>;
}


/**
 * Subtype of the credit product type.  `CREDIT_CARD` - Card that enables the cardholder to make purchases on credit. `SECURED_CARD` - Card backed by user-funded deposit that enables the cardholder to make purchases on credit.
 */

export const ProductSubType = {
    CreditCard: 'CREDIT_CARD',
    SecuredCard: 'SECURED_CARD'
} as const;

export type ProductSubType = typeof ProductSubType[keyof typeof ProductSubType];


/**
 * Type of credit product.  `REVOLVING` - Allows users to continuously borrow and pay debts up to the credit limit.
 */

export const ProductType = {
    Revolving: 'REVOLVING'
} as const;

export type ProductType = typeof ProductType[keyof typeof ProductType];


/**
 * Returns paginated products.
 */
export interface ProductsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more credit product objects.
     */
    'data': Array<ProductResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Information about the program on the Marqeta platform.
 */
export interface Program {
    /**
     * The program long code on the Marqeta platform.
     */
    'long_code': string;
    /**
     * The program identifier on the Marqeta platform.
     */
    'program_id': string;
    /**
     * The program short code on the Marqeta platform.
     */
    'short_code': string;
}
/**
 * Returns paginated program fundings.
 */
export interface ProgramFundingPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more program fundings.
     */
    'data': Array<ProgramFundingResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Returns details of a program funding entry.
 */
export interface ProgramFundingResponse {
    /**
     * Amount of the funding.
     */
    'amount': number;
    /**
     * Timestamp when the funding entry was created.
     */
    'created_time': string;
    'currency_code': CurrencyCode;
    /**
     * Additional notes for the funding entry.
     */
    'memo': string;
    /**
     * Timestamp when the funding entry was posted.
     */
    'post_time': string;
    /**
     * Unique identifier of the program.
     */
    'short_code': string;
    /**
     * Unique identifier of the funding entry.
     */
    'token': string;
    /**
     * Timestamp when the funding entry was last updated.
     */
    'updated_time': string;
}


export interface ProgramFundingSourceModel extends FundingSourceModel {
    'name': string;
}
export interface ProgramFundingSourceRequest {
    'active'?: boolean;
    'name': string;
    'token'?: string;
}
export interface ProgramFundingSourceResponse {
    'account': string;
    'active'?: boolean;
    'created_time': string;
    'last_modified_time': string;
    'name': string;
    'token': string;
}
export interface ProgramFundingSourceUpdateRequest {
    'active'?: boolean;
    'name'?: string;
}
/**
 * Contains information relevant to creating a Credit Program Gateway.
 */
export interface ProgramGatewayCreateReq {
    /**
     * Indicates whether the Program Gateway is active.
     */
    'active'?: boolean;
    /**
     * Basic Authentication password for authenticating your environment.
     */
    'basic_auth_password': string;
    /**
     * Basic Authentication username for authenticating your environment.
     */
    'basic_auth_username': string;
    /**
     * Additional custom information included in the HTTP header. For example, this might contain security information, along with Basic Authentication, when making a Program Gateway request. Custom headers also appear in the associated webhook\'s notifications.
     */
    'custom_header'?: { [key: string]: string; };
    /**
     * Indicates whether the Program Gateway uses mutual Transport Layer Security (mTLS).
     */
    'mtls'?: boolean;
    /**
     * Name of the Program Gateway.
     */
    'name': string;
    /**
     * Total timeout for Program Gateway calls, in milliseconds.
     */
    'timeout_millis'?: number;
    /**
     * Unique identifier of the Program Gateway.  If you do not include a token, the system generates one automatically. As this token is necessary for use in other calls, it is recommended that you define a simple and easy to remember string rather than letting the system generate a token for you. This value cannot be updated.
     */
    'token'?: string;
    /**
     * URL of the Program Gateway endpoint hosted in your environment and configured to receive authorization requests made by the Marqeta platform. Must be HTTPS.
     */
    'url': string;
}
export interface ProgramGatewayFundingSourceModel extends FundingSourceModel {
    'name': string;
}
/**
 * Returns paginated Program Gateways.
 */
export interface ProgramGatewayPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more Program Gateway objects.
     */
    'data': Array<ProgramGatewayResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information relevant to a Credit Program Gateway.
 */
export interface ProgramGatewayResponse {
    /**
     * Indicates whether the Program Gateway is active.
     */
    'active'?: boolean;
    /**
     * Basic Authentication password for authenticating your environment.
     */
    'basic_auth_password'?: string;
    /**
     * Basic Authentication username for authenticating your environment.
     */
    'basic_auth_username'?: string;
    /**
     * Date and time when the Program Gateway was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Additional custom information included in the HTTP header.
     */
    'custom_header'?: object;
    /**
     * Indicates whether the Program Gateway uses mutual Transport Layer Security (mTLS).
     */
    'mtls'?: boolean;
    /**
     * Name of the Program Gateway.
     */
    'name'?: string;
    /**
     * Total timeout for Program Gateway calls, in milliseconds.
     */
    'timeout_millis'?: number;
    /**
     * Unique identifier of the Program Gateway.
     */
    'token'?: string;
    /**
     * Date and time when the Program Gateway was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
    /**
     * URL of the Program Gateway endpoint hosted in your environment and configured to receive authorization requests made by the Marqeta platform.
     */
    'url'?: string;
}
/**
 * Contains information relevant to updating a Program Gateway.
 */
export interface ProgramGatewayUpdateReq {
    /**
     * Indicates whether the Program Gateway is active.
     */
    'active'?: boolean;
    /**
     * Basic Authentication password for authenticating your environment.
     */
    'basic_auth_password'?: string;
    /**
     * Basic Authentication username for authenticating your environment.
     */
    'basic_auth_username'?: string;
    /**
     * Additional custom information included in the HTTP header. For example, this might contain security information, along with Basic Authentication, when making a Program Gateway request. Custom headers also appear in the associated webhook\'s notifications.
     */
    'custom_header'?: { [key: string]: string; };
    /**
     * Indicates whether the Program Gateway uses mutual Transport Layer Security (mTLS).
     */
    'mtls'?: boolean;
    /**
     * Name of the Program Gateway.
     */
    'name'?: string;
    /**
     * Total timeout for Program Gateway calls, in milliseconds.
     */
    'timeout_millis'?: number;
    /**
     * Unique identifier of the Program Gateway.
     */
    'token'?: string;
    /**
     * URL of the Program Gateway endpoint hosted in your environment and configured to receive authorization requests made by the Marqeta platform. Must be HTTPS.
     */
    'url'?: string;
}
export interface ProgramReserveAccountBalance {
    /**
     * Ledger balance, minus any authorized transactions that have not yet cleared. When using JIT Funding, this balance is usually equal to $0.00.
     */
    'available_balance'?: number;
    /**
     * Contains program reserve account balance information, organized by currency code. Sometimes referred to as a _program funding account_.
     */
    'balances'?: { [key: string]: ProgramReserveAccountBalance; };
    /**
     * Not currently in use.
     */
    'credit_balance'?: number;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code'?: string;
    /**
     * When using standard funding: The funds that are available to spend immediately, including funds from any authorized transactions that have not yet cleared. When using Just-in-Time (JIT) Funding: Authorized funds that are currently on hold, but not yet cleared.
     */
    'ledger_balance'?: number;
    /**
     * ACH loads that have been accepted, but for which the funding time has not yet elapsed.
     */
    'pending_credits'?: number;
}
export interface ProgramReserveDepositRequest {
    /**
     * Amount of the deposit.
     */
    'amount': number;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * Idempotent hash value associated with the deposit request.
     */
    'idempotentHash'?: string;
    'is_collateral'?: boolean;
    /**
     * Memo or note describing the deposit request.
     */
    'memo'?: string;
    /**
     * Comma-delimited list of tags describing the deposit request.
     */
    'tags'?: string;
    /**
     * Unique identifier of the deposit request.
     */
    'token': string;
}
export interface ProgramReserveTransactionListResponse {
    /**
     * Number of resources to retrieve.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * List of program reserve transactions.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<ProgramReserveTransactionResponse>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface ProgramReserveTransactionResponse {
    /**
     * Amount of the program reserve account credit or debit. Sometimes referred to as a _program funding account_.
     */
    'amount'?: number;
    /**
     * Date and time when the resource was created, in UTC.
     */
    'created_time': string;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code'?: string;
    'is_collateral'?: boolean;
    /**
     * The date and time when the resource was last modified, in UTC.
     */
    'last_modified_time': string;
    /**
     * Memo or note describing the transaction.
     */
    'memo'?: string;
    /**
     * Transaction state.
     */
    'state'?: ProgramReserveTransactionResponseStateEnum;
    /**
     * Comma-delimited list of tags describing the transaction.
     */
    'tags'?: string;
    /**
     * The unique identifier of the transaction response.
     */
    'token'?: string;
    /**
     * Unique identifier of the transaction.
     */
    'transaction_token'?: string;
    /**
     * Transaction type.
     */
    'type'?: ProgramReserveTransactionResponseTypeEnum;
}

export const ProgramReserveTransactionResponseStateEnum = {
    Pending: 'PENDING',
    Complete: 'COMPLETE'
} as const;

export type ProgramReserveTransactionResponseStateEnum = typeof ProgramReserveTransactionResponseStateEnum[keyof typeof ProgramReserveTransactionResponseStateEnum];
export const ProgramReserveTransactionResponseTypeEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    PendingCredit: 'PENDING_CREDIT',
    PendingDebit: 'PENDING_DEBIT'
} as const;

export type ProgramReserveTransactionResponseTypeEnum = typeof ProgramReserveTransactionResponseTypeEnum[keyof typeof ProgramReserveTransactionResponseTypeEnum];

export interface ProgramTransfer {
    /**
     * Amount of program transfer.
     */
    'amount': number;
    /**
     * Unique identifier of the business. Pass either a `business_token` or a `user_token`, not both.  Send a `GET` request to `/businesses` to retrieve business tokens.
     */
    'business_token'?: string;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * Contains attributes that define characteristics of one or more fees. This array is returned in the response when it is included in the request.
     */
    'fees'?: Array<FeeModel>;
    /**
     * Memo or note describing the program transfer.
     */
    'memo'?: string;
    /**
     * Comma-delimited list of tags describing the program transfer.
     */
    'tags'?: string;
    /**
     * Unique identifier of the program transfer.  If you do not include a token, the system will generate one automatically. This token is necessary for use in other API calls, so we recommend that rather than let the system generate one, you use a simple string that is easy to remember. This value cannot be updated.
     */
    'token'?: string;
    /**
     * Unique identifier of the program transfer type.  Send a `GET` request to `/programtransfers/types` to retrieve program transfer type tokens.
     */
    'type_token': string;
    /**
     * Unique identifier of the user. Pass either a `user_token` or a `business_token`, not both.  Send a `GET` request to `/users` to retrieve business tokens.
     */
    'user_token'?: string;
}
export interface ProgramTransferListResponse {
    /**
     * Number of program transfer resources to retrieve.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of program transfer objects.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<ProgramTransferResponse>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
/**
 * Contains information about a program transfer, which moves funds from an account holder\'s GPA to a program funding source.
 */
export interface ProgramTransferResponse {
    /**
     * Amount of program transfer.
     */
    'amount': number;
    /**
     * Unique identifier of the business account holder. Returned if `user_token` is not specified.
     */
    'business_token'?: string;
    /**
     * Date and time when the program transfer object was created, in UTC.
     */
    'created_time'?: string;
    /**
     * Three-digit ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * Contains attributes that define characteristics of one or more fees.
     */
    'fees'?: Array<FeeDetail>;
    'jit_funding'?: JitFundingApi;
    /**
     * Additional description of the program transfer.
     */
    'memo'?: string;
    /**
     * Comma-delimited list of tags describing the program transfer.
     */
    'tags'?: string;
    /**
     * Unique identifier of the program transfer.
     */
    'token'?: string;
    /**
     * Unique identifier of the transaction.
     */
    'transaction_token': string;
    /**
     * Unique identifier of the program transfer type.
     */
    'type_token': string;
    /**
     * Unique identifier of the user account holder. Returned if `business_token` is not specified.
     */
    'user_token'?: string;
}
export interface ProgramTransferTypeListResponse {
    /**
     * Number of program transfer resources to retrieve.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of program transfer types.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<ProgramTransferTypeResponse>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface ProgramTransferTypeRequest {
    /**
     * Memo or note describing the program transfer type.
     */
    'memo': string;
    /**
     * Unique identifier of the program funding source to which program transfers will be credited.  Send a `GET` request to `/fundingsources/program` to retrieve program funding source tokens.
     */
    'program_funding_source_token': string;
    /**
     * Comma-delimited list of tags describing the program transfer type.
     */
    'tags'?: string;
    /**
     * Unique identifier of the program transfer type.  If you do not include a token, the system will generate one automatically. This token is necessary for use in other API calls, so we recommend that rather than let the system generate one, you use a simple string that is easy to remember. This value cannot be updated.
     */
    'token'?: string;
}
export interface ProgramTransferTypeResponse {
    /**
     * The date and time when the program transfer type object was created, in UTC.
     */
    'created_time'?: string;
    /**
     * Date and time when the program transfer type object was last modified, in UTC.
     */
    'last_modified_time'?: string;
    /**
     * Memo or note describing the program transfer type.
     */
    'memo'?: string;
    /**
     * Unique identifier of the program funding source to which program transfers will be credited.
     */
    'program_funding_source_token': string;
    /**
     * Comma-delimited list of tags describing the program transfer type.
     */
    'tags'?: string;
    /**
     * Unique identifier of the program transfer type request object.
     */
    'token': string;
}
export interface ProvisioningControls {
    'dwt_tar_avs_decline_on_address_number_mismatch'?: boolean;
    'dwt_tar_avs_decline_on_postal_code_mismatch'?: boolean;
    'dwt_use_card_status_during_auth'?: boolean;
    'dwt_verify_atc_during_auth'?: boolean;
    'enable_discretionary_data_during_tar'?: boolean;
    /**
     * A value of `true` requires identity verification set-up for all digital wallets at the card product level.
     */
    'force_yellow_path_for_card_product'?: boolean;
    'in_app_provisioning'?: InAppProvisioning;
    'manual_entry'?: ManualEntry;
    'wallet_provider_card_on_file'?: WalletProviderCardOnFile;
    'web_push_provisioning'?: WebPushProvisioning;
}
export interface PushToCardDisburseListResponse {
    'count'?: number;
    'data'?: Array<PushToCardDisbursementResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface PushToCardDisburseRequest {
    'amount': number;
    'currency_code': string;
    'memo'?: string;
    'payment_instrument_token': string;
    'soft_descriptor'?: PTCSoftDescriptor;
    'tags'?: string;
    'token'?: string;
}
export interface PushToCardDisbursementResponse {
    'amount'?: number;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'currency_code'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'memo'?: string;
    'payment_instrument_token'?: string;
    'status'?: string;
    'tags'?: string;
    'token'?: string;
}
export interface PushToCardListResponse {
    'count'?: number;
    'data'?: Array<PushToCardResponse>;
    'end_index'?: number;
    'is_more'?: boolean;
    'start_index'?: number;
}
export interface PushToCardRequest {
    'address_1': string;
    'address_2'?: string;
    'city': string;
    'country': string;
    'cvv': string;
    'exp_date': string;
    'name_on_card': string;
    'pan': string;
    'postal_code': string;
    'state': string;
    'token'?: string;
    'user_token': string;
}
export interface PushToCardResponse {
    'address_1'?: string;
    'address_2'?: string;
    'city'?: string;
    'country'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'exp_date'?: string;
    'fast_fund_transfer_eligible'?: boolean;
    'gambling_fund_transfer_eligible'?: boolean;
    'last_four'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'last_name'?: string;
    'name_on_card'?: string;
    'postal_code'?: string;
    'state'?: string;
    'token'?: string;
}
/**
 * Contains information about a real-time fee group.
 */
export interface RealTimeFeeGroup {
    /**
     * Indicates whether the real-time fee group is active.
     */
    'active': boolean;
    /**
     * Date and time when the real-time fee group was created, in UTC.
     */
    'created_time'?: string;
    /**
     * Specifies the fees in this real-time fee group.
     */
    'fee_tokens'?: Set<string>;
    /**
     * Date and time when the real-time fee group was last modified, in UTC.
     */
    'last_modified_time'?: string;
    /**
     * Descriptive name for the real-time fee group.
     */
    'name': string;
    /**
     * Unique identifier of the real-time fee group.
     */
    'token': string;
}
export interface RealTimeFeeGroupCreateRequest {
    /**
     * Indicates whether the real-time fee group is active.
     */
    'active'?: boolean;
    /**
     * Unique identifiers of the fees in this real-time fee group. Send a `GET` request to `/fees` to retrieve fee resource tokens.  No two fees in the group can be applicable to the same transaction type (in other words, each fee must have a different value for its `real_time_assessment.transaction_type` field).
     */
    'fee_tokens'?: Set<string>;
    /**
     * Descriptive name for the real-time fee group.
     */
    'name': string;
    /**
     * Unique identifier of the real-time fee group.  If you do not include a token, the system will generate one automatically. This token is necessary for use in other API calls, so we recommend that rather than let the system generate one, you use a simple string that is easy to remember. This value cannot be updated.
     */
    'token'?: string;
}
export interface RealTimeFeeGroupListResponse {
    /**
     * Number of resources to retrieve.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of real time fee group objects.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<RealTimeFeeGroup>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface RealTimeFeeGroupRequest {
    /**
     * Indicates whether the real-time fee group is active.
     */
    'active'?: boolean;
    /**
     * Specifies the fees in this real-time fee group. Send a `GET` request to `/fees` to retrieve fee resources tokens.  No two fees in the group can be applicable to the same transaction type (in other words, each fee must have a different value for its `real_time_assessment.transaction_type` field).
     */
    'fee_tokens'?: Set<string>;
    /**
     * Descriptive name for the real-time fee group.
     */
    'name'?: string;
}
export interface RealTimeStandinCriteria {
    'enabled'?: boolean;
    'include_application_errors'?: boolean;
    'include_connection_errors'?: boolean;
    'include_response_timeouts'?: boolean;
}
export interface RealtimeFeeTransferRequest {
    'fee'?: FeeModel;
    'original_transaction_token'?: string;
    'token'?: string;
}
/**
 * Specifies the details of a refund creation request.
 */
export interface RefundCreateRequest {
    /**
     * Amount of the refund.  The maximum refund amount is the amount that brings the account balance to $0. For example, $4000 is the maximum refund amount for a -$4000 account balance.
     */
    'amount'?: number;
    'currency_code'?: CurrencyCode;
    /**
     * Description of the refund.
     */
    'description'?: string;
    'method': RefundMethod;
    /**
     * Unique identifier of the payment source that receives the refunded amount.
     */
    'payment_source_token'?: string;
    /**
     * Unique identifier of the refund.
     */
    'token'?: string;
    'type': RefundType;
}


/**
 * Contains details for a refund.
 */
export interface RefundDetails {
    /**
     * Description of the refund.
     */
    'description': string;
    'method': RefundMethod;
}


/**
 * Contains details for a refund.
 */
export interface RefundDetailsResponse {
    /**
     * Description of the refund.
     */
    'description': string;
    'method': RefundMethod;
    'status': RefundStatus;
}


/**
 * Payment instrument used to issue the refund.
 */

export const RefundMethod = {
    Ach: 'ACH',
    Check: 'CHECK'
} as const;

export type RefundMethod = typeof RefundMethod[keyof typeof RefundMethod];


/**
 * Detailed refund response object.
 */
export interface RefundResponse {
    /**
     * Unique identifier of the account for which the refund is issued.
     */
    'account_token': string;
    /**
     * Amount of the refund.  The maximum refund amount is the amount that brings the account balance to $0. For example, $4000 is the maximum refund amount for a -$4000 account balance.
     */
    'amount': number;
    /**
     * Date and time when the refund was created.
     */
    'created_time': string;
    'currency_code': CurrencyCode;
    /**
     * Description of the refund.
     */
    'description'?: string;
    'method': RefundMethod;
    /**
     * Unique identifier of the payment source that receives the refunded amount.
     */
    'payment_source_token'?: string;
    'status': RefundStatus;
    /**
     * Unique identifier of the refund.
     */
    'token': string;
    'type': RefundType;
    /**
     * Date and time when the refund was last updated.
     */
    'updated_time': string;
}


/**
 * Current status of the refund.
 */

export const RefundStatus = {
    Initiated: 'INITIATED',
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Submitted: 'SUBMITTED',
    Cancelled: 'CANCELLED',
    Completed: 'COMPLETED',
    Returned: 'RETURNED'
} as const;

export type RefundStatus = typeof RefundStatus[keyof typeof RefundStatus];


/**
 * Request used to transition the status of a refund.
 */
export interface RefundTransitionRequest {
    'status': RefundStatus;
    /**
     * Unique identifier of the refund status transition.
     */
    'token'?: string;
}


/**
 * Response containing refund transition information.
 */
export interface RefundTransitionResponse {
    /**
     * Unique identifier of the credit account on which you want to transition a refund status.
     */
    'account_token': string;
    /**
     * Date and time when the refund transition was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    /**
     * Unique identifier of the refund whose status you want to transition.
     */
    'refund_token': string;
    'status': RefundStatus;
    /**
     * Unique identifier of the refund status transition.
     */
    'token': string;
}


/**
 * Return paginated refund transition response.
 */
export interface RefundTransitionsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more `transitions` objects, which contain information on a refund status transition.
     */
    'data': Array<RefundTransitionResponse>;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Type of refund.
 */

export const RefundType = {
    PaymentRefund: 'PAYMENT_REFUND',
    CreditBalanceRefund: 'CREDIT_BALANCE_REFUND'
} as const;

export type RefundType = typeof RefundType[keyof typeof RefundType];


/**
 * Returns paginated  list of refund resources.
 */
export interface RefundsPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more refunds on a credit account.
     */
    'data': Array<RefundResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
export interface RequestForApplePayWppJWT {
    /**
     * Unique identifier of the card resource.
     */
    'card_token': string;
    /**
     * Random pseudo-unique value used for troubleshooting between multiple parties.
     */
    'req-sys-id'?: string;
}
export interface RequestForWppParameters {
    /**
     * Unique identifier of the card resource.
     */
    'card_token': string;
}
export interface ResetUserPasswordEmailModel {
    /**
     * Cardholder email address.
     */
    'email': string;
}
export interface ResetUserPasswordModel {
    /**
     * New password to the cardholder\'s user account on the Marqeta platform.
     */
    'new_password': string;
    /**
     * Unique identifier of the cardholder.
     */
    'user_token': string;
}
/**
 * Status of the credit product.  * `DRAFT` - The credit product is in the process of being created. * `PENDING_APPROVAL` - The credit product has been created and is awaiting approval. * `SENT_FOR_REVISION` - The credit product has been returned for revision. * `ACTIVE` - The credit product is active. * `REJECTED` - The credit product has been rejected; this status cannot be changed. * `ARCHIVED` - The previously active credit product has been archived.
 */

export const ResourceStatus = {
    Draft: 'DRAFT',
    PendingApproval: 'PENDING_APPROVAL',
    SentForRevision: 'SENT_FOR_REVISION',
    Active: 'ACTIVE',
    Rejected: 'REJECTED',
    Archived: 'ARCHIVED'
} as const;

export type ResourceStatus = typeof ResourceStatus[keyof typeof ResourceStatus];


/**
 * Response codes and memos for account name verification, address verification, card security verification, and transactions.
 */
export interface Response {
    /**
     * Additional information about the transaction, such as velocity control details.  This field is returned in transaction response objects only. It is not returned in address verification or card security verification response objects.
     */
    'additional_information'?: string;
    /**
     * Four-digit response code for address verification, card security code verification, or transactions.  For account name verification, the four digits correspond with assertions that the first, middle, last, and full name of the cardholder on the Marqeta platform match the data provided by the cardholder.  * `0` indicates no validation was performed * `1` indicates the match was unsuccessful (not matched) * `2` indicates the match was partial * `3` indicates the match was exact  For example:  [cols=\"2,3,3,3,3\"] !=== ! Code ! First Name ! Middle Name ! Last Name ! Full Name  ! `0000` ! Not validated ! Not validated ! Not validated ! Not validated  ! `1111` ! Not matched ! Not matched ! Not matched ! Not matched  ! `3333` ! Exact match ! Exact match ! Exact match ! Exact match  ! `1232` ! Not matched ! Partial match ! Exact match ! Partial match !===  For address verification responses, the code is an assertion by the Marqeta platform as to whether its address verification data matches that provided by the cardholder:  [cols=\"2,3,3\"] !=== ! Code ! Address ! Postal Code  ! `0000` ! Match ! Match  ! `0001` ! Match ! Not matched  ! `0100` ! Not matched ! Match  ! `0101` ! Not matched ! Not matched  ! `0200` ! Data not present ! Match  ! `0201` ! Data not present ! Not matched  ! `0002` ! Match ! Data not present  ! `0102` ! Not matched ! Data not present  ! `0303` ! Not validated ! Not validated !===  For card security verification, the code indicates whether the verification check passed and can have these possible values:  * `0000`  Passed * `0001`  Did not pass  For a transaction, the code describes the outcome of the attempted transaction. For the full list of transaction codes, see <</developer-guides/about-transactions#_transaction_response_codes, Transaction response codes>>.
     */
    'code': string;
    /**
     * Additional text that describes the response.
     */
    'memo'?: string;
}
export interface Result {
    'codes'?: Array<ResultCode>;
    'status'?: string;
}
export interface ResultCode {
    'code'?: string;
    'message'?: string;
}
/**
 * Request body that can be used to create a new ACHO transfer for a given payment.
 */
export interface RetryAchPaymentReq {
    'new_acho_ach_transfer_token': string;
    'payment_token': string;
}
/**
 * Contains information on a returned payment.
 */
export interface ReturnedDetails {
    /**
     * Return code for the returned payment. For more, see <</developer-guides/ach-origination#_nacha_ach_return_codes, NACHA ACH return codes>>.
     */
    'return_code': string;
    /**
     * Reason the payment was returned. For more, see <</developer-guides/ach-origination#_nacha_ach_return_codes, NACHA ACH return codes>>.
     */
    'return_reason': string;
}
export interface ReversalModel {
    'amount': number;
    'find_original_window_days'?: number;
    'is_advice'?: boolean;
    'network_fees'?: Array<NetworkFeeModel>;
    'original_transaction_token': string;
    'webhook'?: Webhook;
}
export interface RewardCreateReq {
    /**
     * Amount of the reward.
     */
    'amount': number;
    'currency_code': CurrencyCode;
    /**
     * Description of the reward.
     */
    'description': string;
    /**
     * Allows you to force the creation of a reward on an account.  By default, reward creation is not permitted for accounts with a status of `SUSPENDED` or `TERMINATED` if more than 90 days have passed since the status transition.
     */
    'forced'?: boolean;
    /**
     * Additional information about the reward.
     */
    'note'?: string;
    /**
     * Unique identifier of the reward.
     */
    'token'?: string;
}


export interface RewardResponse {
    /**
     * Unique identifier of the account on which the reward exists.
     */
    'account_token'?: string;
    /**
     * Amount of the reward.
     */
    'amount': number;
    /**
     * Total amount to which a percentage reward method is applied (for example, if a 3% reward is applied to 100, then `100` is the `applied_to_amount` value).  This field is not applicable for a flat fee method.  Returned for auto-cash back reward types only.
     */
    'applied_to_amount'?: number;
    /**
     * Date and time when the reward was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    'currency_code': CurrencyCode;
    /**
     * Description of the reward.
     */
    'description': string;
    'method'?: Method;
    /**
     * Additional information about the reward.
     */
    'note'?: string;
    /**
     * Unique identifier of the reward.  If in the `detail_object`, unique identifier of the detail object.
     */
    'token': string;
    'type': RewardType;
    /**
     * Date and time when the reward was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time': string;
    /**
     * Value of the percentage or flat amount.  Returned for auto-cash back reward types only.
     */
    'value'?: number;
}


/**
 * Type of reward.
 */

export const RewardType = {
    AutoCashBack: 'AUTO_CASH_BACK',
    CashBack: 'CASH_BACK',
    StatementCredit: 'STATEMENT_CREDIT'
} as const;

export type RewardType = typeof RewardType[keyof typeof RewardType];


/**
 * Contains the digital wallet provider\'s risk assessment for provisioning the digital wallet token.
 */
export interface RiskAssessment {
    /**
     * Wallet provider\'s decision as to whether the digital wallet token should be provisioned.
     */
    'score'?: string;
    /**
     * Wallet provider\'s risk assessment version.
     */
    'version'?: string;
}
/**
 * The RiskControl tags that were triggered by the transaction.
 */
export interface RiskcontrolTags {
    /**
     * Name of the rule, as defined in the Real-Time Decisioning dashboard, that was triggered.
     */
    'rule_name'?: string;
    /**
     * Tag name defined in the rule definition in the Real-Time Decisioning dashboard.
     */
    'tag'?: string;
    /**
     * Value associated with the tag.
     */
    'values'?: Array<string>;
}
/**
 * Contains details about a card tokenization push request.
 */
export interface SamsungPushTokenizeRequestData {
    /**
     * Specifies the type of card.
     */
    'card_type'?: string;
    /**
     * Name of the card as displayed in the digital wallet, typically showing the card brand and last four digits of the primary account number (PAN). `Visa 5678`, for example.
     */
    'display_name'?: string;
    /**
     * Encrypted card or cardholder details.
     */
    'extra_provision_payload'?: string;
    /**
     * Last four digits of the primary account number of the physical or virtual card.
     */
    'last_digits'?: string;
    /**
     * Specifies the card network of the physical or virtual card.
     */
    'network'?: string;
    /**
     * Specifies the network that provides the digital wallet token service, as determined by the Samsung Wallet library.
     */
    'token_service_provider'?: string;
}
export interface SelectiveAuth {
    'dmd_location_sensitivity'?: SelectiveAuthDmdLocationSensitivityEnum;
    'enable_regex_search_chain'?: boolean;
    'sa_mode'?: SelectiveAuthSaModeEnum;
}

export const SelectiveAuthDmdLocationSensitivityEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type SelectiveAuthDmdLocationSensitivityEnum = typeof SelectiveAuthDmdLocationSensitivityEnum[keyof typeof SelectiveAuthDmdLocationSensitivityEnum];
export const SelectiveAuthSaModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type SelectiveAuthSaModeEnum = typeof SelectiveAuthSaModeEnum[keyof typeof SelectiveAuthSaModeEnum];

export interface SendingProvisioningDataToGooglePayBackendRequest {
    /**
     * Indicates if the Funding Primary Account Number (FPAN) will be attempted.  * *1* - FPAN save will be attempted. * *0* - FPAN save will not be attempted.
     */
    'card_setting': SendingProvisioningDataToGooglePayBackendRequestCardSettingEnum;
    /**
     * Unique identifier of the card resource.
     */
    'card_token': string;
    /**
     * String provided by Google Wallet that identifies the client session.
     */
    'client_session_id': string;
    /**
     * Google-assigned string that uniquely identifies both the integrator that is initiating the session and the issuer of the card.
     */
    'integrator_id': string;
    /**
     * String provided by Google Wallet that identifies the Android device that will receive the digital wallet token.
     */
    'public_device_id': string;
    /**
     * String provided by Google Wallet that identifies the device-scoped wallet that receives the digital wallet token.
     */
    'public_wallet_id': string;
    /**
     * String provided by Google Wallet that identifies the backend session.
     */
    'server_session_id': string;
    /**
     * Indicates if tokenization will be attempted.  * *1* - Tokenization will be attempted. * *0* - Tokenization will not be attempted.
     */
    'token_setting': SendingProvisioningDataToGooglePayBackendRequestTokenSettingEnum;
}

export const SendingProvisioningDataToGooglePayBackendRequestCardSettingEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SendingProvisioningDataToGooglePayBackendRequestCardSettingEnum = typeof SendingProvisioningDataToGooglePayBackendRequestCardSettingEnum[keyof typeof SendingProvisioningDataToGooglePayBackendRequestCardSettingEnum];
export const SendingProvisioningDataToGooglePayBackendRequestTokenSettingEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type SendingProvisioningDataToGooglePayBackendRequestTokenSettingEnum = typeof SendingProvisioningDataToGooglePayBackendRequestTokenSettingEnum[keyof typeof SendingProvisioningDataToGooglePayBackendRequestTokenSettingEnum];

/**
 * Contains information from the card network about currency conversion at the time of settlement, including the original currency of the transaction, the amount of the transaction in the original currency, and the conversion rate.
 */
export interface SettlementData {
    /**
     * The settled amount.
     */
    'amount'?: number;
    /**
     * Returned when the transaction currency is different from the origination currency.  Conversion rate between the origination currency and the settlement currency.
     */
    'conversion_rate'?: number;
    /**
     * The ISO 4217 code of the currency used in the transaction.
     */
    'currency_code'?: string;
}
export interface Shipping {
    /**
     * 255 char max
     */
    'care_of_line'?: string;
    'method'?: ShippingMethodEnum;
    'recipient_address'?: FulfillmentAddressRequest;
    'return_address'?: FulfillmentAddressRequest;
}

export const ShippingMethodEnum = {
    LocalMail: 'LOCAL_MAIL',
    LocalMailPackage: 'LOCAL_MAIL_PACKAGE',
    Ground: 'GROUND',
    TwoDay: 'TWO_DAY',
    Overnight: 'OVERNIGHT',
    International: 'INTERNATIONAL',
    InternationalPriority: 'INTERNATIONAL_PRIORITY',
    LocalPriority: 'LOCAL_PRIORITY',
    FedexExpedited: 'FEDEX_EXPEDITED',
    FedexRegular: 'FEDEX_REGULAR',
    UpsExpedited: 'UPS_EXPEDITED',
    UpsRegular: 'UPS_REGULAR',
    UspsExpedited: 'USPS_EXPEDITED',
    UspsRegular: 'USPS_REGULAR'
} as const;

export type ShippingMethodEnum = typeof ShippingMethodEnum[keyof typeof ShippingMethodEnum];

/**
 * Specifies shipping details for the order.  This object is returned if it exists in the resource.
 */
export interface ShippingInformationResponse {
    /**
     * Specifies the value of the care of (C/O) line on the mailing carrier.  This field is returned if it exists in the resource.
     */
    'care_of_line'?: string;
    /**
     * Specifies the shipping service.  This field is returned if it exists in the resource.
     */
    'method'?: ShippingInformationResponseMethodEnum;
    'recipient_address'?: FulfillmentAddressResponse;
    'return_address'?: FulfillmentAddressResponse;
}

export const ShippingInformationResponseMethodEnum = {
    LocalMail: 'LOCAL_MAIL',
    LocalMailPackage: 'LOCAL_MAIL_PACKAGE',
    Ground: 'GROUND',
    TwoDay: 'TWO_DAY',
    Overnight: 'OVERNIGHT',
    International: 'INTERNATIONAL',
    InternationalPriority: 'INTERNATIONAL_PRIORITY',
    LocalPriority: 'LOCAL_PRIORITY',
    FedexExpedited: 'FEDEX_EXPEDITED',
    FedexRegular: 'FEDEX_REGULAR',
    UpsExpedited: 'UPS_EXPEDITED',
    UpsRegular: 'UPS_REGULAR',
    UspsExpedited: 'USPS_EXPEDITED',
    UspsRegular: 'USPS_REGULAR'
} as const;

export type ShippingInformationResponseMethodEnum = typeof ShippingInformationResponseMethodEnum[keyof typeof ShippingInformationResponseMethodEnum];

/**
 * Specifies the details of simulate refund transition request .
 */
export interface SimulateRefundTransitionRequest {
    'status': RefundStatus;
    /**
     * Unique identifier for the refund.
     */
    'token': string;
}


export interface SimulationResponseModel {
    'raw_iso8583'?: { [key: string]: object; };
    'transaction'?: TransactionModel;
}
export interface Special {
    'merchant_on_boarding'?: boolean;
}
/**
 * Defines the group of users to which the velocity control applies.
 */
export interface SpendControlAssociation {
    'account_template_token'?: string;
    /**
     * Unique identifier of the card product.  Pass either `card_product_token` or `user_token`, not both.
     */
    'card_product_token'?: string;
    /**
     * Unique identifier of the cardholder.  Pass either `card_product_token` or `user_token`, not both.
     */
    'user_token'?: string;
}
/**
 * Contains tax identification information.
 */
export interface SsnResponseModel {
    /**
     * National Identification Number (NIN).
     */
    'nin'?: string;
    /**
     * Social Insurance Number (SIN).
     */
    'sin'?: string;
    /**
     * United States Social Security Number (SSN) or Individual Taxpayer Identification Number (ITIN).
     */
    'ssn'?: string;
    /**
     * Taxpayer Identification Number (TIN).
     */
    'tin'?: string;
}
/**
 * Collection of statement files.
 */
export interface StatementFile {
    /**
     * Unique identifier of the credit account on which the statement PDF file is generated.
     */
    'account_token'?: string;
    /**
     * Date and time when the statement period ended.
     */
    'closing_date'?: string;
    /**
     * Date and time when the statement period began.
     */
    'opening_date'?: string;
    /**
     * Signed URL to retrieve the statement PDF file.
     */
    'signed_url'?: string;
    /**
     * Unique identifier of the statement summary.
     */
    'statement_summary_token'?: string;
    /**
     * Unique identifier of the statement file.
     */
    'token'?: string;
    /**
     * Type of file.
     */
    'type'?: StatementFileTypeEnum;
}

export const StatementFileTypeEnum = {
    StatementPdf: 'STATEMENT_PDF'
} as const;

export type StatementFileTypeEnum = typeof StatementFileTypeEnum[keyof typeof StatementFileTypeEnum];

/**
 * Returns paginated statement files.
 */
export interface StatementFilePage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * List of statement files.
     */
    'data': Array<StatementFile>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information on statement interest charges.
 */
export interface StatementInterestCharge {
    /**
     * Amount of interest calculated for the billing period.
     */
    'amount'?: number;
    /**
     * Type of APR.
     */
    'apr_type'?: StatementInterestChargeAprTypeEnum;
    /**
     * Annual percentage rate.
     */
    'apr_value'?: number;
    /**
     * Average daily balance used to calculate interest.
     */
    'balance_subject_to_interest_rate'?: number;
    /**
     * Type of balance.  * `PURCHASE` - The balance on purchases.
     */
    'balance_type'?: StatementInterestChargeBalanceTypeEnum;
}

export const StatementInterestChargeAprTypeEnum = {
    GoTo: 'GO_TO'
} as const;

export type StatementInterestChargeAprTypeEnum = typeof StatementInterestChargeAprTypeEnum[keyof typeof StatementInterestChargeAprTypeEnum];
export const StatementInterestChargeBalanceTypeEnum = {
    Purchase: 'PURCHASE'
} as const;

export type StatementInterestChargeBalanceTypeEnum = typeof StatementInterestChargeBalanceTypeEnum[keyof typeof StatementInterestChargeBalanceTypeEnum];

/**
 * Return paginated statement interest charges.
 */
export interface StatementInterestChargesPage {
    /**
     * Unique identifier of the credit account on which the statement interest charge is generated.
     */
    'account_token': string;
    /**
     * Contains one or more interest charges on a statement.
     */
    'data': Array<StatementInterestCharge>;
    /**
     * Unique identifier of the statement summary.
     */
    'statement_summary_token': string;
}
/**
 * Contains information on a statement payment.
 */
export interface StatementPaymentInfo {
    /**
     * Date and time when the statement payment information was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Minimum payment amount for the current statement period, based on the associated credit product settings.
     */
    'minimum_payment_due'?: number;
    /**
     * Balance on the credit account when the statement period ended.
     */
    'new_statement_balance'?: number;
    /**
     * Last day a payment can be made before interest and fees are charged to the account.
     */
    'payment_cutoff_date'?: string;
    /**
     * Payment due date, based on the credit account settings.
     */
    'payment_due_date'?: string;
    /**
     * Unique identifier of the statement summary.
     */
    'statement_summary_token'?: string;
    /**
     * Savings amount if the balance is paid off in three years versus only making minimum payments.
     */
    'three_year_savings'?: number;
    /**
     * Unique identifier of the statement payment.
     */
    'token'?: string;
    /**
     * One or more payoff warnings.
     */
    'warnings'?: Array<StatementPaymentWarning>;
}
/**
 * Contains information on statement payment warnings.
 */
export interface StatementPaymentWarning {
    /**
     * Statement disclosure in the case of negative or no amortization, or no lifetime repayment for the minimum payment warning type.  * `NEGATIVE_OR_NO_AMORTIZATION` - Occurs when the interest amount is higher than the minimum payment; results in the outstanding balance remaining in perpetuity. * `NO_LIFETIME_REPAYMENT` - Occurs when the interest amount is just below the minimum payment; results in the outstanding balance taking longer than a lifetime to pay off.
     */
    'disclosure'?: StatementPaymentWarningDisclosureEnum;
    /**
     * For the minimum payment warning type, this value represents the total amount of interest to pay off the statement balance if only making the minimum payment each month.  For the 3 Year warning type, this value represents the total amount of interest if paying off the statement balance in three years.
     */
    'interest_paid'?: number;
    /**
     * For the minimum payment warning type, this value is 0.  For the 3 Year warning type, this value represents the fixed monthly payment amount required to pay off the statement balance in three years.
     */
    'monthly_payment'?: number;
    /**
     * For the minimum payment warning type, this value represents the number of periods required to pay off the statement balance.  For the 3 Year warning type, this value is 36 (months).
     */
    'pay_off_period'?: number;
    /**
     * Time unit of the pay off period.
     */
    'period_type'?: StatementPaymentWarningPeriodTypeEnum;
    /**
     * For the minimum payment warning type, this value represents the total amount of principal and interest to pay off the statement balance if only making the minimum payment each month.  For the 3 Year warning type, this value represents the total amount of principal and interest if paying off the statement balance in three years.
     */
    'total_paid'?: number;
    /**
     * Type of statement warning.  * `MIN_PAYMENT` - Displays the total estimated payment amount and how long it would take to pay off the statement balance if only making minimum payments. * `3_YEAR` - Displays the monthly payment amount and total estimated payment amount if paying off the statement balance in three years.
     */
    'type'?: StatementPaymentWarningTypeEnum;
}

export const StatementPaymentWarningDisclosureEnum = {
    NegativeOrNoAmortization: 'NEGATIVE_OR_NO_AMORTIZATION',
    NoLifetimeRepayment: 'NO_LIFETIME_REPAYMENT'
} as const;

export type StatementPaymentWarningDisclosureEnum = typeof StatementPaymentWarningDisclosureEnum[keyof typeof StatementPaymentWarningDisclosureEnum];
export const StatementPaymentWarningPeriodTypeEnum = {
    Month: 'MONTH',
    Year: 'YEAR'
} as const;

export type StatementPaymentWarningPeriodTypeEnum = typeof StatementPaymentWarningPeriodTypeEnum[keyof typeof StatementPaymentWarningPeriodTypeEnum];
export const StatementPaymentWarningTypeEnum = {
    MinPayment: 'MIN_PAYMENT',
    _3Year: '3_YEAR'
} as const;

export type StatementPaymentWarningTypeEnum = typeof StatementPaymentWarningTypeEnum[keyof typeof StatementPaymentWarningTypeEnum];

/**
 * Contains information on statement rewards.
 */
export interface StatementReward {
    /**
     * Date and time when the statement reward was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Amount of rewards received in the current billing cycle.
     */
    'current_billing_cycle_reward'?: number;
    /**
     * Amount of rewards received in the previous billing cycle.
     */
    'previous_billing_cycle_reward'?: number;
    /**
     * Unique identifier of the rewards for a specific statement.
     */
    'token'?: string;
}
/**
 * Contains the summary data for an account\'s monthly statement.
 */
export interface StatementSummary {
    /**
     * Unique identifier of the credit account on which the statement summary is generated.
     */
    'account_token': string;
    /**
     * Amount available to spend on the credit account, as of the statement closing date.
     */
    'available_credit': number;
    /**
     * Balance of the credit account when the statement period ended.
     */
    'closing_balance': number;
    /**
     * Date and time when the statement period ended.
     */
    'closing_date': string;
    /**
     * Date and time when the statement summary was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time': string;
    /**
     * Maximum balance the credit account can carry, as of the statement closing date.
     */
    'credit_limit'?: number;
    /**
     * Total amount of credits received during the statement period.
     */
    'credits': number;
    'cycle_type': CycleType;
    /**
     * Number of days in the billing cycle, also known as the statement period.
     */
    'days_in_billing_cycle': number;
    /**
     * Total amount of fees charged during the statement period. Does not include periodic fees.
     */
    'fees': number;
    /**
     * Total amount of interest charged during the statement period.
     */
    'interest': number;
    /**
     * Minimum payment that is due.
     */
    'min_payment_due'?: number;
    /**
     * Balance of the credit account when the statement period began.
     */
    'opening_balance': number;
    /**
     * Date and time when the statement period began.
     */
    'opening_date': string;
    /**
     * Total amount of the payment required to make the account current.
     */
    'past_due_amount': number;
    /**
     * Date when the payment was due for this statement period.
     */
    'payment_due_date'?: string;
    /**
     * Total amount of payments made during the statement period.
     */
    'payments': number;
    /**
     * Date and time when the statement summary was migrated to Marqeta\'s credit platform, in UTC.  The value of this field is `null` if it has not been migrated.
     */
    'program_migration_time'?: string;
    /**
     * Total amount of purchases made during the statement period.
     */
    'purchases': number;
    /**
     * Amount of the minimum payment that remains unpaid for the previous statement period.
     */
    'remaining_min_payment_due'?: number;
    /**
     * Amount of the statement balance that remains unpaid for the previous statement period.
     */
    'remaining_statement_balance'?: number;
    /**
     * Unique identifier of the statement summary.
     */
    'token': string;
}


/**
 * Return filtered transactions.
 */
export interface StatementSummaryPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * One or more statement summaries.
     */
    'data': Array<StatementSummary>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
export interface StoreResponseModel {
    'active'?: boolean;
    'address1': string;
    'address2'?: string;
    'city': string;
    'contact'?: string;
    'contact_email'?: string;
    'country'?: string;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'created_time': string;
    'keyed_auth_cvv_enforced'?: boolean;
    /**
     * yyyy-MM-ddTHH:mm:ssZ
     */
    'last_modified_time': string;
    'latitude'?: number;
    'longitude'?: number;
    'merchant_token': string;
    'mid': string;
    'name': string;
    'network_mid'?: string;
    'partial_approval_capable'?: boolean;
    /**
     * 1 char max
     */
    'partial_auth_flag'?: boolean;
    'phone'?: string;
    'postal_code'?: string;
    'province'?: string;
    'state': string;
    /**
     * The unique identifier of the merchant
     */
    'token'?: string;
    'zip'?: string;
}
export interface StrongCustomerAuthenticationLimits {
    'cavv_authentication_amount_incremental_percentage'?: string;
    'enable_biometric_bypass_sca_contactless'?: boolean;
    'enable_cavv_authentication_amount_validation'?: boolean;
    'enable_issuer_tra_exemption'?: boolean;
    'sca_contactless_cumulative_amount_limit'?: number;
    'sca_contactless_transaction_limit'?: number;
    'sca_contactless_transactions_count_limit'?: number;
    'sca_contactless_transactions_currency'?: string;
    'sca_lvp_cumulative_amount_limit'?: number;
    'sca_lvp_transaction_limit'?: number;
    'sca_lvp_transactions_count_limit'?: number;
    'sca_lvp_transactions_currency'?: string;
    'sca_tra_exemption_amount_limit'?: number;
}
/**
 * Strong Customer Authentication information for contactless transactions
 */
export interface StrongCustomerAuthenticationModel {
    /**
     * Acquirer exemption type for the transaction
     */
    'acquirer_exemption'?: StrongCustomerAuthenticationModelAcquirerExemptionEnum;
    /**
     * Issuer exemption type for the transaction
     */
    'issuer_exemption'?: StrongCustomerAuthenticationModelIssuerExemptionEnum;
}

export const StrongCustomerAuthenticationModelAcquirerExemptionEnum = {
    MerchantInitiatedTransaction: 'MERCHANT_INITIATED_TRANSACTION',
    TransactionRiskAnalysis: 'TRANSACTION_RISK_ANALYSIS',
    RecurringPayment: 'RECURRING_PAYMENT',
    LowValuePayment: 'LOW_VALUE_PAYMENT',
    ScaPerformed: 'SCA_PERFORMED',
    SecureCorporatePayment: 'SECURE_CORPORATE_PAYMENT',
    AuthenticationOutageException: 'AUTHENTICATION_OUTAGE_EXCEPTION'
} as const;

export type StrongCustomerAuthenticationModelAcquirerExemptionEnum = typeof StrongCustomerAuthenticationModelAcquirerExemptionEnum[keyof typeof StrongCustomerAuthenticationModelAcquirerExemptionEnum];
export const StrongCustomerAuthenticationModelIssuerExemptionEnum = {
    LowValuePayment: 'LOW_VALUE_PAYMENT'
} as const;

export type StrongCustomerAuthenticationModelIssuerExemptionEnum = typeof StrongCustomerAuthenticationModelIssuerExemptionEnum[keyof typeof StrongCustomerAuthenticationModelIssuerExemptionEnum];

/**
 * Contains information relevant to creating a substatus.
 */
export interface SubstatusCreateReq {
    /**
     * Additional dynamic attributes related to the substatus. If the substatus is `BANKRUPTCY`, `SCRA` or `POWER_OF_ATTORNEY`, then attributes are required.
     */
    'attributes'?: Array<SubstatusCreateReqAttributesInner>;
    /**
     * List of events related to the substatus.
     */
    'events': Array<SubstatusEvent>;
    /**
     * Unique identifier of the user or account or business for which you want to create a substatus.  * Send a `GET` request to `/credit/accounts` to retrieve existing account tokens. * Send a `GET` request to `/users` to retrieve existing user tokens. * Send a `GET` request to `/business` to retrieve existing business tokens.
     */
    'resource_token': string;
    /**
     * Type of resource to which the substatus can be applied.
     */
    'resource_type': SubstatusCreateReqResourceTypeEnum;
    /**
     * Type of substatus.  * `HARDSHIP`, `FRAUD`, `CEASE_AND_DESIST`, and `OPT_OUT` can only be applied to the `ACCOUNT` resource type. * `MLA`, `SCRA` and `DECEASED` can only be applied to the `USER` resource type. * `POWER_OF_ATTORNEY` and `BANKRUPTCY` can be applied to either the `USER` or the `BUSINESS` resource type.
     */
    'substatus': string;
    /**
     * Unique identifier of the credit substatus.
     */
    'token'?: string;
}

export const SubstatusCreateReqResourceTypeEnum = {
    User: 'USER',
    Account: 'ACCOUNT',
    Business: 'BUSINESS'
} as const;

export type SubstatusCreateReqResourceTypeEnum = typeof SubstatusCreateReqResourceTypeEnum[keyof typeof SubstatusCreateReqResourceTypeEnum];

export interface SubstatusCreateReqAttributesInner {
    /**
     * The name of the attribute.  Marqeta provides several preconfigured attributes, as described in the following list.  * *chapter:* If the substatus is `BANKRUPTCY`, then the chapter attribute is required. `CHAPTER_9` is not applicable to a `USER` resource type. `CHAPTER_13` is not applicable to a `BUSINESS` resource type.  * *military_start_date:* If the substatus is `SCRA`, then the military start date attribute is required. The 6% APR override will be applied from the time and date of account opening until the last statement period of the military start date.  * *end_date:* If the substatus is `POWER_OF_ATTORNEY`, then the end date attribute is applicable. This specifies the date when the power of attorney document is no longer valid.  * *poa_details:* If the substatus is `POWER_OF_ATTORNEY`, then the Power of Attorney details attribute is applicable. This attribute specifies the range of actions that the agent with Power of Attorney is able to perform on the account. By default the range is `UNRESTRICTED`.  * *agent_name:* If the substatus is `POWER_OF_ATTORNEY`, then the agent name is required. This attribute specifies the name of the agent with Power of Attorney for the user.  * *agent_address:* If the substatus is `POWER_OF_ATTORNEY`, then the agent address attribute is required. This attribute specifies the address of the agent with Power of Attorney for the user.  * *agent_id_type:* If the substatus is `POWER_OF_ATTORNEY`, then the agent identification type attribute is required. This specifies the type of the identification method used to identify the agent with Power of Attorney for the user.  * *agent_id_value:* If the substatus is `POWER_OF_ATTORNEY`, then the agent identification value attribute is required. This attribute specifies the value of the identification method used to identify the agent with Power of Attorney for the user.  * *agent_id_expiration_date:* If the substatus is `POWER_OF_ATTORNEY`, then the attribute for the Power of Attorney identification expiration date attribute is required. This attribute specifies the expiration date of the identification method used to identify the agent with Power of Attorney for the user.
     */
    'key'?: string;
    /**
     * The value of the attribute.
     */
    'value'?: string;
}
/**
 * Details of an event related to a substatus.
 */
export interface SubstatusEvent {
    /**
     * The mechanism by which the state of the substatus was applied.  * `ADMIN` - Indicates that the state of the substatus was added through the Marqeta Dashboard. * `API` - Indicates that you initiated an update of the substatus through the Core API. Use this value when creating a substatus. * `FRAUD` - Indicates that either Marqeta or the card network has determined that the account is fraudulent. * `SYSTEM` - Indicates that Marqeta initiated the state of the substatus. For example, Marqeta determined during application decisioning that the applicant is `MLA`.
     */
    'channel'?: SubstatusEventChannelEnum;
    /**
     * Date and time when the state of the substatus went into effect, in UTC. The effective date must be in the past. If no value is set, then the effective date and time will be the current time.
     */
    'effective_date'?: string;
    /**
     * Reason for applying a state designation to the substatus.
     */
    'reason'?: string;
    /**
     * Initial state of the substatus.  * `ACTIVE` - Required if the substatus is `HARDSHIP`, `MLA`, `SCRA`, `DECEASED`, or `POWER_OF_ATTORNEY`. * `BANKRUPTCY_FILED` - Required if the substatus is `BANKRUPTCY`. * `DECEASED_REPORTED` - Required if the substatus is `DECEASED`. * `FRAUD_REPORTED` - Required if the substatus is `FRAUD`.
     */
    'state': SubstatusEventStateEnum;
}

export const SubstatusEventChannelEnum = {
    Admin: 'ADMIN',
    Api: 'API',
    Fraud: 'FRAUD',
    System: 'SYSTEM'
} as const;

export type SubstatusEventChannelEnum = typeof SubstatusEventChannelEnum[keyof typeof SubstatusEventChannelEnum];
export const SubstatusEventStateEnum = {
    Active: 'ACTIVE',
    BankruptcyFiled: 'BANKRUPTCY_FILED',
    DeceasedReported: 'DECEASED_REPORTED',
    FraudReported: 'FRAUD_REPORTED'
} as const;

export type SubstatusEventStateEnum = typeof SubstatusEventStateEnum[keyof typeof SubstatusEventStateEnum];

/**
 * Details of an event related to a substatus.
 */
export interface SubstatusEventResponseDetails {
    /**
     * The channel through which the event occurred.
     */
    'channel': SubstatusEventResponseDetailsChannelEnum;
    /**
     * Creation time of the event.
     */
    'created_time': string;
    /**
     * Effective date of the event, in UTC.
     */
    'effective_date': string;
    /**
     * Reason for the event.
     */
    'reason'?: string;
    /**
     * The state of the event.
     */
    'state': SubstatusEventResponseDetailsStateEnum;
}

export const SubstatusEventResponseDetailsChannelEnum = {
    Admin: 'ADMIN',
    Api: 'API',
    Fraud: 'FRAUD',
    System: 'SYSTEM'
} as const;

export type SubstatusEventResponseDetailsChannelEnum = typeof SubstatusEventResponseDetailsChannelEnum[keyof typeof SubstatusEventResponseDetailsChannelEnum];
export const SubstatusEventResponseDetailsStateEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    DeceasedReported: 'DECEASED_REPORTED',
    DeceasedConfirmed: 'DECEASED_CONFIRMED',
    FraudReported: 'FRAUD_REPORTED',
    FraudConfirmed: 'FRAUD_CONFIRMED',
    BankruptcyFiled: 'BANKRUPTCY_FILED',
    BankruptcyWithdrawn: 'BANKRUPTCY_WITHDRAWN',
    BankruptcyReaffirmed: 'BANKRUPTCY_REAFFIRMED',
    BankruptcyReaffirmRescinded: 'BANKRUPTCY_REAFFIRM_RESCINDED',
    BankruptcyDischarged: 'BANKRUPTCY_DISCHARGED',
    BankruptcyDismissed: 'BANKRUPTCY_DISMISSED',
    BankruptcyFiledInactive: 'BANKRUPTCY_FILED_INACTIVE',
    BankruptcyWithdrawnInactive: 'BANKRUPTCY_WITHDRAWN_INACTIVE',
    BankruptcyReaffirmedInactive: 'BANKRUPTCY_REAFFIRMED_INACTIVE',
    BankruptcyReaffirmRescindedInactive: 'BANKRUPTCY_REAFFIRM_RESCINDED_INACTIVE',
    BankruptcyDischargedInactive: 'BANKRUPTCY_DISCHARGED_INACTIVE',
    BankruptcyDismissedInactive: 'BANKRUPTCY_DISMISSED_INACTIVE'
} as const;

export type SubstatusEventResponseDetailsStateEnum = typeof SubstatusEventResponseDetailsStateEnum[keyof typeof SubstatusEventResponseDetailsStateEnum];

/**
 * Return paginated account and user substatuses.
 */
export interface SubstatusPage {
    /**
     * Number of resources returned.
     */
    'count': number;
    /**
     * Contains one or more substatuses.
     */
    'data': Array<SubstatusResponse>;
    /**
     * Sort order index of the last resource in the returned array.
     */
    'end_index': number;
    /**
     * A value of `true` indicates that more unreturned resources exist.
     */
    'is_more': boolean;
    /**
     * Sort order index of the first resource in the returned array.
     */
    'start_index': number;
}
/**
 * Contains information about the substatus.
 */
export interface SubstatusResponse {
    /**
     * Additional dynamic attributes related to the substatus.  If the substatus is `BANKRUPTCY`, `SCRA`, or `POWER_OF_ATTORNEY`, then attributes are present.
     */
    'attributes'?: Array<SubstatusResponseAttributesInner>;
    /**
     * Date and time when the substatus was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * List of events related to the substatus.
     */
    'events'?: Array<SubstatusEventResponseDetails>;
    /**
     * Denotes whether a substatus is active.
     */
    'is_active': boolean;
    /**
     * Unique identifier of the resource.
     */
    'resource_token': string;
    /**
     * Type of resource to which the substatus is applied.
     */
    'resource_type': SubstatusResponseResourceTypeEnum;
    /**
     * Current state of the substatus.
     */
    'state': SubstatusResponseStateEnum;
    /**
     * Type of substatus.
     */
    'substatus': string;
    /**
     * Unique identifier of the credit substatus.
     */
    'token': string;
    /**
     * Date and time when the substatus was last updated on Marqeta\'s credit platform, in UTC.
     */
    'updated_time'?: string;
}

export const SubstatusResponseResourceTypeEnum = {
    Account: 'ACCOUNT',
    User: 'USER',
    Business: 'BUSINESS'
} as const;

export type SubstatusResponseResourceTypeEnum = typeof SubstatusResponseResourceTypeEnum[keyof typeof SubstatusResponseResourceTypeEnum];
export const SubstatusResponseStateEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    DeceasedReported: 'DECEASED_REPORTED',
    DeceasedConfirmed: 'DECEASED_CONFIRMED',
    FraudReported: 'FRAUD_REPORTED',
    FraudConfirmed: 'FRAUD_CONFIRMED',
    BankruptcyFiled: 'BANKRUPTCY_FILED',
    BankruptcyWithdrawn: 'BANKRUPTCY_WITHDRAWN',
    BankruptcyReaffirmed: 'BANKRUPTCY_REAFFIRMED',
    BankruptcyReaffirmRescinded: 'BANKRUPTCY_REAFFIRM_RESCINDED',
    BankruptcyDischarged: 'BANKRUPTCY_DISCHARGED',
    BankruptcyDismissed: 'BANKRUPTCY_DISMISSED',
    BankruptcyFiledInactive: 'BANKRUPTCY_FILED_INACTIVE',
    BankruptcyWithdrawnInactive: 'BANKRUPTCY_WITHDRAWN_INACTIVE',
    BankruptcyReaffirmedInactive: 'BANKRUPTCY_REAFFIRMED_INACTIVE',
    BankruptcyReaffirmRescindedInactive: 'BANKRUPTCY_REAFFIRM_RESCINDED_INACTIVE',
    BankruptcyDischargedInactive: 'BANKRUPTCY_DISCHARGED_INACTIVE',
    BankruptcyDismissedInactive: 'BANKRUPTCY_DISMISSED_INACTIVE'
} as const;

export type SubstatusResponseStateEnum = typeof SubstatusResponseStateEnum[keyof typeof SubstatusResponseStateEnum];

export interface SubstatusResponseAttributesInner {
    /**
     * The name of the attribute.  Marqeta provides several preconfigured attributes, as described in the following list.  * *chapter:* If the substatus is `BANKRUPTCY`, then this value defines the chapter.  * *military_start_date:* If the substatus is `SCRA`, then this value defines the military start date.  * *end_date:* If the substatus is `POWER_OF_ATTORNEY`, then the end date attribute is present. This specifies the date when the power of attorney document is no longer valid.  * *poa_details:* If the substatus is `POWER_OF_ATTORNEY`, then the Power of Attorney details attribute is applicable. This attribute specifies the range of actions that the agent with Power of Attorney is able to perform on the account. By default the range is `UNRESTRICTED`.  * *agent_name:* If the substatus is `POWER_OF_ATTORNEY`, then the agent name is present. This attribute specifies the name of the agent with Power of Attorney for the user.  * *agent_address:* If the substatus is `POWER_OF_ATTORNEY`, then the agent address attribute is present. This attribute specifies the address of the agent with Power of Attorney for the user.  * *agent_id_type:* If the substatus is `POWER_OF_ATTORNEY`, then the agent identification type attribute is present. This specifies the type of the identification method used to identify the agent with Power of Attorney for the user.  * *agent_id_value:* If the substatus is `POWER_OF_ATTORNEY`, then the agent identification value attribute is present. This attribute specifies the value of the identification method used to identify the agent with Power of Attorney for the user.  * *agent_id_expiration_date:* If the substatus is `POWER_OF_ATTORNEY`, then the attribute for the Power of Attorney identification expiration date attribute is present. This attribute specifies the expiration date of the identification method used to identify the agent with Power of Attorney for the user.
     */
    'key'?: string;
    /**
     * The value of the attribute.
     */
    'value'?: string;
}
/**
 * Contains information relevant to deactivating a substatus.
 */
export interface SubstatusUpdateReq {
    /**
     * The mechanism by which a state designation was applied to a substatus. If no value is set, then it defaults to `API`.  * `ADMIN` - Indicates that the state of the substatus was added through the Marqeta Dashboard. * `API` - Indicates that you initiated the update of the substatus through the Core API. Use this value when creating a card transition with an API `POST` request. * `FRAUD` - Indicates that either Marqeta or the card network has determined that the account is fraudulent. * `SYSTEM` - Indicates that the substatus update was initiated by Marqeta. For example, Marqeta determined during application decisioning that the applicant is `MLA`.
     */
    'channel'?: SubstatusUpdateReqChannelEnum;
    /**
     * Date and time when the state of the substatus is effective, in UTC.
     */
    'effective_date'?: string;
    /**
     * Reason for applying the state to the substatus.
     */
    'reason'?: string;
    /**
     * New state of the substatus.  * `INACTIVE` is a valid state for substatuses `HARDSHIP`, `FRAUD`, `MLA`, `SCRA`, `DECEASED`, and `POWER_OF_ATTORNEY`. * `DECEASED_CONFIRMED` is a valid state for substatus `DECEASED`. * `FRAUD_CONFIRMED` is a valid state for substatus `FRAUD`. * `BANKRUPTCY_WITHDRAWN`, `BANKRUPTCY_REAFFIRMED`, `BANKRUPTCY_REAFFIRM_RESCINDED`, `BANKRUPTCY_DISCHARGED`, `BANKRUPTCY_DISMISSED`, `BANKRUPTCY_FILED_INACTIVE`, `BANKRUPTCY_WITHDRAWN_INACTIVE`, `BANKRUPTCY_REAFFIRMED_INACTIVE`, `BANKRUPTCY_REAFFIRM_RESCINDED_INACTIVE`, `BANKRUPTCY_DISCHARGED_INACTIVE`, and `BANKRUPTCY_DISMISSED_INACTIVE` states are applicable to `BANKRUPTCY`.
     */
    'state': SubstatusUpdateReqStateEnum;
}

export const SubstatusUpdateReqChannelEnum = {
    Admin: 'ADMIN',
    Api: 'API',
    Fraud: 'FRAUD',
    System: 'SYSTEM'
} as const;

export type SubstatusUpdateReqChannelEnum = typeof SubstatusUpdateReqChannelEnum[keyof typeof SubstatusUpdateReqChannelEnum];
export const SubstatusUpdateReqStateEnum = {
    Inactive: 'INACTIVE',
    BankruptcyWithdrawn: 'BANKRUPTCY_WITHDRAWN',
    BankruptcyReaffirmed: 'BANKRUPTCY_REAFFIRMED',
    BankruptcyReaffirmRescinded: 'BANKRUPTCY_REAFFIRM_RESCINDED',
    BankruptcyDischarged: 'BANKRUPTCY_DISCHARGED',
    BankruptcyDismissed: 'BANKRUPTCY_DISMISSED',
    BankruptcyFiledInactive: 'BANKRUPTCY_FILED_INACTIVE',
    BankruptcyWithdrawnInactive: 'BANKRUPTCY_WITHDRAWN_INACTIVE',
    BankruptcyReaffirmedInactive: 'BANKRUPTCY_REAFFIRMED_INACTIVE',
    BankruptcyReaffirmRescindedInactive: 'BANKRUPTCY_REAFFIRM_RESCINDED_INACTIVE',
    BankruptcyDischargedInactive: 'BANKRUPTCY_DISCHARGED_INACTIVE',
    BankruptcyDismissedInactive: 'BANKRUPTCY_DISMISSED_INACTIVE',
    DeceasedConfirmed: 'DECEASED_CONFIRMED',
    FraudConfirmed: 'FRAUD_CONFIRMED'
} as const;

export type SubstatusUpdateReqStateEnum = typeof SubstatusUpdateReqStateEnum[keyof typeof SubstatusUpdateReqStateEnum];

/**
 * Successful response for operation
 */
export interface Success {
    /**
     * Denotes whether the operation is successful or not
     */
    'success'?: boolean;
}
export interface SyncStatementAssetReq {
    /**
     * Unique identifier of the statement asset in Credit File Template.
     */
    'asset_token': string;
    /**
     * Unique identifier of the program.
     */
    'short_code': string;
}
export interface Tag {
    /**
     * Name of the tag.
     */
    'name'?: string;
    /**
     * Value of the tag.
     */
    'value'?: string;
}
/**
 * Contains information about the point of sale, including details on how the card was presented.  Returned if provided by the card network, and the request uses Transaction Model v1 of the Marqeta Core API. Not returned for Transaction Model v2 requests.
 */
export interface TerminalModel {
    /**
     * Indicates whether the card was present during the transaction.
     */
    'card_presence'?: string;
    /**
     * Indicates whether the cardholder was present during the transaction.
     */
    'cardholder_presence'?: string;
    /**
     * Indicates whether the card acceptor or terminal supports partial-approval transactions.
     */
    'partial_approval_capable'?: string;
    /**
     * Indicates whether the cardholder entered a PIN during the transaction.
     */
    'pin_present'?: string;
    /**
     * Indicates a higher-risk operation, such as a quasi-cash or cryptocurrency transaction.  These transactions typically involve non-financial institutions.
     */
    'special_condition_indicator'?: TerminalModelSpecialConditionIndicatorEnum;
    /**
     * Card acceptor or terminal identification number.
     */
    'tid'?: string;
    /**
     * Specifies the initiator of the transaction.
     */
    'transaction_initiated_by'?: TerminalModelTransactionInitiatedByEnum;
    /**
     * Specifies the category of a point-of-sale transaction.
     */
    'transaction_initiated_category'?: TerminalModelTransactionInitiatedCategoryEnum;
}

export const TerminalModelSpecialConditionIndicatorEnum = {
    Unspecified: 'UNSPECIFIED',
    CryptocurrencyPurchase: 'CRYPTOCURRENCY_PURCHASE',
    QuasiCash: 'QUASI_CASH',
    DebtPayment: 'DEBT_PAYMENT',
    CentralBankDigitalCurrencyPurchase: 'CENTRAL_BANK_DIGITAL_CURRENCY_PURCHASE',
    StablecoinPurchase: 'STABLECOIN_PURCHASE',
    BlockchainNativeTokenPurchase: 'BLOCKCHAIN_NATIVE_TOKEN_PURCHASE',
    NonFungibleTokenPurchase: 'NON_FUNGIBLE_TOKEN_PURCHASE'
} as const;

export type TerminalModelSpecialConditionIndicatorEnum = typeof TerminalModelSpecialConditionIndicatorEnum[keyof typeof TerminalModelSpecialConditionIndicatorEnum];
export const TerminalModelTransactionInitiatedByEnum = {
    Consumer: 'CONSUMER',
    Merchant: 'MERCHANT',
    Unknown: 'UNKNOWN',
    Marqeta: 'MARQETA',
    Network: 'NETWORK'
} as const;

export type TerminalModelTransactionInitiatedByEnum = typeof TerminalModelTransactionInitiatedByEnum[keyof typeof TerminalModelTransactionInitiatedByEnum];
export const TerminalModelTransactionInitiatedCategoryEnum = {
    CardOnFile: 'CARD_ON_FILE',
    RecurringVarAmtFixedFreq: 'RECURRING_VAR_AMT_FIXED_FREQ',
    RecurringPayment: 'RECURRING_PAYMENT',
    InstallmentPayment: 'INSTALLMENT_PAYMENT',
    UnscheduledPayment: 'UNSCHEDULED_PAYMENT',
    PartialShipment: 'PARTIAL_SHIPMENT',
    DelayedPayment: 'DELAYED_PAYMENT',
    NoShow: 'NO_SHOW',
    Resubmission: 'RESUBMISSION',
    DeferredBilling: 'DEFERRED_BILLING',
    AccountInquiry: 'ACCOUNT_INQUIRY',
    IncrementalAuthorization: 'INCREMENTAL_AUTHORIZATION',
    Reauthorization: 'REAUTHORIZATION'
} as const;

export type TerminalModelTransactionInitiatedCategoryEnum = typeof TerminalModelTransactionInitiatedCategoryEnum[keyof typeof TerminalModelTransactionInitiatedCategoryEnum];

/**
 * Specifies personalized text that appears on the card.
 */
export interface Text {
    'name_line_1': TextValue;
    'name_line_2'?: TextValue;
    'name_line_3'?: TextValue;
}
export interface TextValue {
    /**
     * Line of personalized text printed on the card.
     */
    'value'?: string;
}
export interface TokenRequest {
    'account_number': string;
    /**
     * required if \'user_token\' is null
     */
    'business_token'?: string;
    'cvv_number': string;
    'exp_date': string;
    'is_default_account'?: boolean;
    'postal_code'?: string;
    'token'?: string;
    /**
     * required if \'business_token\' is null
     */
    'user_token'?: string;
    'zip'?: string;
}
/**
 * Contains information held and provided by the token service provider (card network).
 */
export interface TokenServiceProvider {
    /**
     * Unique value representing a tokenization request (Mastercard only).
     */
    'correlation_id'?: string;
    /**
     * Unique identifier of the digital wallet token primary account number (PAN) within the card network.
     */
    'pan_reference_id': string;
    /**
     * _(Mastercard only)_ Represents the confidence level in the digital wallet token.
     */
    'token_assurance_level'?: string;
    /**
     * Digital wallet\'s decision as to whether the digital wallet token should be provisioned.
     */
    'token_eligibility_decision'?: string;
    /**
     * Expiration date of the digital wallet token.
     */
    'token_expiration'?: string;
    /**
     * Primary account number (PAN) of the digital wallet token.
     */
    'token_pan'?: string;
    /**
     * Unique identifier of the digital wallet token within the card network.
     */
    'token_reference_id'?: string;
    /**
     * Unique numerical identifier of the token requestor within the card network. These ID numbers map to `token_requestor_name` field values as follows:  *Mastercard*  * 50110030273  `APPLE_PAY` * 50120834693  `ANDROID_PAY` * 50139059239  `SAMSUNG_PAY`  *Visa*  * 40010030273  `APPLE_PAY` * 40010075001  `ANDROID_PAY` * 40010043095  `SAMSUNG_PAY` * 40010075196  `MICROSOFT_PAY` * 40010075338  `VISA_CHECKOUT` * 40010075449  `FACEBOOK` * 40010075839  `NETFLIX` * 40010077056  `FITBIT_PAY` * 40010069887  `GARMIN_PAY`
     */
    'token_requestor_id'?: string;
    /**
     * Name of the token requestor within the card network.  *NOTE:* The list of example values for this field is maintained by the card networks and is subject to change.
     */
    'token_requestor_name'?: string;
    /**
     * Token score assigned by the digital wallet.
     */
    'token_score'?: string;
    'token_service_provider_id'?: string;
    /**
     * Type of the digital wallet token.
     */
    'token_type'?: string;
}
export interface TokenUpdateRequest {
    'active'?: boolean;
    'exp_date': string;
    'is_default_account'?: boolean;
}
/**
 * Contains information about the merchant.
 */
export interface TransactionCardAcceptor {
    /**
     * Card acceptor\'s address. May be returned if the request uses Transaction Model v1 of the Marqeta Core API. Not returned for Transaction Model v2 requests.
     */
    'address'?: string;
    /**
     * Business registration identifier, as provided by the Visa card network.
     */
    'business_registration_id'?: string;
    /**
     * Business registration identifier type, as provided by the Visa card network.
     */
    'business_registration_id_type'?: TransactionCardAcceptorBusinessRegistrationIdTypeEnum;
    /**
     * Card acceptor\'s city.
     */
    'city'?: string;
    /**
     * Card acceptor\'s country code. May be returned if the request uses Transaction Model v2 of the Marqeta Core API. Not returned for Transaction Model v1 requests.
     */
    'country_code'?: string;
    /**
     * The merchant\'s country of origin.  A merchant\'s country of origin can be different from the country in which the merchant is located. For example, embassies are physically located in countries that are not their country of origin: a Mexican embassy might be physically located in Singapore, but the country of origin is Mexico.  This field is included when the cardholder conducts a transaction with a government-controlled merchant using a Marqeta-issued card.
     */
    'country_of_origin'?: string;
    'customer_service_phone'?: string;
    /**
     * Geographic coordinates of the card acceptor in `latitudeE7,longitudeE7` format.
     */
    'geographic_coordinates'?: string;
    'independent_sales_organization_id'?: string;
    /**
     * Legal business name, as provided by the Visa card network.
     */
    'legal_business_name'?: string;
    /**
     * Merchant category code (MCC).
     */
    'mcc'?: string;
    /**
     * An array of `mcc_groups`.
     */
    'mcc_groups'?: Array<string>;
    'merchant_tax_id'?: string;
    /**
     * The VAT registration identifier of the merchant.
     */
    'merchant_vat_registration_id'?: string;
    /**
     * The merchant identifier.
     */
    'mid'?: string;
    /**
     * Card acceptor\'s name.
     */
    'name'?: string;
    /**
     * Identifier assigned by the card network.
     */
    'network_assigned_id'?: string;
    /**
     * The merchant identifier on the card network.
     */
    'network_mid'?: string;
    'payment_facilitator_id'?: string;
    /**
     * The name of the payment facilitator, including the sub-merchant identifier, of an original credit transaction. This field is returned when a payment facilitator participates in the transaction.
     */
    'payment_facilitator_name'?: string;
    'phone'?: string;
    'poi'?: TerminalModel;
    /**
     * Card acceptor\'s postal code.
     */
    'postal_code'?: string;
    /**
     * Geographic coordinates of the service provider in `latitudeE7,longitudeE7` format.
     */
    'service_geographic_coordinates'?: string;
    'special_merchant_id'?: string;
    /**
     * State, provincial, territorial, or federal abbreviation (`CA` for California or `CAN` for Canada, for example).  For the complete list, see <</core-api/kyc-verification#_valid_state_provincial_territorial_and_federal_abbreviations, Valid state, provincial, territorial, and federal abbreviations>>.  *Note*: Non-US merchants may return more than 2 char for this field.
     */
    'state'?: string;
    'sub_merchant_id'?: string;
    /**
     * The name of the transfer service provider of a money transfer original credit transaction. This field is included when a transfer service provider participates in the transaction.
     */
    'transfer_service_provider_name'?: string;
    'url'?: string;
}

export const TransactionCardAcceptorBusinessRegistrationIdTypeEnum = {
    Unspecified: 'unspecified',
    TaxRegistrationIdentification: 'tax_registration_identification',
    NationalIdentification: 'national_identification',
    CompanyRegistrationIdentification: 'company_registration_identification',
    Passport: 'passport',
    DefaultValue: 'default_value'
} as const;

export type TransactionCardAcceptorBusinessRegistrationIdTypeEnum = typeof TransactionCardAcceptorBusinessRegistrationIdTypeEnum[keyof typeof TransactionCardAcceptorBusinessRegistrationIdTypeEnum];

export interface TransactionControls {
    /**
     * 50 char max (default = accept_us_only)
     */
    'accepted_countries_token'?: string;
    'address_verification'?: AvsControls;
    'allow_chip_fallback'?: boolean;
    'allow_first_pin_set_via_financial_transaction'?: boolean;
    'allow_gpa_auth'?: boolean;
    'allow_mcc_group_authorization_controls'?: boolean;
    'allow_network_load'?: boolean;
    'allow_network_load_card_activation'?: boolean;
    'allow_quasi_cash'?: boolean;
    'always_require_icc'?: boolean;
    'always_require_pin'?: boolean;
    'enable_credit_service'?: boolean;
    'enable_partial_auth_approval'?: boolean;
    'ignore_card_suspended_state'?: boolean;
    'notification_language'?: string;
    /**
     * 36 char max
     */
    'quasi_cash_exempt_merchant_group_token'?: string;
    'quasi_cash_exempt_mids'?: string;
    'require_card_not_present_card_security_code'?: boolean;
    'strong_customer_authentication_limits'?: StrongCustomerAuthenticationLimits;
}
/**
 * Contains information about the device used in the transaction to enhance the risk decisioning process. Use this data to improve fraud prevention and dispute resolution.
 */
export interface TransactionDevice {
    /**
     * Unique identifier of the data component bound to the credential.
     */
    'binding_id'?: string;
    /**
     * IP address of the device. The presence of the IP address helps determine if the transaction was initiated from an unusual network, helping establish a pattern of safe device usage that further confirms the authenticity of the consumer who initiated the transaction.
     */
    'ip_address'?: string;
    /**
     * Geographic coordinates of the device. Contains the latitude and longitude of the device used when the cardholder was authenticated during checkout. This field helps to determine if the transaction was initiated from an unexpected location.
     */
    'location'?: string;
    /**
     * Telephone number of the device. Contains the phone number that was used to authenticate the consumer during checkout, or the consumer\'s preferred phone number. The presence of the phone number helps establish the consumer\'s authenticity when matching the phone number provided during checkout to a list of known phone numbers for the consumer.
     */
    'phone_number'?: string;
}
/**
 * Contains merchant-provided metadata related to the transaction, including details about lodging- and transit-related purchases.  May be returned if the request uses Transaction Model v2 of the Marqeta Core API. Not returned for Transaction Model v1 requests.
 */
export interface TransactionMetadata {
    'airline'?: Airline;
    /**
     * Number of days the pre-authorization is in effect.
     */
    'authorization_life_cycle'?: number;
    /**
     * Whether the transaction is cross-border, i.e., when the merchant and the cardholder are located in two different countries.
     */
    'cross_border_transaction'?: boolean;
    /**
     * Indicates an offline authorization made during an interruption of card network connectivity, such as a purchase on a flight.
     */
    'is_deferred_authorization'?: boolean;
    /**
     * Whether the transaction is a lodging or vehicle rental.
     */
    'is_lodging_auto_rental'?: boolean;
    /**
     * Date and time when the lodging check-in or vehicle rental began.
     */
    'lodging_auto_rental_start_date'?: string;
    /**
     * Indicates a credit or debit adjustment in a clearing transaction.
     */
    'memo'?: TransactionMetadataMemoEnum;
    /**
     * Indicates the type of mail or telephone order transaction.
     */
    'moto_indicator'?: TransactionMetadataMotoIndicatorEnum;
    'one_leg_out'?: boolean;
    /**
     * Channel from which the transaction was originated.
     */
    'payment_channel'?: TransactionMetadataPaymentChannelEnum;
    'special_purchase_id'?: string;
    /**
     * Type of product or service being purchased, if provided by the merchant.
     */
    'transaction_category'?: TransactionMetadataTransactionCategoryEnum;
    'transit'?: Transit;
}

export const TransactionMetadataMemoEnum = {
    CreditAdjustment: 'CREDIT_ADJUSTMENT',
    DebitAdjustment: 'DEBIT_ADJUSTMENT'
} as const;

export type TransactionMetadataMemoEnum = typeof TransactionMetadataMemoEnum[keyof typeof TransactionMetadataMemoEnum];
export const TransactionMetadataMotoIndicatorEnum = {
    Unknown: 'UNKNOWN',
    Manual: 'MANUAL',
    Recurring: 'RECURRING',
    Installment: 'INSTALLMENT',
    Others: 'OTHERS'
} as const;

export type TransactionMetadataMotoIndicatorEnum = typeof TransactionMetadataMotoIndicatorEnum[keyof typeof TransactionMetadataMotoIndicatorEnum];
export const TransactionMetadataPaymentChannelEnum = {
    Other: 'OTHER',
    Atm: 'ATM',
    Ecommerce: 'ECOMMERCE',
    Mail: 'MAIL',
    Phone: 'PHONE',
    Moto: 'MOTO'
} as const;

export type TransactionMetadataPaymentChannelEnum = typeof TransactionMetadataPaymentChannelEnum[keyof typeof TransactionMetadataPaymentChannelEnum];
export const TransactionMetadataTransactionCategoryEnum = {
    RetailSale: 'RETAIL_SALE',
    BillPay: 'BILL_PAY',
    Hotel: 'HOTEL',
    HealthCare: 'HEALTH_CARE',
    Restaurant: 'RESTAURANT',
    AutoRental: 'AUTO_RENTAL',
    Airline: 'AIRLINE',
    Payment: 'PAYMENT',
    HospitalizationCollege: 'HOSPITALIZATION_COLLEGE',
    PhoneMailEcommerce: 'PHONE_MAIL_ECOMMERCE',
    Atm: 'ATM',
    Transit: 'TRANSIT',
    ExtendedAuthorization: 'EXTENDED_AUTHORIZATION'
} as const;

export type TransactionMetadataTransactionCategoryEnum = typeof TransactionMetadataTransactionCategoryEnum[keyof typeof TransactionMetadataTransactionCategoryEnum];

/**
 * Transactions are represented by the `transaction` object. The Marqeta platform creates a separate `transaction` object for each transaction message received from the card network. The attributes of a given `transaction` object depend on the transaction type.  This section documents all fields that might be included in a `transaction` object.  // This schema is used by InfoDev to generate API reference documentation. // File location in GitHub is: openapi/transactions/schemas/transaction_model.yaml
 */
export interface TransactionModel {
    'account_funding'?: AccountFunding;
    'account_name_verification'?: AccountNameVerificationModel;
    'account_owner'?: AccountOwnerModel;
    'accounts'?: Array<AccountBalance>;
    'acquirer'?: Acquirer;
    /**
     * Indicates the amount of the acquirer fee. Account holders are sometimes charged an acquirer fee for card use at ATMs, fuel dispensers, and so on.
     */
    'acquirer_fee_amount'?: number;
    /**
     * Acquirer-assigned unique identifier of the transaction. Useful for settlement and reconciliation.
     */
    'acquirer_reference_data'?: string;
    /**
     * Acquirer-assigned unique identifier of the transaction. Useful for settlement and reconciliation.
     */
    'acquirer_reference_id'?: string;
    /**
     * Unique identifier of the user who conducted the transaction. This might be a child user configured to share its parent\'s account balance.
     */
    'acting_user_token': string;
    'address_verification'?: AddressVerificationModel;
    /**
     * Extended stand-in processing (STIP) reason code, as provided by the card network.
     */
    'advice_reason_code'?: string;
    /**
     * Extended stand-in processing (STIP) reason details, as provided by the card network.
     */
    'advice_reason_details'?: string;
    /**
     * Amount of the transaction.
     */
    'amount': number;
    /**
     * Amount of original authorization to be released. This field appears in final clearing transactions where the clearing amount is lower than the authorization amount.
     */
    'amount_to_be_released'?: number;
    /**
     * Anticipated amount of the transaction, as provided by the card network. This field applies to anticipated amount verification transactions (AAVTs).
     */
    'anticipated_amount'?: number;
    /**
     * Unique identifier assigned to an authorization, printed on the receipt at point of sale.
     */
    'approval_code'?: string;
    'atc_information'?: ATCInformationModel;
    'authorization_expiration'?: string;
    'auto_reload'?: AutoReloadModel;
    'bank_transfer_token'?: string;
    /**
     * The batch number of the transaction.
     */
    'batch_number'?: string;
    'billpay'?: BillPayResponse;
    'business'?: BusinessMetadata;
    /**
     * Unique identifier of the business that owns the account that funded the transaction.
     */
    'business_token'?: string;
    'card'?: CardResponse;
    'card_acceptor'?: TransactionCardAcceptor;
    'card_holder_model'?: UserCardHolderResponse;
    /**
     * Unique identifier of the card product.
     */
    'card_product_token'?: string;
    'card_security_code_verification'?: CardSecurityCodeVerification;
    /**
     * Unique identifier of the card. Useful when a single account holder has multiple cards.
     */
    'card_token'?: string;
    'cardholder_authentication_data'?: CardholderAuthenticationData;
    /**
     * Amount of cash back requested by the cardholder during the transaction. Included in the total transaction amount.
     */
    'cash_back_amount'?: number;
    'cashloads_direct'?: CashloadsResponseModel;
    'chargeback'?: ChargebackResponse;
    /**
     * A sequence number that identifies a specific clearing message among multiple clearing messages for an authorization.
     */
    'clearing_record_sequence_number'?: string;
    /**
     * Date and time when the Marqeta platform created the transaction entry, in UTC format. For example, when Marqeta processed the clearing record for a refund.
     */
    'created_time'?: string;
    /**
     * Currency type of the transaction.
     */
    'currency_code'?: string;
    'currency_conversion'?: CurrencyConversion;
    'deferred_settlement_days'?: string;
    /**
     * Visa Digital Commerce Authentication Program (VDCAP) indicator for U.S. domestic card-not-present transactions. Indicates the presence of key data elements, along with the eligible method used to share authentication data.  * *02:* Visa Secure * *03:* Visa data only * *04:* Visa Payment Passkey with Visa Secure * *05:* Visa Payment Passkey with Visa Token Service * *06:* IDX 3rd party * *07:* Visa Token Service data only
     */
    'digital_commerce_authentication_indicator'?: string;
    'digital_wallet_token'?: DigitalWalletToken;
    'digital_wallet_token_transaction_service_provider_info'?: DigitalServiceProvider;
    'direct_deposit'?: DepositDepositResponse;
    'dispute'?: DisputeModel;
    /**
     * Duration of the transaction on Marqeta\'s servers, in milliseconds.
     */
    'duration'?: number;
    /**
     * The enhanced commercial card data token for the transaction.
     */
    'enhanced_data_token'?: string;
    /**
     * Indicates an estimated authorization. An estimated authorization allows the merchant to obtain an approval for funds before the cardholder has finalized exactly what goods or services will be purchased.
     */
    'estimated_authorization'?: boolean;
    'fee'?: Fee;
    'fee_transfer'?: FeeTransferResponse;
    /**
     * List of fees associated with the transaction.  This array is returned if it exists in the resource.
     */
    'fees'?: Array<NetworkFeeModel>;
    'flex'?: Flex;
    'fraud'?: FraudView;
    /**
     * Specifies the funding account type.
     */
    'from_account'?: string;
    'from_account_token'?: string;
    'gpa'?: CardholderBalance;
    'gpa_order'?: GpaResponse;
    'gpa_order_unload'?: GpaReturns;
    /**
     * Sequential identifier of the transaction.
     */
    'identifier'?: string;
    /**
     * An array of incremental authorization transaction tokens.
     */
    'incremental_authorization_transaction_tokens'?: Array<string>;
    'installment_data'?: InstallmentData;
    'interchange_rate_descriptor'?: string;
    /**
     * Indicates the final clearing event for an authorization. If the final cleared amount is lower than the authorized amount, you must release the hold on the funds per the value in the `amount_to_be_released` field.
     */
    'is_final_clearing'?: boolean;
    /**
     * Indicates if the transaction is a pre-authorization.
     */
    'is_preauthorization'?: boolean;
    /**
     * The international service assessment indicator indicates if an ISA fee is applicable to the transaction.
     */
    'isaIndicator'?: TransactionModelIsaIndicatorEnum;
    /**
     * The amount of interchange charged by the card issuer.
     */
    'issuer_interchange_amount'?: number;
    /**
     * Unique identifier of the Marqeta platform server that received the transaction from the card network.
     */
    'issuer_payment_node'?: string;
    /**
     * Date and time when the Marqeta platform received the transaction from the card network, in UTC.
     */
    'issuer_received_time'?: string;
    /**
     * Indicates the local time of the transaction at the card acceptor\'s location. You can use this field to determine the correct time of the transaction when filing a dispute.
     */
    'local_transaction_date'?: string;
    'merchant'?: MerchantResponseModel;
    /**
     * Unique network identification value formed by combining the 6- to 9-character Mastercard Banknet Reference Number and the 4-digit settlement date for recurring payments and other merchant-initiated transactions.
     */
    'merchant_initiated_original_trace_id'?: string;
    /**
     * If an authorization has multiple clearing transactions, this field displays their total number. For example, if an authorization has four clearing transactions, the sequence count is `04`.
     */
    'multi_clearing_sequence_count'?: string;
    /**
     * If an authorization has multiple clearing transactions, this field displays the sequence number for the clearing transaction. For example, if this is the second clearing transaction of four, the sequence number is `02`.
     */
    'multi_clearing_sequence_number'?: string;
    'national_net_cpd_of_original'?: string;
    /**
     * Indicates which card network was used to complete the transactions.
     */
    'network'?: string;
    'network_metadata'?: NetworkMetadata;
    /**
     * Network-assigned unique identifier of the transaction. Useful for settlement and reconciliation.
     */
    'network_reference_id'?: string;
    /**
     * Transaction identifier, as provided by the card network. This identifier connects the original transaction to all subsequent activities throughout the transaction lifecycle.
     */
    'network_transaction_lifecycle_id'?: string;
    'original_credit'?: OriginalCredit;
    /**
     * Unique identifier of the original transaction in a series of related transactions.
     */
    'original_transaction_token'?: string;
    'payment_facilitator'?: PaymentFacilitatorModel;
    'peer_transfer'?: PeerTransferResponse;
    /**
     * Indicates whether the transaction is credit or debit.
     */
    'polarity'?: TransactionModelPolarityEnum;
    'pos'?: Pos;
    /**
     * Returned for final transaction types.  Unique identifier of the preceding related transaction. Useful for identifying the transaction that preceded the current one.  For example, `authorization`, a temporary transaction type, precedes and is completed by `authorization.clearing`, a final transaction type. In this case, the `authorization` token is returned with this field. For which transaction types are temporary or final, see <</core-api/event-types#_transaction_events, Transaction events in Event Types>>.
     */
    'preceding_related_transaction_token'?: string;
    'preceding_transaction'?: PrecedingTransaction;
    'program'?: Program;
    'program_reserve_deposit_info'?: ProgramReserveTransactionResponse;
    'program_transfer'?: ProgramTransferResponse;
    'real_time_fee_group'?: RealTimeFeeGroup;
    'relay_resistance_protocol_result'?: string;
    /**
     * Merchant-requested amount, including any fees.
     */
    'request_amount'?: number;
    'response'?: Response;
    /**
     * Date and time when funds were moved for a transaction, in UTC. For example, in the case of a refund, when funds were credited to the cardholder.
     */
    'settlement_date'?: string;
    /**
     * Indicates the settlement service used for the transaction.
     */
    'settlement_indicator'?: string;
    /**
     * Indicates which party approved a transaction: the card network using stand-in processing, or Marqeta using Commando Mode. Returned only when a transaction is approved.
     */
    'standin_approved_by'?: string;
    /**
     * Indicates which party approved a transaction: the card network using stand-in processing, or Marqeta using Commando Mode.
     */
    'standin_by'?: string;
    /**
     * Indicates why the card network handled a transaction requiring stand-in processing.
     */
    'standin_reason'?: string;
    /**
     * Current state of the transaction. For more information about the `state` field, see <</developer-guides/about-transactions#_the_transaction_lifecycle, The transaction lifecycle>>.
     */
    'state': TransactionModelStateEnum;
    'store'?: StoreResponseModel;
    'strong_customer_authentication'?: StrongCustomerAuthenticationModel;
    /**
     * Indicates which subnetwork was used to complete the transaction. Possible values include the following:  * *VISANET*  Used for VisaNet signature-based transactions. * *VISANETDEBIT*  Used for VisaNet Debit PIN-based transaction. * *VISAINTERLINK*  Used for Visa Interlink PIN-based transactions. * *VISAPLUS*  Used for ATM withdrawals on Visa. * *MAESTRO*  Used for PIN-based transactions on Mastercard. * *CIRRUS*  Used for ATM withdrawals on Mastercard. * *MASTERCARDDEBIT*  Used for signature-based transactions on Mastercard. * *GATEWAY_JIT*  Used for Gateway JIT Funding transactions. * *MANAGED_JIT*  Used for Managed JIT Funding transactions or for transactions that occur while Commando Mode is enabled.
     */
    'subnetwork'?: string;
    /**
     * Specifies the receiving account type.
     */
    'to_account'?: string;
    /**
     * Unique identifier of the transaction, formatted as a UUID.  *NOTE:* For subsequent related transactions, this token value appears as the `preceding_related_transaction_token`.
     */
    'token': string;
    /**
     * Additional transaction attributes.
     */
    'transaction_attributes'?: { [key: string]: string; };
    'transaction_metadata'?: TransactionMetadata;
    /**
     * Transaction event type. For more information about the `type` field, see <</core-api/event-types#_transaction_events, Transaction events>>.
     */
    'type': TransactionModelTypeEnum;
    'user'?: CardholderMetadata;
    /**
     * Unique identifier of the user who owns the account that funded the transaction; subsequent related transactions retain the same `user_token`, even if the card used to complete the transaction moves to another user.
     */
    'user_token'?: string;
    /**
     * Date and time when the user initiated the transaction, in UTC. For example, when a merchant performed the original authorization for a refund.
     */
    'user_transaction_time'?: string;
    'vdcap_qualified'?: boolean;
    'velocity_control_balances'?: { [key: string]: Available; };
    'visa_pop_code'?: string;
}

export const TransactionModelIsaIndicatorEnum = {
    MultiCurrency: 'MULTI_CURRENCY',
    SingleCurrency: 'SINGLE_CURRENCY',
    RebateCancelled: 'REBATE_CANCELLED',
    MultiCurrencyNonUsCountries: 'MULTI_CURRENCY_NON_US_COUNTRIES',
    SingleCurrencyPaidByIssuer: 'SINGLE_CURRENCY_PAID_BY_ISSUER',
    NoChargeAssessed: 'NO_CHARGE_ASSESSED'
} as const;

export type TransactionModelIsaIndicatorEnum = typeof TransactionModelIsaIndicatorEnum[keyof typeof TransactionModelIsaIndicatorEnum];
export const TransactionModelPolarityEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    PendingCredit: 'PENDING_CREDIT',
    PendingDebit: 'PENDING_DEBIT'
} as const;

export type TransactionModelPolarityEnum = typeof TransactionModelPolarityEnum[keyof typeof TransactionModelPolarityEnum];
export const TransactionModelStateEnum = {
    Pending: 'PENDING',
    Cleared: 'CLEARED',
    Completion: 'COMPLETION',
    Declined: 'DECLINED',
    Error: 'ERROR'
} as const;

export type TransactionModelStateEnum = typeof TransactionModelStateEnum[keyof typeof TransactionModelStateEnum];
export const TransactionModelTypeEnum = {
    GpaCredit: 'gpa.credit',
    GpaCreditPending: 'gpa.credit.pending',
    GpaCreditPendingReversal: 'gpa.credit.pending.reversal',
    GpaCreditReversal: 'gpa.credit.reversal',
    GpaCreditNetworkload: 'gpa.credit.networkload',
    GpaCreditNetworkloadReversal: 'gpa.credit.networkload.reversal',
    GpaDebitNetworkload: 'gpa.debit.networkload',
    GpaDebit: 'gpa.debit',
    GpaDebitPending: 'gpa.debit.pending',
    GpaDebitPendingReversal: 'gpa.debit.pending.reversal',
    GpaGrant: 'gpa.grant',
    GpaCreditIssueroperator: 'gpa.credit.issueroperator',
    GpaDebitIssueroperator: 'gpa.debit.issueroperator',
    GpaCreditChargeback: 'gpa.credit.chargeback',
    GpaCreditChargebackReversal: 'gpa.credit.chargeback.reversal',
    GpaCreditBillpayment: 'gpa.credit.billpayment',
    GpaCreditAuthorizationBillpayment: 'gpa.credit.authorization.billpayment',
    GpaCreditAuthorizationBillpaymentReversal: 'gpa.credit.authorization.billpayment.reversal',
    Authorization: 'authorization',
    AuthorizationAdvice: 'authorization.advice',
    AuthorizationReversal: 'authorization.reversal',
    AuthorizationClearing: 'authorization.clearing',
    AuthorizationReversalIssuerexpiration: 'authorization.reversal.issuerexpiration',
    DisputeCredit: 'dispute.credit',
    DisputeDebit: 'dispute.debit',
    AuthorizationClearingChargeback: 'authorization.clearing.chargeback',
    AuthorizationClearingChargebackReversal: 'authorization.clearing.chargeback.reversal',
    Refund: 'refund',
    PindebitAtmWithdrawal: 'pindebit.atm.withdrawal',
    PindebitBalanceinquiry: 'pindebit.balanceinquiry',
    PindebitCashback: 'pindebit.cashback',
    PindebitCheckavs: 'pindebit.checkavs',
    Pindebit: 'pindebit',
    ProgramreserveCredit: 'programreserve.credit',
    ProgramreserveDebit: 'programreserve.debit',
    FeeChargePending: 'fee.charge.pending',
    FeeCharge: 'fee.charge',
    FeeChargeRefund: 'fee.charge.refund',
    FeeChargeReversal: 'fee.charge.reversal',
    FundsExpire: 'funds.expire',
    RewardEarn: 'reward.earn',
    TransferPeer: 'transfer.peer',
    TransferFee: 'transfer.fee',
    AccountFundingAuthorization: 'account.funding.authorization',
    AccountFundingAuthorizationReversal: 'account.funding.authorization.reversal',
    AccountFundingAuthorizationClearing: 'account.funding.authorization.clearing',
    AccountFundingAuthPlusCapture: 'account.funding.auth_plus_capture',
    AccountFundingAuthPlusCaptureReversal: 'account.funding.auth_plus_capture.reversal',
    AccountCredit: 'account.credit',
    AccountDebit: 'account.debit',
    Balanceinquiry: 'balanceinquiry',
    AuthorizationAtmWithdrawal: 'authorization.atm.withdrawal',
    AuthorizationPinChange: 'authorization.pin.change',
    AuthorizationPinUnblock: 'authorization.pin.unblock',
    AuthorizationClearingAtmWithdrawal: 'authorization.clearing.atm.withdrawal',
    AuthorizationCashback: 'authorization.cashback',
    AuthorizationClearingCashback: 'authorization.clearing.cashback',
    TransferProgram: 'transfer.program',
    AuthorizationQuasiCash: 'authorization.quasi.cash',
    AuthorizationClearingQuasiCash: 'authorization.clearing.quasi.cash',
    AuthorizationIncremental: 'authorization.incremental',
    GpaCreditAuthorization: 'gpa.credit.authorization',
    GpaCreditAuthorizationReversal: 'gpa.credit.authorization.reversal',
    GpaDebitAuthorization: 'gpa.debit.authorization',
    GpaDebitReversal: 'gpa.debit.reversal',
    OriginalCreditAuthorization: 'original.credit.authorization',
    OriginalCreditAuthorizationReversal: 'original.credit.authorization.reversal',
    OriginalCreditAuthorizationClearing: 'original.credit.authorization.clearing',
    OriginalCreditAuthPlusCapture: 'original.credit.auth_plus_capture',
    OriginalCreditAuthPlusCaptureReversal: 'original.credit.auth_plus_capture.reversal',
    RefundAuthorization: 'refund.authorization',
    RefundAuthorizationAdvice: 'refund.authorization.advice',
    RefundAuthorizationClearing: 'refund.authorization.clearing',
    RefundAuthorizationReversal: 'refund.authorization.reversal',
    TokenActivationRequest: 'token.activation-request',
    TokenAdvice: 'token.advice',
    PindebitAuthorization: 'pindebit.authorization',
    PindebitAuthorizationClearing: 'pindebit.authorization.clearing',
    PindebitAuthorizationReversal: 'pindebit.authorization.reversal',
    PindebitAuthorizationReversalIssuerexpiration: 'pindebit.authorization.reversal.issuerexpiration',
    AuthorizationStandin: 'authorization.standin',
    AuthorizationClearingChargebackCompleted: 'authorization.clearing.chargeback.completed',
    AuthorizationClearingChargebackProvisionalCredit: 'authorization.clearing.chargeback.provisional.credit',
    AuthorizationClearingChargebackProvisionalDebit: 'authorization.clearing.chargeback.provisional.debit',
    AuthorizationClearingChargebackWriteoff: 'authorization.clearing.chargeback.writeoff',
    DirectdepositCredit: 'directdeposit.credit',
    DirectdepositCreditPending: 'directdeposit.credit.pending',
    DirectdepositCreditReject: 'directdeposit.credit.reject',
    DirectdepositCreditPendingReversal: 'directdeposit.credit.pending.reversal',
    DirectdepositCreditReversal: 'directdeposit.credit.reversal',
    DirectdepositDebit: 'directdeposit.debit',
    DirectdepositDebitPending: 'directdeposit.debit.pending',
    DirectdepositDebitReject: 'directdeposit.debit.reject',
    DirectdepositDebitReversal: 'directdeposit.debit.reversal',
    PinChangeReversal: 'pin.change.reversal',
    PinChangeReversalAdvice: 'pin.change.reversal.advice',
    DirectdepositDebitPendingReversal: 'directdeposit.debit.pending.reversal',
    PindebitChargeback: 'pindebit.chargeback',
    PindebitChargebackCompleted: 'pindebit.chargeback.completed',
    PindebitChargebackProvisionalCredit: 'pindebit.chargeback.provisional.credit',
    PindebitChargebackProvisionalDebit: 'pindebit.chargeback.provisional.debit',
    PindebitChargebackReversal: 'pindebit.chargeback.reversal',
    PindebitChargebackWriteoff: 'pindebit.chargeback.writeoff',
    PindebitPinChange: 'pindebit.pin.change',
    PindebitPinUnblock: 'pindebit.pin.unblock',
    PindebitCreditAdjustment: 'pindebit.credit.adjustment',
    PindebitQuasiCash: 'pindebit.quasi.cash',
    PindebitRefund: 'pindebit.refund',
    PindebitRefundReversal: 'pindebit.refund.reversal',
    PindebitReversal: 'pindebit.reversal',
    PindebitTransfer: 'pindebit.transfer',
    PushtocardDebit: 'pushtocard.debit',
    PushtocardReversal: 'pushtocard.reversal',
    CreditAdjustment: 'credit.adjustment',
    DebitAdjustment: 'debit.adjustment',
    PinChangeViaApi: 'pin.change.via.api',
    ProductInquiry: 'product.inquiry',
    TransitOffer: 'transit.offer',
    TransferFromCheckingHold: 'transfer.from.checking.hold',
    TransferFromCheckingClear: 'transfer.from.checking.clear',
    TransferToCheckingOpen: 'transfer.to.checking.open',
    TransferToCheckingClear: 'transfer.to.checking.clear',
    TransferToSavingsOpen: 'transfer.to.savings.open',
    TransferToSavingsClear: 'transfer.to.savings.clear',
    TransferFromSavingsHold: 'transfer.from.savings.hold',
    TransferFromSavingsClear: 'transfer.from.savings.clear',
    FpsDebitHold: 'fps.debit.hold',
    FpsDebitClear: 'fps.debit.clear',
    FpsDebitHoldReverse: 'fps.debit.hold.reverse',
    FpsDebitClearReverse: 'fps.debit.clear.reverse',
    FpsCreditOpen: 'fps.credit.open',
    FpsCreditClear: 'fps.credit.clear',
    FpsCreditOpenReverse: 'fps.credit.open.reverse',
    FpsCreditClearReverse: 'fps.credit.clear.reverse',
    OpenBankingFpsDebitHold: 'open.banking.fps.debit.hold',
    OpenBankingFpsDebitClear: 'open.banking.fps.debit.clear',
    OpenBankingFpsDebitHoldReverse: 'open.banking.fps.debit.hold.reverse',
    OpenBankingFpsDebitClearReverse: 'open.banking.fps.debit.clear.reverse',
    InterestPostingClear: 'interest.posting.clear',
    InterestPostingClearReverse: 'interest.posting.clear.reverse',
    InterestPostingAdjustment: 'interest.posting.adjustment',
    Unknown: 'unknown'
} as const;

export type TransactionModelTypeEnum = typeof TransactionModelTypeEnum[keyof typeof TransactionModelTypeEnum];

export interface TransactionModelListResponse {
    /**
     * The number of resources to retrieve.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * An array of transaction objects. See the <</core-api/transactions/#transaction_model, Transaction object>> description at the top of this page.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<TransactionModel>;
    /**
     * The sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * The sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface TransactionOptions {
    'additional_data'?: string;
    'card_expiration_date_yymm'?: string;
    'database_transaction_timeout'?: number;
    'encryption_key_id'?: string;
    'is_async'?: boolean;
    'pre_auth_time_limit'?: string;
    'send_expiration_date'?: boolean;
    'send_track_data'?: boolean;
    'transaction_timeout_threshold_seconds'?: number;
    'transaction_token'?: string;
}
/**
 * Contains merchant-provided, transit-related metadata related to the transaction.
 */
export interface Transit {
    /**
     * Type of transit transaction.
     */
    'transaction_type'?: TransitTransactionTypeEnum;
    /**
     * Mode of transportation.
     */
    'transportation_mode'?: TransitTransportationModeEnum;
}

export const TransitTransactionTypeEnum = {
    PreFunded: 'PRE_FUNDED',
    RealTimeAuthorized: 'REAL_TIME_AUTHORIZED',
    PostAuthorizedAggregated: 'POST_AUTHORIZED_AGGREGATED',
    AuthorizedAggregatedSplitClearing: 'AUTHORIZED_AGGREGATED_SPLIT_CLEARING',
    Other: 'OTHER',
    DebitRecovery: 'DEBIT_RECOVERY',
    AggregatedTransaction: 'AGGREGATED_TRANSACTION',
    AccountStatusInquiry: 'ACCOUNT_STATUS_INQUIRY'
} as const;

export type TransitTransactionTypeEnum = typeof TransitTransactionTypeEnum[keyof typeof TransitTransactionTypeEnum];
export const TransitTransportationModeEnum = {
    Bus: 'BUS',
    Train: 'TRAIN',
    WaterBorneVehicle: 'WATER_BORNE_VEHICLE',
    Toll: 'TOLL',
    Parking: 'PARKING',
    Taxi: 'TAXI',
    ParaTransit: 'PARA_TRANSIT',
    SelfDriveVehicle: 'SELF_DRIVE_VEHICLE',
    Coach: 'COACH',
    Locomotive: 'LOCOMOTIVE',
    PoweredMotorVehicle: 'POWERED_MOTOR_VEHICLE',
    Trailer: 'TRAILER',
    InterCity: 'INTER_CITY',
    CableCar: 'CABLE_CAR'
} as const;

export type TransitTransportationModeEnum = typeof TransitTransportationModeEnum[keyof typeof TransitTransportationModeEnum];

/**
 * Provides a list of rules triggered by a fraud event, along with the information on tags and rule characteristics.
 */
export interface TriggeredRule {
    /**
     * Indicates if the rule triggered an alert.
     */
    'alert'?: boolean;
    /**
     * The entity type where the triggered rule was defined.
     */
    'entity_type'?: string;
    /**
     * Name of the rule, as defined in the Real-Time Decisioning dashboard that was triggered.
     */
    'rule_name'?: string;
    /**
     * Indicates if the triggered rule has `suppress_alert` in the definition.
     */
    'suppress_alert'?: boolean;
    /**
     * All the tags defined in the triggered rule.
     */
    'tags'?: Array<Tag>;
}
export interface UnauthorizedError {
    'error_code': UnauthorizedErrorErrorCodeEnum;
    'error_message': string;
}

export const UnauthorizedErrorErrorCodeEnum = {
    _401: '401'
} as const;

export type UnauthorizedErrorErrorCodeEnum = typeof UnauthorizedErrorErrorCodeEnum[keyof typeof UnauthorizedErrorErrorCodeEnum];

export interface UnloadRequestModel {
    'amount': number;
    'funding_source_address_token'?: string;
    'memo'?: string;
    'original_order_token': string;
    'tags'?: string;
    'token'?: string;
}
export interface UpdateAliasStatusRequest {
    /**
     * Status of the Visa Alias.
     */
    'status'?: string;
}
export interface UserAccountsBalanceResponse {
    'account_balances': Array<AccountBalance>;
    'user_token'?: string;
}
export interface UserAssociation {
    'single_inventory_user'?: boolean;
    'single_inventory_user_token'?: string;
}
export interface UserCardHolderListResponse {
    /**
     * Number of resources to retrieve.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of user objects.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<CardHolderModel>;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
/**
 * Contains information about a cardholder.
 */
export interface UserCardHolderResponse {
    /**
     * Associates the specified account holder group with the cardholder.
     */
    'account_holder_group_token'?: string;
    /**
     * Specifies if the cardholder is in the `ACTIVE` state on the Marqeta platform.
     */
    'active'?: boolean;
    /**
     * Cardholder\'s address.
     */
    'address1'?: string;
    /**
     * Additional address information for the cardholder.
     */
    'address2'?: string;
    'authentication'?: Authentication;
    /**
     * Cardholder\'s date of birth.
     */
    'birth_date'?: string;
    /**
     * Country where the cardholder was born.
     */
    'birth_place'?: string;
    /**
     * Unique identifier of the business resource.
     */
    'business_token'?: string;
    /**
     * City where the cardholder resides.
     */
    'city'?: string;
    /**
     * Company name.
     */
    'company'?: string;
    /**
     * Specifies if the cardholder holds a corporate card.
     */
    'corporate_card_holder'?: boolean;
    /**
     * Country where the cardholder resides.
     */
    'country'?: string;
    /**
     * Date and time when the resource was created, in UTC.
     */
    'created_time': string;
    /**
     * Valid email address of the cardholder.
     */
    'email'?: string;
    /**
     * Cardholder\'s first name.
     */
    'first_name'?: string;
    /**
     * Gender of the cardholder.
     */
    'gender'?: UserCardHolderResponseGenderEnum;
    /**
     * Cardholder\'s title or prefix: Dr., Miss, Mr., Ms., and so on.
     */
    'honorific'?: string;
    /**
     * Expiration date of the cardholder\'s identification.
     */
    'id_card_expiration_date'?: string;
    /**
     * Cardholder\'s identification card number.
     */
    'id_card_number'?: string;
    /**
     * One or more objects containing identifications associated with the cardholder.
     */
    'identifications'?: Array<IdentificationResponseModel>;
    /**
     * Cardholder\'s IP address.
     */
    'ip_address'?: string;
    /**
     * Date and time when the resource was last updated, in UTC.
     */
    'last_modified_time': string;
    /**
     * Cardholder\'s last name.
     */
    'last_name'?: string;
    /**
     * Associates any additional metadata you provide with the cardholder.
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Cardholder\'s middle name.
     */
    'middle_name'?: string;
    /**
     * Cardholder\'s nationality.
     */
    'nationality'?: string;
    /**
     * Any additional information pertaining to the cardholder.
     */
    'notes'?: string;
    /**
     * Unique identifier of the parent user or business resource.
     */
    'parent_token'?: string;
    /**
     * Expiration date of the cardholder\'s passport.
     */
    'passport_expiration_date'?: string;
    /**
     * Cardholder\'s passport number.
     */
    'passport_number'?: string;
    /**
     * Password to the cardholder\'s user account on the Marqeta platform.
     */
    'password'?: string;
    /**
     * Cardholder\'s telephone number.
     */
    'phone'?: string;
    /**
     * Postal code of the cardholder\'s address.
     */
    'postal_code'?: string;
    /**
     * Cardholder\'s Social Security Number (SSN).
     */
    'ssn'?: string;
    /**
     * State or province where the cardholder resides.
     */
    'state'?: string;
    /**
     * Specifies the status of the cardholder on the Marqeta platform.
     */
    'status'?: UserCardHolderResponseStatusEnum;
    /**
     * Professional title of the cardholder, such as Chief Comptroller.
     */
    'title'?: string;
    /**
     * Unique identifier of the cardholder.
     */
    'token'?: string;
    /**
     * Indicates whether the child shares balances with the parent (`true`), or the child\'s balances are independent of the parent (`false`).
     */
    'uses_parent_account'?: boolean;
    /**
     * United States ZIP code of the cardholder\'s address.
     */
    'zip'?: string;
}

export const UserCardHolderResponseGenderEnum = {
    F: 'F',
    M: 'M'
} as const;

export type UserCardHolderResponseGenderEnum = typeof UserCardHolderResponseGenderEnum[keyof typeof UserCardHolderResponseGenderEnum];
export const UserCardHolderResponseStatusEnum = {
    Unverified: 'UNVERIFIED',
    Limited: 'LIMITED',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Closed: 'CLOSED'
} as const;

export type UserCardHolderResponseStatusEnum = typeof UserCardHolderResponseStatusEnum[keyof typeof UserCardHolderResponseStatusEnum];

export interface UserCardHolderSearchModel {
    /**
     * Performs a match on the specified deposit account number. Send a `GET` request to `/directdeposits/accounts/{user_token}` to retrieve the deposit account number for a specific cardholder.
     */
    'dda'?: string;
    /**
     * Performs a non-case-sensitive, exact match on the cardholder\'s `email` field.
     */
    'email'?: string;
    /**
     * Performs a non-case-sensitive match on the cardholder\'s `first_name` field. Matching is partial on the beginning of the name. For example, a match on \"Alex\" returns both \"Alex\" and \"Alexander\".
     */
    'first_name'?: string;
    /**
     * Performs a non-case-sensitive match on the cardholder\'s `last_name` field. Matching is partial on the beginning of the name. For example, a match on \"Smith\" returns both \"Smith\" and \"Smithfield\".
     */
    'last_name'?: string;
    /**
     * Performs a match on the cardholder\'s `phone` field.
     */
    'phone'?: string;
    /**
     * Performs a match on the cardholder\'s identification number.
     */
    'ssn'?: string;
}
export interface UserCardHolderUpdateModel {
    /**
     * Associates the specified account holder group with the cardholder. Send a `GET` request to `/accountholdergroups` to retrieve account holder group tokens.
     */
    'account_holder_group_token'?: string;
    /**
     * Cardholder address.  *NOTE:* Required for KYC verification (US-based cardholders only). Cannot perform KYC if set to a PO Box.
     */
    'address1'?: string;
    /**
     * Additional address information for the cardholder.  *NOTE:* Cannot perform KYC if set to a PO Box.
     */
    'address2'?: string;
    /**
     * Cardholder date of birth.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'birth_date'?: string;
    /**
     * Country where the cardholder was born.
     */
    'birth_place'?: string;
    /**
     * The city that corresponds to the address.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'city'?: string;
    /**
     * Company name.
     */
    'company'?: string;
    /**
     * Specifies if the cardholder holds a corporate card.
     */
    'corporate_card_holder'?: boolean;
    /**
     * Country in which the cardholder resides.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'country'?: string;
    /**
     * Valid email address for the cardholder.  This value must be unique among cardholders.
     */
    'email'?: string;
    /**
     * Cardholder first name.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'first_name'?: string;
    /**
     * Gender of the cardholder.
     */
    'gender'?: UserCardHolderUpdateModelGenderEnum;
    /**
     * Cardholder title or prefix: Ms., Mr., Miss, Mrs.
     */
    'honorific'?: string;
    /**
     * Expiration date of the cardholder\'s identification card.
     */
    'id_card_expiration_date'?: string;
    /**
     * Cardholder\'s identification card number.
     */
    'id_card_number'?: string;
    /**
     * One or more objects containing identifications associated with the cardholder.
     */
    'identifications'?: Array<IdentificationRequestModel>;
    /**
     * Cardholder IP address.
     */
    'ip_address'?: string;
    /**
     * Cardholder last name.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'last_name'?: string;
    /**
     * Associates any additional metadata you provide with the cardholder.
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Cardholder middle name.
     */
    'middle_name'?: string;
    /**
     * Cardholder nationality.
     */
    'nationality'?: string;
    /**
     * Any additional information pertaining to the cardholder.
     */
    'notes'?: string;
    /**
     * Unique identifier of an existing user or business resource.  Required if `uses_parent_account = true`. This account holder is configured as the parent of the current cardholder.  To unlink a child account from a parent account, update this field to a null value.
     */
    'parent_token'?: string;
    /**
     * Expiration date of the cardholder\'s passport.
     */
    'passport_expiration_date'?: string;
    /**
     * Cardholder passport number.
     */
    'passport_number'?: string;
    /**
     * Cardholder\'s user account password on the Marqeta platform.
     */
    'password'?: string;
    /**
     * Cardholder telephone number (including area code), prepended by the `+` symbol and the 1- to 3-digit country calling code. Do not include hyphens, spaces, or parentheses.
     */
    'phone'?: string;
    /**
     * Postal code of the cardholder\'s address.  *NOTE:* Required for KYC verification (US-based cardholders only).
     */
    'postal_code'?: string;
    /**
     * Cardholder\'s Social Security Number (SSN) or Individual Taxpayer Identification Number (ITIN).
     */
    'ssn'?: string;
    /**
     * State where the cardholder resides (`CA` for California, for example).  *NOTE:* <</core-api/kyc-verification#_valid_state_provincial_territorial_and_federal_abbreviations, Two-character abbreviation>> required for KYC verification (US-based cardholders only).
     */
    'state'?: string;
    /**
     * Professional title of the cardholder, such as Chief Comptroller.
     */
    'title'?: string;
    /**
     * Unique identifier of the cardholder.
     */
    'token'?: string;
    /**
     * Indicates whether the child shares balances with the parent (`true`), or the child\'s balances are independent of the parent (`false`).  If set to `true`, you must also include a `parent_token` in the request. This value cannot be updated.
     */
    'uses_parent_account'?: boolean;
}

export const UserCardHolderUpdateModelGenderEnum = {
    F: 'F',
    M: 'M'
} as const;

export type UserCardHolderUpdateModelGenderEnum = typeof UserCardHolderUpdateModelGenderEnum[keyof typeof UserCardHolderUpdateModelGenderEnum];

export interface UserTransitionListResponse {
    /**
     * Number of resources retrieved.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of user transition resources.  Resources are returned as appropriate to your query.
     */
    'data'?: Array<UserTransitionResponse>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface UserTransitionRequest {
    /**
     * Mechanism by which the transaction was initiated.
     */
    'channel': UserTransitionRequestChannelEnum;
    /**
     * Unique hashed value that identifies subsequent submissions of the user transition request.
     */
    'idempotentHash'?: string;
    /**
     * Additional information about the status change.
     */
    'reason'?: string;
    /**
     * Identifies the standardized reason for the transition:  *00:* Object activated for the first time.  *01:* Requested by you.  *02:* Inactivity over time.  *03:* This address cannot accept mail or the addressee is unknown.  *04:* Negative account balance.  *05:* Account under review.  *06:* Suspicious activity was identified.  *07:* Activity outside the program parameters was identified.  *08:* Confirmed fraud was identified.  *09:* Matched with an Office of Foreign Assets Control list.  *10:* Card was reported lost.  *11:* Card information was cloned.  *12:* Account or card information was compromised.  *13:* Temporary status change while on hold/leave.  *14:* Initiated by Marqeta.  *15:* Initiated by issuer.  *16:* Card expired.  *17:* Failed KYC.  *18:* Changed to `ACTIVE` because information was properly validated.  *19:* Changed to `ACTIVE` because account activity was properly validated.  *20:* Change occurred prior to the normalization of reason codes.  *21:* Initiated by a third party, often a digital wallet provider.  *22:* PIN retry limit reached.  *23:* Card was reported stolen.  *24:* Address issue.  *25:* Name issue.  *26:* SSN issue.  *27:* DOB issue.  *28:* Email issue.  *29:* Phone issue.  *30:* Account/fulfillment mismatch.  *31:* Other reason.  *86:* Notification of death.
     */
    'reason_code': UserTransitionRequestReasonCodeEnum;
    /**
     * Specifies the new status of the user.
     */
    'status': UserTransitionRequestStatusEnum;
    /**
     * Unique identifier of the user transition.  If you do not include a token, the system generates one automatically. This token is referenced in other API calls, so we recommend that you define a simple string that is easy to remember. This value cannot be updated.
     */
    'token'?: string;
    /**
     * Unique identifier of the user whose status you want to transition.
     */
    'user_token': string;
}

export const UserTransitionRequestChannelEnum = {
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM'
} as const;

export type UserTransitionRequestChannelEnum = typeof UserTransitionRequestChannelEnum[keyof typeof UserTransitionRequestChannelEnum];
export const UserTransitionRequestReasonCodeEnum = {
    _00: '00',
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15',
    _16: '16',
    _17: '17',
    _18: '18',
    _19: '19',
    _20: '20',
    _21: '21',
    _22: '22',
    _23: '23',
    _24: '24',
    _25: '25',
    _26: '26',
    _27: '27',
    _28: '28',
    _29: '29',
    _30: '30',
    _31: '31',
    _32: '32',
    _86: '86'
} as const;

export type UserTransitionRequestReasonCodeEnum = typeof UserTransitionRequestReasonCodeEnum[keyof typeof UserTransitionRequestReasonCodeEnum];
export const UserTransitionRequestStatusEnum = {
    Unverified: 'UNVERIFIED',
    Limited: 'LIMITED',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Closed: 'CLOSED',
    Terminated: 'TERMINATED'
} as const;

export type UserTransitionRequestStatusEnum = typeof UserTransitionRequestStatusEnum[keyof typeof UserTransitionRequestStatusEnum];

export interface UserTransitionResponse {
    /**
     * Mechanism by which the transaction was initiated.
     */
    'channel': UserTransitionResponseChannelEnum;
    /**
     * Date and time when the resource was created, in UTC.
     */
    'created_time'?: string;
    /**
     * Date and time when the resource was created. Expressed in UTC, with millisecond precision.
     */
    'created_timestamp'?: string;
    /**
     * Date and time when the resource was last modified, in UTC.
     */
    'last_modified_time'?: string;
    /**
     * Associates customer-injected metadata with the user. Returned if part of the call to `POST /users`.
     */
    'metadata'?: { [key: string]: string; };
    /**
     * Additional information about the status change.
     */
    'reason'?: string;
    /**
     * Identifies the standardized reason for the transition:  *00:* Object activated for the first time.  *01:* Requested by you.  *02:* Inactivity over time.  *03:* This address cannot accept mail or the addressee is unknown.  *04:* Negative account balance.  *05:* Account under review.  *06:* Suspicious activity was identified.  *07:* Activity outside the program parameters was identified.  *08:* Confirmed fraud was identified.  *09:* Matched with an Office of Foreign Assets Control list.  *10:* Card was reported lost.  *11:* Card information was cloned.  *12:* Account or card information was compromised.  *13:* Temporary status change while on hold/leave.  *14:* Initiated by Marqeta.  *15:* Initiated by issuer.  *16:* Card expired.  *17:* Failed KYC.  *18:* Changed to `ACTIVE` because information was properly validated.  *19:* Changed to `ACTIVE` because account activity was properly validated.  *20:* Change occurred prior to the normalization of reason codes.  *21:* Initiated by a third party, often a digital wallet provider.  *22:* PIN retry limit reached.  *23:* Card was reported stolen.  *24:* Address issue.  *25:* Name issue.  *26:* SSN issue.  *27:* DOB issue.  *28:* Email issue.  *29:* Phone issue.  *30:* Account/fulfillment mismatch.  *31:* Other reason.  *86:* Notification of death.
     */
    'reason_code': UserTransitionResponseReasonCodeEnum;
    /**
     * Specifies the new status of the user.
     */
    'status': UserTransitionResponseStatusEnum;
    /**
     * Unique identifier of the user transition.
     */
    'token': string;
    /**
     * Unique identifier of the user whose status was transitioned.
     */
    'user_token'?: string;
}

export const UserTransitionResponseChannelEnum = {
    Api: 'API',
    Ivr: 'IVR',
    Fraud: 'FRAUD',
    Admin: 'ADMIN',
    System: 'SYSTEM'
} as const;

export type UserTransitionResponseChannelEnum = typeof UserTransitionResponseChannelEnum[keyof typeof UserTransitionResponseChannelEnum];
export const UserTransitionResponseReasonCodeEnum = {
    _00: '00',
    _01: '01',
    _02: '02',
    _03: '03',
    _04: '04',
    _05: '05',
    _06: '06',
    _07: '07',
    _08: '08',
    _09: '09',
    _10: '10',
    _11: '11',
    _12: '12',
    _13: '13',
    _14: '14',
    _15: '15',
    _16: '16',
    _17: '17',
    _18: '18',
    _19: '19',
    _20: '20',
    _21: '21',
    _22: '22',
    _23: '23',
    _24: '24',
    _25: '25',
    _26: '26',
    _27: '27',
    _28: '28',
    _29: '29',
    _30: '30',
    _31: '31',
    _32: '32',
    _86: '86'
} as const;

export type UserTransitionResponseReasonCodeEnum = typeof UserTransitionResponseReasonCodeEnum[keyof typeof UserTransitionResponseReasonCodeEnum];
export const UserTransitionResponseStatusEnum = {
    Unverified: 'UNVERIFIED',
    Limited: 'LIMITED',
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Closed: 'CLOSED',
    Terminated: 'TERMINATED'
} as const;

export type UserTransitionResponseStatusEnum = typeof UserTransitionResponseStatusEnum[keyof typeof UserTransitionResponseStatusEnum];

export interface UserValidationRequest {
    /**
     * yyyy-MM-dd
     */
    'birth_date'?: string;
    /**
     * Phone #
     */
    'phone'?: string;
    /**
     * Six-char random name postfix
     */
    'random_name_line1_postfix'?: string;
    /**
     * Last four digits of SSN
     */
    'ssn'?: string;
}
export interface UserValidationResponse {
    /**
     * yyyy-MM-dd
     */
    'birth_date': boolean;
    /**
     * 10 char max, phone number
     */
    'phone': boolean;
    /**
     * Six-char random name postfix
     */
    'random_name_line1_postfix': boolean;
    /**
     * Last four digits of SSN
     */
    'ssn': boolean;
}
export interface ValidationsRequest {
    'user'?: UserValidationRequest;
}
export interface ValidationsResponse {
    'user': UserValidationResponse;
}
export interface VelocityControlBalance {
    /**
     * Indicates whether the velocity control is active.
     */
    'active'?: boolean;
    /**
     * Maximum monetary sum that can be cleared within the time period defined by velocity period.
     */
    'amount_limit': number;
    'association'?: Association;
    /**
     * Three-character ISO 4217 currency code.
     */
    'currency_code': string;
    'merchant_scope'?: MerchantScope;
    /**
     * Description of how the velocity control restricts spending. For example, \"Max spend of $500 per day\" or \"Max spend of $5000 per month for non-exempt employees\".
     */
    'name'?: string;
    /**
     * Unique identifier of the velocity control.
     */
    'token'?: string;
    /**
     * Maximum number of times a card can be used within the time period defined by the `velocity_window` field.  Leave `null` to indicate that the card can be used an unlimited number of times.
     */
    'usage_limit'?: number;
    'velocity_window'?: VelocityWindow;
    /**
     * Start day of the velocity window defined by the `velocity_window` field. Default value is `1`
     */
    'velocity_window_start_day'?: number;
    'available'?: VelocityControlBalanceAllOfAvailable;
}


export interface VelocityControlBalanceAllOfAvailable {
    /**
     * Amount of money remaining for the user. This value is returned only if the user has a limit on the amount of money.
     */
    'amount'?: number;
    /**
     * Number of days remaining for the user. This value is returned only if the user has a limit on the number of days.
     */
    'days_remaining'?: number;
    /**
     * Number of uses remaining for the user. This value is returned only if the user has a limit on the number of uses.
     */
    'uses'?: number;
}
export interface VelocityControlBalanceListResponse {
    /**
     * Number of velocity control resources retrieved.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of velocity control objects that include available balances.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<VelocityControlBalanceResponse>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface VelocityControlBalancePage {
    /**
     * Number of resources retrieved.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of Card Group objects.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<VelocityControlBalance>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface VelocityControlBalanceResponse {
    /**
     * Indicates whether the velocity control is active.
     */
    'active'?: boolean;
    /**
     * Maximum monetary sum that can be cleared within the time period defined by the `velocity_window` field. Refunds and reversals cannot exceed this limit.
     */
    'amount_limit': number;
    /**
     * If set to `true`, only approved transactions are subject to control. If set to `false`, only declined transactions are subject to control.
     */
    'approvals_only'?: boolean;
    'association'?: SpendControlAssociation;
    'available': Available;
    /**
     * Three-character ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * If set to `true`, the cashback components of point-of-sale transactions are subject to control.
     */
    'include_cashback'?: boolean;
    /**
     * If set to `true`, original credit transactions (OCT) are subject to control.
     */
    'include_credits'?: boolean;
    /**
     * If set to `true`, the following transactions are subject to control:  * *Account funding:* All account funding transactions * *Cashback:* Only the purchase component of cashback transactions * *Purchase transactions:* All authorizations, PIN debit transactions, and incremental transactions * *Quasi-cash:* All quasi-cash transactions * *Refunds:* All refund transactions (see <</developer-guides/controlling-spending#_controls_to_limit_amount_and_frequency_of_spending, Controls to limit amount and frequency of spending>> for more information) * *Reversals:* All reversal transactions
     */
    'include_purchases'?: boolean;
    /**
     * If set to `true`, account-to-account transfers are subject to control. Account-to-account transfers are not currently supported.
     */
    'include_transfers'?: boolean;
    /**
     * If set to `true`, ATM withdrawals are subject to control.
     */
    'include_withdrawals'?: boolean;
    'merchant_scope'?: MerchantScope;
    'money_in_transaction'?: MoneyInTransaction;
    /**
     * Description of how the velocity control restricts spending, for example, \"Max spend of $500 per day\" or \"Max spend of $5000 per month for non-exempt employees\".
     */
    'name'?: string;
    /**
     * Unique identifier of the velocity control.
     */
    'token'?: string;
    /**
     * Maximum number of times a card can be used within the time period defined by the `velocity_window` field.
     */
    'usage_limit'?: number;
    /**
     * Defines the time period to which the `amount_limit` and `usage_limit` fields apply:  * *DAY*  one day; days begin at 00:00:00 UTC. * *WEEK*  one week; weeks begin Sundays at 00:00:00 UTC. * *MONTH*  one month; months begin on the first day of month at 00:00:00 UTC. * *LIFETIME*  forever; time period never expires. * *TRANSACTION*  a single transaction.
     */
    'velocity_window': VelocityControlBalanceResponseVelocityWindowEnum;
}

export const VelocityControlBalanceResponseVelocityWindowEnum = {
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH',
    Lifetime: 'LIFETIME',
    Transaction: 'TRANSACTION'
} as const;

export type VelocityControlBalanceResponseVelocityWindowEnum = typeof VelocityControlBalanceResponseVelocityWindowEnum[keyof typeof VelocityControlBalanceResponseVelocityWindowEnum];

export interface VelocityControlListResponse {
    /**
     * Number of resources retrieved.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of velocity control objects.  Objects are returned as appropriate to your query.
     */
    'data'?: Array<VelocityControlResponse>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * The sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface VelocityControlRequest {
    /**
     * Indicates whether the velocity control is active.
     */
    'active'?: boolean;
    /**
     * Maximum monetary sum that can be cleared within the time period defined by the `velocity_window` field. Refunds and reversals cannot exceed this limit.
     */
    'amount_limit': number;
    /**
     * If set to `true`, only approved transactions are subject to control. If set to `false`, only declined transactions are subject to control.
     */
    'approvals_only'?: boolean;
    'association'?: SpendControlAssociation;
    /**
     * Three-character ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * If set to `true`, the cashback components of point-of-sale transactions are subject to control.
     */
    'include_cashback'?: boolean;
    /**
     * If set to `true`, original credit transactions (OCT) are subject to control. Your request can contain either a `money_in_transaction` object or the `include_credits` field, not both.
     */
    'include_credits'?: boolean;
    /**
     * If set to `true`, the following transactions are subject to control:  * *Account funding:* All account funding transactions * *Cashback:* Only the purchase component of cashback transactions * *Purchase transactions:* All authorizations, PIN debit transactions, and incremental transactions * *Quasi-cash:* All quasi-cash transactions * *Refunds:* All refund transactions (see <</developer-guides/controlling-spending#_controls_to_limit_amount_and_frequency_of_spending, Controls to limit amount and frequency of spending>> for more information) * *Reversals:* All reversal transactions
     */
    'include_purchases'?: boolean;
    /**
     * If set to `true`, account-to-account transfers are subject to control. Account-to-account transfers are not currently supported.
     */
    'include_transfers'?: boolean;
    /**
     * If set to `true`, ATM withdrawals are subject to control.
     */
    'include_withdrawals'?: boolean;
    'merchant_scope'?: MerchantScope;
    'money_in_transaction'?: MoneyInTransaction;
    /**
     * Description of how the velocity control restricts spending, for example, \"Max spend of $500 per day\" or \"Max spend of $5000 per month for non-exempt employees\".  Ensure that the description you provide here adequately captures the kind of restriction exerted by this velocity control, because the Marqeta platform will send this information to you in a webhook in the event that the transaction authorization attempt is declined by the velocity control.  *NOTE:* This field is very important. If your program has multiple velocity controls in place, it is not always clear which one prevented the transaction from being approved. Adding specific details to this field gives you more contextual information when debugging or monitoring declined authorization attempts.
     */
    'name'?: string;
    /**
     * Unique identifier of the velocity control.  If you do not include a token, the system will generate one automatically. This token is necessary for use in other API calls, so we recommend that rather than let the system generate one, you use a simple string that is easy to remember. This value cannot be updated.
     */
    'token'?: string;
    /**
     * Maximum number of times a card can be used within the time period defined by the `velocity_window` field.  If `velocity_window` is set to `TRANSACTION`, do not include a `usage_limit` in your request.  Set to `-1` to indicate that the card can be used an unlimited number of times.
     */
    'usage_limit'?: number;
    /**
     * Defines the time period to which the `amount_limit` and `usage_limit` fields apply:  * *DAY*  one day; days begin at 00:00:00 UTC. * *WEEK*  one week; weeks begin Sundays at 00:00:00 UTC. * *MONTH*  one month; months begin on the first day of month at 00:00:00 UTC. * *LIFETIME*  forever; time period never expires. * *TRANSACTION*  a single transaction.  // (2023-05-03): This statement was validated by Processing, as part of a customer inquiry. *NOTE:* If set to `DAY`, `WEEK`, or `MONTH`, the velocity control takes effect retroactively from the beginning of the specified period. The amount and usage data already collected within the first period is counted toward the limits. If set to `LIFETIME`, the velocity control only applies to transactions on or after the date and time that the velocity control was created. `LIFETIME` velocity controls are not retroactively applied to historical transactions.  // (2023-05-03): Commenting this note out, as it is untrue in testing as reported by customers and confirmed by transaction engine team //_*NOTE:* Editing any of the following fields on a velocity control resets its usage and amount count to 0:  //_* `merchant_scope.mcc` //_* `merchant_scope.mid` //_* `merchant_scope.mcc_group` //_* `association.user_token` //_* `association.card_product_token`
     */
    'velocity_window': VelocityControlRequestVelocityWindowEnum;
}

export const VelocityControlRequestVelocityWindowEnum = {
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH',
    Lifetime: 'LIFETIME',
    Transaction: 'TRANSACTION'
} as const;

export type VelocityControlRequestVelocityWindowEnum = typeof VelocityControlRequestVelocityWindowEnum[keyof typeof VelocityControlRequestVelocityWindowEnum];

export interface VelocityControlResponse {
    /**
     * Indicates whether the velocity control is active.
     */
    'active'?: boolean;
    /**
     * Maximum monetary sum that can be cleared within the time period defined by the `velocity_window` field. Refunds and reversals cannot exceed this limit.
     */
    'amount_limit': number;
    /**
     * If set to `true`, only approved transactions are subject to control. If set to `false`, only declined transactions are subject to control.
     */
    'approvals_only'?: boolean;
    'association'?: SpendControlAssociation;
    /**
     * Three-character ISO 4217 currency code.
     */
    'currency_code': string;
    /**
     * If set to `true`, the cashback components of point-of-sale transactions are subject to control.
     */
    'include_cashback'?: boolean;
    /**
     * If set to `true`, original credit transactions (OCT) are subject to control.
     */
    'include_credits'?: boolean;
    /**
     * If set to `true`, the following transactions are subject to control:  * *Account funding:* All account funding transactions * *Cashback:* Only the purchase component of cashback transactions * *Purchase transactions:* All authorizations, PIN debit transactions, and incremental transactions * *Quasi-cash:* All quasi-cash transactions * *Refunds:* All refund transactions (see <</developer-guides/controlling-spending#_controls_to_limit_amount_and_frequency_of_spending, Controls to limit amount and frequency of spending>> for more information) * *Reversals:* All reversal transactions
     */
    'include_purchases'?: boolean;
    /**
     * If set to `true`, account-to-account transfers are subject to control. Account-to-account transfers are not currently supported.
     */
    'include_transfers'?: boolean;
    /**
     * If set to `true`, ATM withdrawals are subject to control.
     */
    'include_withdrawals'?: boolean;
    'merchant_scope'?: MerchantScope;
    'money_in_transaction'?: MoneyInTransaction;
    /**
     * Description of how the velocity control restricts spending. For example, \"Max spend of $500 per day\" or \"Max spend of $5000 per month for non-exempt employees\".
     */
    'name'?: string;
    /**
     * Unique identifier of the velocity control.
     */
    'token'?: string;
    /**
     * Maximum number of times a card can be used within the time period defined by the `velocity_window` field.
     */
    'usage_limit'?: number;
    /**
     * Defines the time period to which the `amount_limit` and `usage_limit` fields apply:  * *DAY*  one day; days begin at 00:00:00 UTC. * *WEEK*  one week; weeks begin Sundays at 00:00:00 UTC. * *MONTH*  one month; months begin on the first day of month at 00:00:00 UTC. * *LIFETIME*  forever; time period never expires. * *TRANSACTION*  a single transaction.
     */
    'velocity_window': VelocityControlResponseVelocityWindowEnum;
}

export const VelocityControlResponseVelocityWindowEnum = {
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH',
    Lifetime: 'LIFETIME',
    Transaction: 'TRANSACTION'
} as const;

export type VelocityControlResponseVelocityWindowEnum = typeof VelocityControlResponseVelocityWindowEnum[keyof typeof VelocityControlResponseVelocityWindowEnum];

export interface VelocityControlUpdateRequest {
    /**
     * Indicates whether the velocity control is active.
     */
    'active'?: boolean;
    /**
     * Maximum monetary sum that can be cleared within the time period defined by the `velocity_window` field. Refunds and reversals cannot exceed this limit.
     */
    'amount_limit'?: number;
    /**
     * If set to `true`, only approved transactions are subject to control. If set to `false`, only declined transactions are subject to control.
     */
    'approvals_only'?: boolean;
    'association'?: SpendControlAssociation;
    /**
     * Three-character ISO 4217 currency code.
     */
    'currency_code'?: string;
    /**
     * If set to `true`, the cashback components of point-of-sale transactions are subject to control.
     */
    'include_cashback'?: boolean;
    /**
     * If set to `true`, original credit transactions are subject to control. Your request can contain either a `money_in_transaction` object or the `include_credits` field, not both.
     */
    'include_credits'?: boolean;
    /**
     * If set to `true`, the following transactions are subject to control:  * *Account funding:* All account funding transactions * *Cashback:* Only the purchase component of cashback transactions * *Purchase transactions:* All authorizations, PIN debit transactions, and incremental transactions * *Quasi-cash:* All quasi-cash transactions * *Refunds:* All refund transactions (see <</developer-guides/controlling-spending#_controls_to_limit_amount_and_frequency_of_spending, Controls to limit amount and frequency of spending>> for more information) * *Reversals:* All reversal transactions
     */
    'include_purchases'?: boolean;
    /**
     * If set to `true`, account-to-account transfers are subject to control. Account-to-account transfers are not currently supported.
     */
    'include_transfers'?: boolean;
    /**
     * If set to `true`, ATM withdrawals are subject to control.
     */
    'include_withdrawals'?: boolean;
    'merchant_scope'?: MerchantScope;
    'money_in_transaction'?: MoneyInTransaction;
    /**
     * Description of how the velocity control restricts spending. For example, \"Max spend of $500 per day\" or \"Max spend of $5000 per month for non-exempt employees\".  Ensure that the description you provide here adequately captures the kind of restriction exerted by this velocity control, because the Marqeta platform will send this information to you in a webhook in the event that the transaction authorization attempt is declined by the velocity control.  *NOTE:* This field is very important. If your program has multiple velocity controls in place, it is not always clear which one prevented the transaction from being approved. Adding specific details to this field gives you more contextual information when debugging or monitoring declined authorization attempts.
     */
    'name'?: string;
    /**
     * Unique identifier of the velocity control resource.
     */
    'token': string;
    /**
     * Maximum number of times a card can be used within the time period defined by the `velocity_window` field.  If `velocity_window` is set to `TRANSACTION`, do not include a `usage_limit` in your request.
     */
    'usage_limit'?: number;
    /**
     * Defines the time period to which the `amount_limit` and `usage_limit` fields apply:  * *DAY*  one day; days begin at 00:00:00 UTC. * *WEEK*  one week; weeks begin Sundays at 00:00:00 UTC. * *MONTH*  one month; months begin on the first day of month at 00:00:00 UTC. * *LIFETIME*  forever; time period never expires. * *TRANSACTION*  a single transaction.  // (2023-05-03): This statement was validated by Processing, as part of a customer inquiry. *NOTE:* If set to `DAY`, `WEEK`, or `MONTH`, the velocity control takes effect retroactively from the beginning of the specified period. The amount and usage data already collected within the first period is counted toward the limits. If set to `LIFETIME`, the velocity control only applies to transactions on or after the date and time that the velocity control was created. `LIFETIME` velocity controls are not retroactively applied to historical transactions.  // (2023-05-03): Commenting this note out, as it is untrue in testing as reported by customers and confirmed by transaction engine team //_*NOTE:* Editing any of the following fields on a velocity control resets its usage and amount count to 0:  //_* `merchant_scope.mcc` //_* `merchant_scope.mid` //_* `merchant_scope.mcc_group` //_* `association.user_token` //_* `association.card_product_token`
     */
    'velocity_window'?: VelocityControlUpdateRequestVelocityWindowEnum;
}

export const VelocityControlUpdateRequestVelocityWindowEnum = {
    Day: 'DAY',
    Week: 'WEEK',
    Month: 'MONTH',
    Quarter: 'QUARTER',
    Year: 'YEAR',
    Lifetime: 'LIFETIME',
    Transaction: 'TRANSACTION'
} as const;

export type VelocityControlUpdateRequestVelocityWindowEnum = typeof VelocityControlUpdateRequestVelocityWindowEnum[keyof typeof VelocityControlUpdateRequestVelocityWindowEnum];

/**
 * Defines the time period to which the `amount_limit` and `usage_limit` fields apply: * *MONTH*  one month; months begin on the first day of month at 00:00:00 ET.
 */

export const VelocityWindow = {
    Month: 'MONTH'
} as const;

export type VelocityWindow = typeof VelocityWindow[keyof typeof VelocityWindow];


/**
 * Billing address for Visa Click to Pay.
 */
export interface VisaClickToPayBillingAddress {
    /**
     * First line of the billing address.
     */
    'address1': string;
    /**
     * Optional second line of the billing address.
     */
    'address2'?: string;
    /**
     * City of the billing address.
     */
    'city': string;
    /**
     * Country of the billing address.
     */
    'country': string;
    /**
     * Postal code of the billing address.
     */
    'postalCode': string;
    /**
     * State of the billing address.
     */
    'state': string;
}
/**
 * Card information for Visa Click to Pay.
 */
export interface VisaClickToPayCard {
    'billingAddress': VisaClickToPayBillingAddress;
    /**
     * Unique identifier of the card.
     */
    'cardToken': string;
    /**
     * Name of the cardholder that appears on the card.
     */
    'nameOnCard': string;
}
/**
 * Request to enroll a card for an existing cardholder.
 */
export interface VisaClickToPayEnrollCardsRequest {
    'card': VisaClickToPayCard;
    /**
     * Unique identifier of the cardholder.
     */
    'userToken': string;
}
/**
 * Request to enroll a new cardholder and card.
 */
export interface VisaClickToPayEnrollRequest {
    'card': VisaClickToPayCard;
    'user': VisaClickToPayUser;
}
/**
 * Response containing the external consumer ID of a Visa Click to Pay cardholder.
 */
export interface VisaClickToPayGetUserDataResponse {
    /**
     * External consumer ID
     */
    'externalConsumerId': string;
}
/**
 * Response containing the request trace ID of a Visa Click to Pay request.
 */
export interface VisaClickToPayResponse {
    /**
     * Unique identifier of the Visa Click to Pay request.
     */
    'requestTraceId': string;
}
/**
 * Response containing the status of a Visa Click to Pay request.
 */
export interface VisaClickToPayStatusResponse {
    /**
     * External consumer ID of the cardholder.
     */
    'externalConsumerId': string;
    /**
     * Status of the operation.
     */
    'status': string;
}
/**
 * Request to update a card for an existing cardholder.
 */
export interface VisaClickToPayUpdateCardRequest {
    'card': VisaClickToPayCard;
    /**
     * Unique identifier of the cardholder.
     */
    'userToken': string;
}
/**
 * Request to update cardholder information.
 */
export interface VisaClickToPayUpdateCardholderRequest {
    'user': VisaClickToPayUser;
}
/**
 * User\'s email address, mobile phone number without country code, first name, last name, locale, and country.
 */
export interface VisaClickToPayUser {
    /**
     * ISO 3166-1 alpha-3 country code.
     */
    'country': string;
    /**
     * User\'s email address.
     */
    'email': string;
    /**
     * User\'s first name.
     */
    'firstName': string;
    /**
     * User\'s last name.
     */
    'lastName': string;
    /**
     * The user-provided language choice. The ISO 639-2 language code is a two-letter country code that represents a language.  The ISO maintains the link:https://id.loc.gov/vocabulary/iso639-2.html[ISO 639-2 language codes, window=\"_blank\"].
     */
    'locale': string;
    /**
     * User\'s mobile phone number without country code.
     */
    'phone': string;
    /**
     * Unique identifier of the cardholder.
     */
    'userToken': string;
}
export interface WalletProviderCardOnFile {
    'address_verification'?: DigitalWalletTokenAddressVerification;
    /**
     * Specifies if the card on file is enabled.
     */
    'enabled'?: boolean;
}
/**
 * Contains information held and provided by the digital wallet provider.
 */
export interface WalletProviderProfile {
    'account'?: Account;
    /**
     * Score from the device.
     */
    'device_score'?: string;
    /**
     * Source from which the digital wallet provider obtained the card primary account number (PAN).
     */
    'pan_source'?: string;
    /**
     * Reason for the wallet provider\'s provisioning decision.  * *01*  Cardholder\'s wallet account is too new relative to launch. * *02*  Cardholder\'s wallet account is too new relative to provisioning request. * *03*  Cardholder\'s wallet account/card pair is newer than date threshold. * *04*  Changes made to account data within the account threshold. * *05*  Suspicious transactions linked to this account. * *06*  Account has not had activity in the last year. * *07*  Suspended cards in the secure element. * *08*  Device was put in lost mode in the last seven days for longer than the duration threshold. * *09*  The number of provisioning attempts on this device in 24 hours exceeds threshold. * *0A*  There have been more than the threshold number of different cards attempted at provisioning to this phone in 24 hours. * *0B*  The card provisioning attempt contains a distinct name in excess of the threshold. * *0C*  The device score is less than 3. * *0D*  The account score is less than 4. * *0E*  Device provisioning location outside of the cardholder\'s wallet account home country. * *0G*  Suspect fraud.
     */
    'reason_code'?: string;
    /**
     * Array of recommendation reasons from the digital wallet provider.
     */
    'recommendation_reasons'?: Array<string>;
    'risk_assessment'?: RiskAssessment;
}
export interface WebPushProvisioning {
    /**
     * Identifier that Apple uses to identify the program to process the request for.
     */
    'wpp_apple_card_template_id'?: string;
    /**
     * Identifier that Apple uses to identify the program to provide the correct card art for.
     */
    'wpp_apple_partner_id'?: string;
    /**
     * Identifier that Google uses to identify the program to process the request for and to provide the correct card art for.
     */
    'wpp_google_piaid'?: string;
}
/**
 * Contains header data for the JWS object.
 */
export interface WebPushProvisioningApplePayJWSHeader {
    /**
     * Unique identifier of the JSON Web Signature (JWS) public key of the key pair used to generate the signature.
     */
    'kid': string;
}
/**
 * Object containing JSON Web Signature (JWS) data.
 */
export interface WebPushProvisioningApplePayJWSModel {
    'header': WebPushProvisioningApplePayJWSHeader;
    /**
     * JSON Web Signature (JWS) message payload.
     */
    'payload': string;
    /**
     * Contains header parameters that are integrity-protected by the JSON Web Signature (JWS).
     */
    'protected': string;
    /**
     * The JSON Web Signature (JWS).
     */
    'signature': string;
}
export interface WebPushProvisioningApplePayJWTResponse {
    'jws': WebPushProvisioningApplePayJWSModel;
    /**
     * Unique state associated with the digital wallet token. The Marqeta platform returns a universally unique identifier (UUID) in this field.
     */
    'state': string;
}
export interface Webhook {
    /**
     * Valid URL
     */
    'endpoint': string;
    /**
     * Authentication password
     */
    'password': string;
    /**
     * Authentication secret
     */
    'secret'?: string;
    /**
     * Authentication username
     */
    'username': string;
}
export interface WebhookBaseModel {
    /**
     * Indicates whether the webhook is active.
     */
    'active'?: boolean;
    'config': WebhookConfigRequestModel;
    /**
     * Specifies the types of events for which notifications are sent.  The wildcard character `\\*` indicates that you receive all webhook notifications, or all notifications of a specified category. For example, `*` indicates that you receive all webhook notifications; `transaction.*` indicates that you receive all `transaction` webhook notifications.  *NOTE:* You can only use the wildcard character with the _base_ type events, not subcategories. For example, you cannot subscribe to `cardtransition.fulfillment.\\*` events, but you can subscribe to `cardtransition.*`.
     */
    'events': Array<string>;
    /**
     * Descriptive name of the webhook.
     */
    'name': string;
}
/**
 * Contains the configuration information for the webhook.
 */
export interface WebhookConfigRequestModel {
    /**
     * Password for accessing your webhook endpoint.
     */
    'basic_auth_password': string;
    /**
     * Username for accessing your webhook endpoint.
     */
    'basic_auth_username': string;
    /**
     * Custom headers to be passed along with the request.
     */
    'custom_header'?: { [key: string]: string; };
    /**
     * Randomly chosen string used for implementing HMAC-SHA1. HMAC-SHA1 provides an added layer of security by authenticating the message and validating message integrity. Using this functionality requires that your webhook endpoint verify the message signature. For information about implementing this functionality, see <</developer-guides/signature-verification, Signature Verification>>.
     */
    'secret'?: string;
    /**
     * URL of your webhook endpoint.
     */
    'url': string;
    /**
     * Set to `true` to use use mutual transport layer security (mTLS) authentication for the webhook. mTLS authentication is in the beta testing phase, and is not yet generally available. Contact your Marqeta representative for more information about using mTLS authentication.
     */
    'use_mtls'?: boolean;
}
/**
 * Contains the configuration information for the webhook.
 */
export interface WebhookConfigResponseModel {
    /**
     * Password for accessing your webhook endpoint.
     */
    'basic_auth_password': string;
    /**
     * Username for accessing your webhook endpoint.
     */
    'basic_auth_username': string;
    /**
     * Custom headers to be passed along with the request.
     */
    'custom_header'?: { [key: string]: string; };
    /**
     * Randomly chosen string used for implementing HMAC-SHA1. HMAC-SHA1 provides an added layer of security by authenticating the message and validating message integrity. Using this functionality requires that your webhook endpoint verify the message signature. For information about implementing this functionality, see <</developer-guides/signature-verification, Signature Verification>>.
     */
    'secret'?: string;
    /**
     * URL of your webhook endpoint.
     */
    'url': string;
    /**
     * Set to `true` to use use mutual transport layer security (mTLS) authentication for the webhook.  mTLS authentication is in the beta testing phase, and is not yet generally available. Contact your Marqeta representative for more information about using mTLS authentication.
     */
    'use_mtls'?: boolean;
}
/**
 * Contains information about a webhook event.
 */
export interface WebhookEventResendContainerResponse {
    /**
     * Event notification that was resent to your webhook endpoint.
     */
    'unused'?: string;
}
export interface WebhookPingModel {
    /**
     * Array of ping requests to your webhook endpoint.
     */
    'pings': Array<EchoPingRequest>;
}
export interface WebhookRequestModel {
    /**
     * Indicates whether the webhook is active.
     */
    'active'?: boolean;
    'config': WebhookConfigRequestModel;
    /**
     * Specifies the types of events for which notifications are sent.  The wildcard character `\\*` indicates that you receive all webhook notifications, or all notifications of a specified category. For example, `*` indicates that you receive all webhook notifications; `transaction.*` indicates that you receive all `transaction` webhook notifications.  *NOTE:* You can only use the wildcard character with the _base_ type events, not subcategories. For example, you cannot subscribe to `cardtransition.fulfillment.\\*` events, but you can subscribe to `cardtransition.*`.
     */
    'events': Array<string>;
    /**
     * Descriptive name of the webhook.
     */
    'name': string;
    /**
     * Unique identifier of the webhook.
     */
    'token'?: string;
}
export interface WebhookResponseModel {
    /**
     * Indicates whether the webhook is active. This field is returned if you included it in your webhook.
     */
    'active'?: boolean;
    'config': WebhookConfigResponseModel;
    /**
     * Date and time when the webhook event was created, in UTC.
     */
    'created_time'?: string;
    /**
     * Specifies the types of events for which notifications are sent.  The wildcard character `\\*` indicates that you receive all webhook notifications, or all notifications of a specified category. For example, `*` indicates that you receive all webhook notifications; `transaction.*` indicates that you receive all `transaction` webhook notifications.  *NOTE:* You can only use the wildcard character with the _base_ type events, not subcategories. For example, you cannot subscribe to `cardtransition.fulfillment.\\*` events, but you can subscribe to `cardtransition.*`.
     */
    'events': Array<string>;
    /**
     * Date and time when the associated object was last modified, in UTC.
     */
    'last_modified_time'?: string;
    /**
     * Descriptive name of the webhook.
     */
    'name': string;
    /**
     * Unique identifier of the webhook.
     */
    'token'?: string;
}
export interface WebhookResponseModelListResponse {
    /**
     * Number of resources to retrieve.  This field is returned if there are resources in your returned array.
     */
    'count'?: number;
    /**
     * Array of webhooks resources.  Resources are returned as appropriate to your query.
     */
    'data'?: Array<WebhookResponseModel>;
    /**
     * Sort order index of the last resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'end_index'?: number;
    /**
     * A value of `true` indicates that more unreturned resources exist. A value of `false` indicates that no more unreturned resources exist.  This field is returned if there are resources in your returned array.
     */
    'is_more'?: boolean;
    /**
     * Sort order index of the first resource in the returned array.  This field is returned if there are resources in your returned array.
     */
    'start_index'?: number;
}
export interface WebhookUpdateCustomHeaderRequest {
    /**
     * Additional custom information included in the HTTP header. For example, this might contain security information, along with Basic Authentication, when making a JIT Funding request.
     */
    'custom_header'?: { [key: string]: string; };
}
export interface WithdrawalRequestModel {
    'account_type'?: WithdrawalRequestModelAccountTypeEnum;
    'amount': number;
    'card_acceptor'?: CardAcceptorModel;
    'card_token': string;
    'mid': string;
    'pin'?: string;
    'webhook'?: Webhook;
}

export const WithdrawalRequestModelAccountTypeEnum = {
    Checking: 'checking',
    Savings: 'savings',
    Credit: 'credit'
} as const;

export type WithdrawalRequestModelAccountTypeEnum = typeof WithdrawalRequestModelAccountTypeEnum[keyof typeof WithdrawalRequestModelAccountTypeEnum];

/**
 * Contains details about a card tokenization push request.
 */
export interface XpayPushTokenizeRequestData {
    /**
     * Specifies the type of card.
     */
    'card_type'?: string;
    /**
     * Name of the card as displayed in the digital wallet, typically showing the card brand and last four digits of the primary account number (PAN). `Visa 5678`, for example.
     */
    'display_name'?: string;
    /**
     * Encrypted card or cardholder details.
     */
    'extra_provision_payload'?: string;
    /**
     * Last four digits of the primary account number of the physical or virtual card.
     */
    'last_digits'?: string;
    /**
     * Specifies the card network of the physical or virtual card.
     */
    'network'?: string;
    /**
     * Specifies the network that provides the digital wallet token service.
     */
    'token_service_provider'?: string;
}
/**
 * Contains information about year-to-date totals for an account.
 */
export interface YearToDate {
    /**
     * Unique identifier of the associated credit account.
     */
    'account_token': string;
    /**
     * Date and time when the year-to-date total was created on Marqeta\'s credit platform, in UTC.
     */
    'created_time'?: string;
    /**
     * Unique identifier of the statement summary from which to retrieve year-to-date totals.
     */
    'statement_token': string;
    /**
     * Unique identifier of the year-to-date total.
     */
    'token'?: string;
    /**
     * Total fees charged year-to-date.
     */
    'total_fees': number;
    /**
     * Total interest charged year-to-date.
     */
    'total_interest': number;
}

/**
 * AcceptedCountriesApi - axios parameter creator
 */
export const AcceptedCountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all accepted countries
         * @param {number} [count] Number of accepted countries to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [name] Name
         * @param {boolean} [whitelist] Whitelist
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountries: async (count?: number, startIndex?: number, name?: string, whitelist?: boolean, searchType?: string, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/acceptedcountries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (whitelist !== undefined) {
                localVarQueryParameter['whitelist'] = whitelist;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific accepted country
         * @param {string} token Accepted country token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountriesToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAcceptedcountriesToken', 'token', token)
            const localVarPath = `/acceptedcountries/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AcceptedCountriesApi - functional programming interface
 */
export const AcceptedCountriesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AcceptedCountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all accepted countries
         * @param {number} [count] Number of accepted countries to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [name] Name
         * @param {boolean} [whitelist] Whitelist
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAcceptedcountries(count?: number, startIndex?: number, name?: string, whitelist?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptedCountriesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAcceptedcountries(count, startIndex, name, whitelist, searchType, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AcceptedCountriesApi.getAcceptedcountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific accepted country
         * @param {string} token Accepted country token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAcceptedcountriesToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AcceptedCountriesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAcceptedcountriesToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AcceptedCountriesApi.getAcceptedcountriesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AcceptedCountriesApi - factory interface
 */
export const AcceptedCountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AcceptedCountriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all accepted countries
         * @param {number} [count] Number of accepted countries to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [name] Name
         * @param {boolean} [whitelist] Whitelist
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountries(count?: number, startIndex?: number, name?: string, whitelist?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<AcceptedCountriesListResponse> {
            return localVarFp.getAcceptedcountries(count, startIndex, name, whitelist, searchType, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific accepted country
         * @param {string} token Accepted country token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAcceptedcountriesToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<AcceptedCountriesModel> {
            return localVarFp.getAcceptedcountriesToken(token, fields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AcceptedCountriesApi - object-oriented interface
 */
export class AcceptedCountriesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all accepted countries
     * @param {number} [count] Number of accepted countries to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [name] Name
     * @param {boolean} [whitelist] Whitelist
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAcceptedcountries(count?: number, startIndex?: number, name?: string, whitelist?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return AcceptedCountriesApiFp(this.configuration).getAcceptedcountries(count, startIndex, name, whitelist, searchType, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific accepted country
     * @param {string} token Accepted country token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAcceptedcountriesToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return AcceptedCountriesApiFp(this.configuration).getAcceptedcountriesToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountApi - axios parameter creator
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all active and upcoming periodic fee schedules of an account
         * @summary Get all active and upcoming periodic fee schedules of an account
         * @param {string} accountToken account token
         * @param {number} [count] Number of periodic fee schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeriodicFeeSchedules: async (accountToken: string, count?: number, startIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getPeriodicFeeSchedules', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/periodicfeeschedules`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the billing cycle details for a specific account token.
         * @summary Get billing cycle by account token
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBillingCycleForAccount: async (accountToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveBillingCycleForAccount', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/billingcycle`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all active and upcoming periodic fee schedules of an account
         * @summary Get all active and upcoming periodic fee schedules of an account
         * @param {string} accountToken account token
         * @param {number} [count] Number of periodic fee schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeriodicFeeSchedules(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeriodicFeeSchedulePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeriodicFeeSchedules(accountToken, count, startIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.getPeriodicFeeSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the billing cycle details for a specific account token.
         * @summary Get billing cycle by account token
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBillingCycleForAccount(accountToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountBillingCycleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBillingCycleForAccount(accountToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.retrieveBillingCycleForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Get all active and upcoming periodic fee schedules of an account
         * @summary Get all active and upcoming periodic fee schedules of an account
         * @param {string} accountToken account token
         * @param {number} [count] Number of periodic fee schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeriodicFeeSchedules(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<PeriodicFeeSchedulePage> {
            return localVarFp.getPeriodicFeeSchedules(accountToken, count, startIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the billing cycle details for a specific account token.
         * @summary Get billing cycle by account token
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBillingCycleForAccount(accountToken: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountBillingCycleResponse> {
            return localVarFp.retrieveBillingCycleForAccount(accountToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * Get all active and upcoming periodic fee schedules of an account
     * @summary Get all active and upcoming periodic fee schedules of an account
     * @param {string} accountToken account token
     * @param {number} [count] Number of periodic fee schedule resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPeriodicFeeSchedules(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).getPeriodicFeeSchedules(accountToken, count, startIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the billing cycle details for a specific account token.
     * @summary Get billing cycle by account token
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveBillingCycleForAccount(accountToken: string, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).retrieveBillingCycleForAccount(accountToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountCardsApi - axios parameter creator
 */
export const AccountCardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a credit card for an existing credit account.  [NOTE] You can ship cards to an address different from the <</core-api/users, user>> address. After creating a card, send a `PUT` request to the `/cards` endpoint with the new address in the `fulfillment.shipping` object. For more, see <</core-api/cards#putCardsToken, Update card>>.
         * @summary Create account card
         * @param {string} accountToken Unique identifier of the credit account for which to create a credit card.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {object} body Expected request body to create a credit card for an existing credit account. Refer to &lt;&lt;/core-api/cards/#postCards,Create card&gt;&gt; for the complete list of fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCardForAccount: async (accountToken: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createCardForAccount', 'accountToken', accountToken)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createCardForAccount', 'body', body)
            const localVarPath = `/accounts/{account_token}/cards`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a credit card for a credit account.
         * @summary Retrieve account card
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a credit card.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} cardToken Unique identifier of the credit card to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/cards&#x60; to retrieve existing credit card tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardByAccount: async (accountToken: string, cardToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getCardByAccount', 'accountToken', accountToken)
            // verify required parameter 'cardToken' is not null or undefined
            assertParamExists('getCardByAccount', 'cardToken', cardToken)
            const localVarPath = `/accounts/{account_token}/cards/{card_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"card_token"}}`, encodeURIComponent(String(cardToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of cards for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account cards
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve credit cards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [status] Status of the credit cards to retrieve.
         * @param {number} [count] Number of credit card resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetCardsByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsByAccount: async (accountToken: string, status?: string, count?: number, startIndex?: number, sortBy?: GetCardsByAccountSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getCardsByAccount', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/cards`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountCardsApi - functional programming interface
 */
export const AccountCardsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountCardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a credit card for an existing credit account.  [NOTE] You can ship cards to an address different from the <</core-api/users, user>> address. After creating a card, send a `PUT` request to the `/cards` endpoint with the new address in the `fulfillment.shipping` object. For more, see <</core-api/cards#putCardsToken, Update card>>.
         * @summary Create account card
         * @param {string} accountToken Unique identifier of the credit account for which to create a credit card.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {object} body Expected request body to create a credit card for an existing credit account. Refer to &lt;&lt;/core-api/cards/#postCards,Create card&gt;&gt; for the complete list of fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCardForAccount(accountToken: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCardForAccount(accountToken, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountCardsApi.createCardForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a credit card for a credit account.
         * @summary Retrieve account card
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a credit card.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} cardToken Unique identifier of the credit card to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/cards&#x60; to retrieve existing credit card tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardByAccount(accountToken: string, cardToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardByAccount(accountToken, cardToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountCardsApi.getCardByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of cards for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account cards
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve credit cards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [status] Status of the credit cards to retrieve.
         * @param {number} [count] Number of credit card resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetCardsByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardsByAccount(accountToken: string, status?: string, count?: number, startIndex?: number, sortBy?: GetCardsByAccountSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCardsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardsByAccount(accountToken, status, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountCardsApi.getCardsByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountCardsApi - factory interface
 */
export const AccountCardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountCardsApiFp(configuration)
    return {
        /**
         * Create a credit card for an existing credit account.  [NOTE] You can ship cards to an address different from the <</core-api/users, user>> address. After creating a card, send a `PUT` request to the `/cards` endpoint with the new address in the `fulfillment.shipping` object. For more, see <</core-api/cards#putCardsToken, Update card>>.
         * @summary Create account card
         * @param {string} accountToken Unique identifier of the credit account for which to create a credit card.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {object} body Expected request body to create a credit card for an existing credit account. Refer to &lt;&lt;/core-api/cards/#postCards,Create card&gt;&gt; for the complete list of fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCardForAccount(accountToken: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.createCardForAccount(accountToken, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a credit card for a credit account.
         * @summary Retrieve account card
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a credit card.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} cardToken Unique identifier of the credit card to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/cards&#x60; to retrieve existing credit card tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardByAccount(accountToken: string, cardToken: string, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.getCardByAccount(accountToken, cardToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of cards for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account cards
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve credit cards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [status] Status of the credit cards to retrieve.
         * @param {number} [count] Number of credit card resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetCardsByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsByAccount(accountToken: string, status?: string, count?: number, startIndex?: number, sortBy?: GetCardsByAccountSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<AccountCardsPage> {
            return localVarFp.getCardsByAccount(accountToken, status, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountCardsApi - object-oriented interface
 */
export class AccountCardsApi extends BaseAPI {
    /**
     * Create a credit card for an existing credit account.  [NOTE] You can ship cards to an address different from the <</core-api/users, user>> address. After creating a card, send a `PUT` request to the `/cards` endpoint with the new address in the `fulfillment.shipping` object. For more, see <</core-api/cards#putCardsToken, Update card>>.
     * @summary Create account card
     * @param {string} accountToken Unique identifier of the credit account for which to create a credit card.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {object} body Expected request body to create a credit card for an existing credit account. Refer to &lt;&lt;/core-api/cards/#postCards,Create card&gt;&gt; for the complete list of fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCardForAccount(accountToken: string, body: object, options?: RawAxiosRequestConfig) {
        return AccountCardsApiFp(this.configuration).createCardForAccount(accountToken, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a credit card for a credit account.
     * @summary Retrieve account card
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve a credit card.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} cardToken Unique identifier of the credit card to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/cards&#x60; to retrieve existing credit card tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardByAccount(accountToken: string, cardToken: string, options?: RawAxiosRequestConfig) {
        return AccountCardsApiFp(this.configuration).getCardByAccount(accountToken, cardToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of cards for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List account cards
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve credit cards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} [status] Status of the credit cards to retrieve.
     * @param {number} [count] Number of credit card resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetCardsByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardsByAccount(accountToken: string, status?: string, count?: number, startIndex?: number, sortBy?: GetCardsByAccountSortByEnum, options?: RawAxiosRequestConfig) {
        return AccountCardsApiFp(this.configuration).getCardsByAccount(accountToken, status, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetCardsByAccountSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type GetCardsByAccountSortByEnum = typeof GetCardsByAccountSortByEnum[keyof typeof GetCardsByAccountSortByEnum];


/**
 * AccountDocumentsApi - axios parameter creator
 */
export const AccountDocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an array of documents on a credit account.
         * @summary List documents
         * @param {string} accountToken Unique identifier of the credit account for which you want to get documents.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDocuments: async (accountToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getAccountDocuments', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/documents`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific type of document on a credit account.
         * @summary Retrieve document
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a specific type of document.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAndDocumentAssetType} documentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentByAccountAndType: async (accountToken: string, documentType: AccountAndDocumentAssetType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getDocumentByAccountAndType', 'accountToken', accountToken)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('getDocumentByAccountAndType', 'documentType', documentType)
            const localVarPath = `/accounts/{account_token}/documents/{document_type}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"document_type"}}`, encodeURIComponent(String(documentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the history of a specific type of document on a credit account.
         * @summary Retrieve document history
         * @param {string} accountToken Unique identifier of the credit account for which to get document history.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAndDocumentAssetType} documentType 
         * @param {number} [count] Number of account document resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetDocumentHistoryByAccountAndTypeSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentHistoryByAccountAndType: async (accountToken: string, documentType: AccountAndDocumentAssetType, count?: number, startIndex?: number, sortBy?: GetDocumentHistoryByAccountAndTypeSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getDocumentHistoryByAccountAndType', 'accountToken', accountToken)
            // verify required parameter 'documentType' is not null or undefined
            assertParamExists('getDocumentHistoryByAccountAndType', 'documentType', documentType)
            const localVarPath = `/accounts/{account_token}/documents/{document_type}/history`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"document_type"}}`, encodeURIComponent(String(documentType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountDocumentsApi - functional programming interface
 */
export const AccountDocumentsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountDocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an array of documents on a credit account.
         * @summary List documents
         * @param {string} accountToken Unique identifier of the credit account for which you want to get documents.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountDocuments(accountToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDocumentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountDocuments(accountToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDocumentsApi.getAccountDocuments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific type of document on a credit account.
         * @summary Retrieve document
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a specific type of document.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAndDocumentAssetType} documentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentByAccountAndType(accountToken: string, documentType: AccountAndDocumentAssetType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentByAccountAndType(accountToken, documentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDocumentsApi.getDocumentByAccountAndType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the history of a specific type of document on a credit account.
         * @summary Retrieve document history
         * @param {string} accountToken Unique identifier of the credit account for which to get document history.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAndDocumentAssetType} documentType 
         * @param {number} [count] Number of account document resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetDocumentHistoryByAccountAndTypeSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentHistoryByAccountAndType(accountToken: string, documentType: AccountAndDocumentAssetType, count?: number, startIndex?: number, sortBy?: GetDocumentHistoryByAccountAndTypeSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDocumentsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentHistoryByAccountAndType(accountToken, documentType, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDocumentsApi.getDocumentHistoryByAccountAndType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountDocumentsApi - factory interface
 */
export const AccountDocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountDocumentsApiFp(configuration)
    return {
        /**
         * Retrieve an array of documents on a credit account.
         * @summary List documents
         * @param {string} accountToken Unique identifier of the credit account for which you want to get documents.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDocuments(accountToken: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountDocumentsResponse> {
            return localVarFp.getAccountDocuments(accountToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific type of document on a credit account.
         * @summary Retrieve document
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a specific type of document.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAndDocumentAssetType} documentType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentByAccountAndType(accountToken: string, documentType: AccountAndDocumentAssetType, options?: RawAxiosRequestConfig): AxiosPromise<AccountDocumentResponse> {
            return localVarFp.getDocumentByAccountAndType(accountToken, documentType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the history of a specific type of document on a credit account.
         * @summary Retrieve document history
         * @param {string} accountToken Unique identifier of the credit account for which to get document history.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAndDocumentAssetType} documentType 
         * @param {number} [count] Number of account document resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetDocumentHistoryByAccountAndTypeSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentHistoryByAccountAndType(accountToken: string, documentType: AccountAndDocumentAssetType, count?: number, startIndex?: number, sortBy?: GetDocumentHistoryByAccountAndTypeSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<AccountDocumentsPage> {
            return localVarFp.getDocumentHistoryByAccountAndType(accountToken, documentType, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountDocumentsApi - object-oriented interface
 */
export class AccountDocumentsApi extends BaseAPI {
    /**
     * Retrieve an array of documents on a credit account.
     * @summary List documents
     * @param {string} accountToken Unique identifier of the credit account for which you want to get documents.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountDocuments(accountToken: string, options?: RawAxiosRequestConfig) {
        return AccountDocumentsApiFp(this.configuration).getAccountDocuments(accountToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific type of document on a credit account.
     * @summary Retrieve document
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve a specific type of document.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {AccountAndDocumentAssetType} documentType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDocumentByAccountAndType(accountToken: string, documentType: AccountAndDocumentAssetType, options?: RawAxiosRequestConfig) {
        return AccountDocumentsApiFp(this.configuration).getDocumentByAccountAndType(accountToken, documentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the history of a specific type of document on a credit account.
     * @summary Retrieve document history
     * @param {string} accountToken Unique identifier of the credit account for which to get document history.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {AccountAndDocumentAssetType} documentType 
     * @param {number} [count] Number of account document resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetDocumentHistoryByAccountAndTypeSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDocumentHistoryByAccountAndType(accountToken: string, documentType: AccountAndDocumentAssetType, count?: number, startIndex?: number, sortBy?: GetDocumentHistoryByAccountAndTypeSortByEnum, options?: RawAxiosRequestConfig) {
        return AccountDocumentsApiFp(this.configuration).getDocumentHistoryByAccountAndType(accountToken, documentType, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetDocumentHistoryByAccountAndTypeSortByEnum = {
    EffectiveDate: 'effectiveDate',
    EffectiveDate2: '-effectiveDate'
} as const;
export type GetDocumentHistoryByAccountAndTypeSortByEnum = typeof GetDocumentHistoryByAccountAndTypeSortByEnum[keyof typeof GetDocumentHistoryByAccountAndTypeSortByEnum];


/**
 * AccountHolderGroupsApi - axios parameter creator
 */
export const AccountHolderGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists account holder groups
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroups: async (count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accountholdergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific account holder group object
         * @param {string} token Account holder group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroupsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAccountholdergroupsToken', 'token', token)
            const localVarPath = `/accountholdergroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an account holder group object
         * @param {AccountHolderGroupRequest} accountHolderGroupRequest Account holder group object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountholdergroups: async (accountHolderGroupRequest: AccountHolderGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountHolderGroupRequest' is not null or undefined
            assertParamExists('postAccountholdergroups', 'accountHolderGroupRequest', accountHolderGroupRequest)
            const localVarPath = `/accountholdergroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(accountHolderGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an account holder group object
         * @param {string} token 
         * @param {AccountHolderGroupUpdateRequest} accountHolderGroupUpdateRequest Account holder group update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccountholdergroupsToken: async (token: string, accountHolderGroupUpdateRequest: AccountHolderGroupUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putAccountholdergroupsToken', 'token', token)
            // verify required parameter 'accountHolderGroupUpdateRequest' is not null or undefined
            assertParamExists('putAccountholdergroupsToken', 'accountHolderGroupUpdateRequest', accountHolderGroupUpdateRequest)
            const localVarPath = `/accountholdergroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(accountHolderGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountHolderGroupsApi - functional programming interface
 */
export const AccountHolderGroupsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountHolderGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists account holder groups
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountholdergroups(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountHolderGroupListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountholdergroups(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountHolderGroupsApi.getAccountholdergroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific account holder group object
         * @param {string} token Account holder group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountholdergroupsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountHolderGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountholdergroupsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountHolderGroupsApi.getAccountholdergroupsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an account holder group object
         * @param {AccountHolderGroupRequest} accountHolderGroupRequest Account holder group object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccountholdergroups(accountHolderGroupRequest: AccountHolderGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountHolderGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccountholdergroups(accountHolderGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountHolderGroupsApi.postAccountholdergroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an account holder group object
         * @param {string} token 
         * @param {AccountHolderGroupUpdateRequest} accountHolderGroupUpdateRequest Account holder group update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAccountholdergroupsToken(token: string, accountHolderGroupUpdateRequest: AccountHolderGroupUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountHolderGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAccountholdergroupsToken(token, accountHolderGroupUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountHolderGroupsApi.putAccountholdergroupsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountHolderGroupsApi - factory interface
 */
export const AccountHolderGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountHolderGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists account holder groups
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroups(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountHolderGroupListResponse> {
            return localVarFp.getAccountholdergroups(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific account holder group object
         * @param {string} token Account holder group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountholdergroupsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountHolderGroupResponse> {
            return localVarFp.getAccountholdergroupsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an account holder group object
         * @param {AccountHolderGroupRequest} accountHolderGroupRequest Account holder group object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountholdergroups(accountHolderGroupRequest: AccountHolderGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountHolderGroupResponse> {
            return localVarFp.postAccountholdergroups(accountHolderGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an account holder group object
         * @param {string} token 
         * @param {AccountHolderGroupUpdateRequest} accountHolderGroupUpdateRequest Account holder group update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccountholdergroupsToken(token: string, accountHolderGroupUpdateRequest: AccountHolderGroupUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AccountHolderGroupResponse> {
            return localVarFp.putAccountholdergroupsToken(token, accountHolderGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountHolderGroupsApi - object-oriented interface
 */
export class AccountHolderGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Lists account holder groups
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountholdergroups(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return AccountHolderGroupsApiFp(this.configuration).getAccountholdergroups(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific account holder group object
     * @param {string} token Account holder group token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountholdergroupsToken(token: string, options?: RawAxiosRequestConfig) {
        return AccountHolderGroupsApiFp(this.configuration).getAccountholdergroupsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an account holder group object
     * @param {AccountHolderGroupRequest} accountHolderGroupRequest Account holder group object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postAccountholdergroups(accountHolderGroupRequest: AccountHolderGroupRequest, options?: RawAxiosRequestConfig) {
        return AccountHolderGroupsApiFp(this.configuration).postAccountholdergroups(accountHolderGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an account holder group object
     * @param {string} token 
     * @param {AccountHolderGroupUpdateRequest} accountHolderGroupUpdateRequest Account holder group update object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putAccountholdergroupsToken(token: string, accountHolderGroupUpdateRequest: AccountHolderGroupUpdateRequest, options?: RawAxiosRequestConfig) {
        return AccountHolderGroupsApiFp(this.configuration).putAccountholdergroupsToken(token, accountHolderGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountRefundsApi - axios parameter creator
 */
export const AccountRefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new refund, which you can issue to the account holder if their credit account balance is negative.
         * @summary Create refund
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {RefundCreateRequest} refundCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund: async (accountToken: string, refundCreateRequest: RefundCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createRefund', 'accountToken', accountToken)
            // verify required parameter 'refundCreateRequest' is not null or undefined
            assertParamExists('createRefund', 'refundCreateRequest', refundCreateRequest)
            const localVarPath = `/accounts/{account_token}/refunds`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(refundCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the `/credit/accounts/{account_token}/refunds` endpoint to retrieve an array of refunds on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account refunds
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve refunds.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Beginning of the date range of the refunds to return.
         * @param {string} [endDate] End of the date range of the refunds to return.
         * @param {number} [count] Number of account refund resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRefundsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order. Only supports &#x60;lastModifiedTime&#x60; and &#x60;-lastModifiedTime&#x60;.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;updated_time&#x60;.
         * @param {Array<RefundStatus>} [statuses] Array of statuses by which to filter refunds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds: async (accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: ListRefundsSortByEnum, statuses?: Array<RefundStatus>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('listRefunds', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/refunds`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0, 10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0, 10) :
                    endDate;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the `/accounts/{account_token}/refunds/{refund_token}` endpoint to retrieve a refund.
         * @summary Retrieve account refund
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds/{refund_token}&#x60; to retrieve existing refunds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRefund: async (accountToken: string, refundToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveRefund', 'accountToken', accountToken)
            // verify required parameter 'refundToken' is not null or undefined
            assertParamExists('retrieveRefund', 'refundToken', refundToken)
            const localVarPath = `/accounts/{account_token}/refunds/{refund_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"refund_token"}}`, encodeURIComponent(String(refundToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the `/accounts/{account_token}/refunds/{refund_token}/transitions` endpoint to transition a credit account refund\'s status to a new status.
         * @summary Transition account refund status
         * @param {string} accountToken Unique identifier of the credit account for which you want to transition a refund status. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund whose status you want to transition. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds&#x60; endpoint to retrieve existing refund tokens for a given account.
         * @param {RefundTransitionRequest} refundTransitionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionRefund: async (accountToken: string, refundToken: string, refundTransitionRequest: RefundTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('transitionRefund', 'accountToken', accountToken)
            // verify required parameter 'refundToken' is not null or undefined
            assertParamExists('transitionRefund', 'refundToken', refundToken)
            // verify required parameter 'refundTransitionRequest' is not null or undefined
            assertParamExists('transitionRefund', 'refundTransitionRequest', refundTransitionRequest)
            const localVarPath = `/accounts/{account_token}/refunds/{refund_token}/transitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"refund_token"}}`, encodeURIComponent(String(refundToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(refundTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountRefundsApi - functional programming interface
 */
export const AccountRefundsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountRefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new refund, which you can issue to the account holder if their credit account balance is negative.
         * @summary Create refund
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {RefundCreateRequest} refundCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRefund(accountToken: string, refundCreateRequest: RefundCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRefund(accountToken, refundCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountRefundsApi.createRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use the `/credit/accounts/{account_token}/refunds` endpoint to retrieve an array of refunds on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account refunds
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve refunds.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Beginning of the date range of the refunds to return.
         * @param {string} [endDate] End of the date range of the refunds to return.
         * @param {number} [count] Number of account refund resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRefundsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order. Only supports &#x60;lastModifiedTime&#x60; and &#x60;-lastModifiedTime&#x60;.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;updated_time&#x60;.
         * @param {Array<RefundStatus>} [statuses] Array of statuses by which to filter refunds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRefunds(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: ListRefundsSortByEnum, statuses?: Array<RefundStatus>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRefunds(accountToken, startDate, endDate, count, startIndex, sortBy, statuses, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountRefundsApi.listRefunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use the `/accounts/{account_token}/refunds/{refund_token}` endpoint to retrieve a refund.
         * @summary Retrieve account refund
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds/{refund_token}&#x60; to retrieve existing refunds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRefund(accountToken: string, refundToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRefund(accountToken, refundToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountRefundsApi.retrieveRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use the `/accounts/{account_token}/refunds/{refund_token}/transitions` endpoint to transition a credit account refund\'s status to a new status.
         * @summary Transition account refund status
         * @param {string} accountToken Unique identifier of the credit account for which you want to transition a refund status. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund whose status you want to transition. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds&#x60; endpoint to retrieve existing refund tokens for a given account.
         * @param {RefundTransitionRequest} refundTransitionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionRefund(accountToken: string, refundToken: string, refundTransitionRequest: RefundTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionRefund(accountToken, refundToken, refundTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountRefundsApi.transitionRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountRefundsApi - factory interface
 */
export const AccountRefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountRefundsApiFp(configuration)
    return {
        /**
         * Create a new refund, which you can issue to the account holder if their credit account balance is negative.
         * @summary Create refund
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {RefundCreateRequest} refundCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund(accountToken: string, refundCreateRequest: RefundCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefundResponse> {
            return localVarFp.createRefund(accountToken, refundCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use the `/credit/accounts/{account_token}/refunds` endpoint to retrieve an array of refunds on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account refunds
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve refunds.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Beginning of the date range of the refunds to return.
         * @param {string} [endDate] End of the date range of the refunds to return.
         * @param {number} [count] Number of account refund resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRefundsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order. Only supports &#x60;lastModifiedTime&#x60; and &#x60;-lastModifiedTime&#x60;.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;updated_time&#x60;.
         * @param {Array<RefundStatus>} [statuses] Array of statuses by which to filter refunds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRefunds(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: ListRefundsSortByEnum, statuses?: Array<RefundStatus>, options?: RawAxiosRequestConfig): AxiosPromise<RefundsPage> {
            return localVarFp.listRefunds(accountToken, startDate, endDate, count, startIndex, sortBy, statuses, options).then((request) => request(axios, basePath));
        },
        /**
         * Use the `/accounts/{account_token}/refunds/{refund_token}` endpoint to retrieve a refund.
         * @summary Retrieve account refund
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds/{refund_token}&#x60; to retrieve existing refunds.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRefund(accountToken: string, refundToken: string, options?: RawAxiosRequestConfig): AxiosPromise<RefundResponse> {
            return localVarFp.retrieveRefund(accountToken, refundToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Use the `/accounts/{account_token}/refunds/{refund_token}/transitions` endpoint to transition a credit account refund\'s status to a new status.
         * @summary Transition account refund status
         * @param {string} accountToken Unique identifier of the credit account for which you want to transition a refund status. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund whose status you want to transition. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds&#x60; endpoint to retrieve existing refund tokens for a given account.
         * @param {RefundTransitionRequest} refundTransitionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionRefund(accountToken: string, refundToken: string, refundTransitionRequest: RefundTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefundResponse> {
            return localVarFp.transitionRefund(accountToken, refundToken, refundTransitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountRefundsApi - object-oriented interface
 */
export class AccountRefundsApi extends BaseAPI {
    /**
     * Create a new refund, which you can issue to the account holder if their credit account balance is negative.
     * @summary Create refund
     * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {RefundCreateRequest} refundCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRefund(accountToken: string, refundCreateRequest: RefundCreateRequest, options?: RawAxiosRequestConfig) {
        return AccountRefundsApiFp(this.configuration).createRefund(accountToken, refundCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use the `/credit/accounts/{account_token}/refunds` endpoint to retrieve an array of refunds on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List account refunds
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve refunds.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} [startDate] Beginning of the date range of the refunds to return.
     * @param {string} [endDate] End of the date range of the refunds to return.
     * @param {number} [count] Number of account refund resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListRefundsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order. Only supports &#x60;lastModifiedTime&#x60; and &#x60;-lastModifiedTime&#x60;.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;updated_time&#x60;.
     * @param {Array<RefundStatus>} [statuses] Array of statuses by which to filter refunds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRefunds(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: ListRefundsSortByEnum, statuses?: Array<RefundStatus>, options?: RawAxiosRequestConfig) {
        return AccountRefundsApiFp(this.configuration).listRefunds(accountToken, startDate, endDate, count, startIndex, sortBy, statuses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use the `/accounts/{account_token}/refunds/{refund_token}` endpoint to retrieve a refund.
     * @summary Retrieve account refund
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve a refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} refundToken Unique identifier of the refund to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds/{refund_token}&#x60; to retrieve existing refunds.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveRefund(accountToken: string, refundToken: string, options?: RawAxiosRequestConfig) {
        return AccountRefundsApiFp(this.configuration).retrieveRefund(accountToken, refundToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use the `/accounts/{account_token}/refunds/{refund_token}/transitions` endpoint to transition a credit account refund\'s status to a new status.
     * @summary Transition account refund status
     * @param {string} accountToken Unique identifier of the credit account for which you want to transition a refund status. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} refundToken Unique identifier of the refund whose status you want to transition. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds&#x60; endpoint to retrieve existing refund tokens for a given account.
     * @param {RefundTransitionRequest} refundTransitionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transitionRefund(accountToken: string, refundToken: string, refundTransitionRequest: RefundTransitionRequest, options?: RawAxiosRequestConfig) {
        return AccountRefundsApiFp(this.configuration).transitionRefund(accountToken, refundToken, refundTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListRefundsSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListRefundsSortByEnum = typeof ListRefundsSortByEnum[keyof typeof ListRefundsSortByEnum];


/**
 * AccountRewardsApi - axios parameter creator
 */
export const AccountRewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a reward for an existing credit account.
         * @summary Create account reward
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a reward.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {RewardCreateReq} rewardCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReward: async (accountToken: string, rewardCreateReq: RewardCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createReward', 'accountToken', accountToken)
            // verify required parameter 'rewardCreateReq' is not null or undefined
            assertParamExists('createReward', 'rewardCreateReq', rewardCreateReq)
            const localVarPath = `/accounts/{account_token}/rewards`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(rewardCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountRewardsApi - functional programming interface
 */
export const AccountRewardsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountRewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a reward for an existing credit account.
         * @summary Create account reward
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a reward.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {RewardCreateReq} rewardCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReward(accountToken: string, rewardCreateReq: RewardCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReward(accountToken, rewardCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountRewardsApi.createReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountRewardsApi - factory interface
 */
export const AccountRewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountRewardsApiFp(configuration)
    return {
        /**
         * Create a reward for an existing credit account.
         * @summary Create account reward
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a reward.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {RewardCreateReq} rewardCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReward(accountToken: string, rewardCreateReq: RewardCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<RewardResponse> {
            return localVarFp.createReward(accountToken, rewardCreateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountRewardsApi - object-oriented interface
 */
export class AccountRewardsApi extends BaseAPI {
    /**
     * Create a reward for an existing credit account.
     * @summary Create account reward
     * @param {string} accountToken Unique identifier of the credit account for which you want to create a reward.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {RewardCreateReq} rewardCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createReward(accountToken: string, rewardCreateReq: RewardCreateReq, options?: RawAxiosRequestConfig) {
        return AccountRewardsApiFp(this.configuration).createReward(accountToken, rewardCreateReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountSignupBonusApi - axios parameter creator
 */
export const AccountSignupBonusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent: async (eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('resendWebhookEvent', 'eventType', eventType)
            // verify required parameter 'resourceToken' is not null or undefined
            assertParamExists('resendWebhookEvent', 'resourceToken', resourceToken)
            const localVarPath = `/webhooks/{event_type}/{resource_token}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"resource_token"}}`, encodeURIComponent(String(resourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountSignupBonusApi - functional programming interface
 */
export const AccountSignupBonusApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountSignupBonusApiAxiosParamCreator(configuration)
    return {
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResendContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhookEvent(eventType, resourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSignupBonusApi.resendWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountSignupBonusApi - factory interface
 */
export const AccountSignupBonusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountSignupBonusApiFp(configuration)
    return {
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResendContainerResponse> {
            return localVarFp.resendWebhookEvent(eventType, resourceToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountSignupBonusApi - object-oriented interface
 */
export class AccountSignupBonusApi extends BaseAPI {
    /**
     * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
     * @summary Resend credit event notification
     * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig) {
        return AccountSignupBonusApiFp(this.configuration).resendWebhookEvent(eventType, resourceToken, options).then((request) => request(this.axios, this.basePath));
    }
}




/**
 * AccountTransitionsApi - axios parameter creator
 */
export const AccountTransitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a transition for a credit account.
         * @summary Retrieve account transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} token Unique identifier of the account transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransition: async (accountToken: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getAccountTransition', 'accountToken', accountToken)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAccountTransition', 'token', token)
            const localVarPath = `/accounts/{account_token}/accounttransitions/{token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of transitions on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account transitions
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account transition resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListAccountTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountTransitions: async (accountToken: string, count?: number, startIndex?: number, sortBy?: ListAccountTransitionsSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('listAccountTransitions', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/accounttransitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent: async (eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('resendWebhookEvent', 'eventType', eventType)
            // verify required parameter 'resourceToken' is not null or undefined
            assertParamExists('resendWebhookEvent', 'resourceToken', resourceToken)
            const localVarPath = `/webhooks/{event_type}/{resource_token}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"resource_token"}}`, encodeURIComponent(String(resourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transition a credit account to a new status.
         * @summary Transition account status
         * @param {string} accountToken Unique identifier of the credit account for which to transition a status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountTransitionReq} accountTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionAccount: async (accountToken: string, accountTransitionReq: AccountTransitionReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('transitionAccount', 'accountToken', accountToken)
            // verify required parameter 'accountTransitionReq' is not null or undefined
            assertParamExists('transitionAccount', 'accountTransitionReq', accountTransitionReq)
            const localVarPath = `/accounts/{account_token}/accounttransitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(accountTransitionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountTransitionsApi - functional programming interface
 */
export const AccountTransitionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountTransitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a transition for a credit account.
         * @summary Retrieve account transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} token Unique identifier of the account transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransition(accountToken: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransition(accountToken, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountTransitionsApi.getAccountTransition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of transitions on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account transitions
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account transition resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListAccountTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountTransitions(accountToken: string, count?: number, startIndex?: number, sortBy?: ListAccountTransitionsSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTransitionsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountTransitions(accountToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountTransitionsApi.listAccountTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResendContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhookEvent(eventType, resourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountTransitionsApi.resendWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transition a credit account to a new status.
         * @summary Transition account status
         * @param {string} accountToken Unique identifier of the credit account for which to transition a status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountTransitionReq} accountTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionAccount(accountToken: string, accountTransitionReq: AccountTransitionReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionAccount(accountToken, accountTransitionReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountTransitionsApi.transitionAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountTransitionsApi - factory interface
 */
export const AccountTransitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountTransitionsApiFp(configuration)
    return {
        /**
         * Retrieve a transition for a credit account.
         * @summary Retrieve account transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} token Unique identifier of the account transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransition(accountToken: string, token: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountTransitionResponse> {
            return localVarFp.getAccountTransition(accountToken, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of transitions on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account transitions
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account transition resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListAccountTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountTransitions(accountToken: string, count?: number, startIndex?: number, sortBy?: ListAccountTransitionsSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<AccountTransitionsPage> {
            return localVarFp.listAccountTransitions(accountToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResendContainerResponse> {
            return localVarFp.resendWebhookEvent(eventType, resourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Transition a credit account to a new status.
         * @summary Transition account status
         * @param {string} accountToken Unique identifier of the credit account for which to transition a status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountTransitionReq} accountTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionAccount(accountToken: string, accountTransitionReq: AccountTransitionReq, options?: RawAxiosRequestConfig): AxiosPromise<AccountTransitionResponse> {
            return localVarFp.transitionAccount(accountToken, accountTransitionReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountTransitionsApi - object-oriented interface
 */
export class AccountTransitionsApi extends BaseAPI {
    /**
     * Retrieve a transition for a credit account.
     * @summary Retrieve account transition
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} token Unique identifier of the account transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountTransition(accountToken: string, token: string, options?: RawAxiosRequestConfig) {
        return AccountTransitionsApiFp(this.configuration).getAccountTransition(accountToken, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of transitions on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List account transitions
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {number} [count] Number of account transition resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListAccountTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAccountTransitions(accountToken: string, count?: number, startIndex?: number, sortBy?: ListAccountTransitionsSortByEnum, options?: RawAxiosRequestConfig) {
        return AccountTransitionsApiFp(this.configuration).listAccountTransitions(accountToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
     * @summary Resend credit event notification
     * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig) {
        return AccountTransitionsApiFp(this.configuration).resendWebhookEvent(eventType, resourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transition a credit account to a new status.
     * @summary Transition account status
     * @param {string} accountToken Unique identifier of the credit account for which to transition a status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {AccountTransitionReq} accountTransitionReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transitionAccount(accountToken: string, accountTransitionReq: AccountTransitionReq, options?: RawAxiosRequestConfig) {
        return AccountTransitionsApiFp(this.configuration).transitionAccount(accountToken, accountTransitionReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListAccountTransitionsSortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime'
} as const;
export type ListAccountTransitionsSortByEnum = typeof ListAccountTransitionsSortByEnum[keyof typeof ListAccountTransitionsSortByEnum];



/**
 * AdjustmentsApi - axios parameter creator
 */
export const AdjustmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an adjustment for an existing credit account.
         * @summary Create account adjustment
         * @param {string} accountToken Unique identifier of the credit account for which you want to create an adjustment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAdjustmentReq} accountAdjustmentReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdjustmentForAccount: async (accountToken: string, accountAdjustmentReq: AccountAdjustmentReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createAdjustmentForAccount', 'accountToken', accountToken)
            // verify required parameter 'accountAdjustmentReq' is not null or undefined
            assertParamExists('createAdjustmentForAccount', 'accountAdjustmentReq', accountAdjustmentReq)
            const localVarPath = `/accounts/{account_token}/adjustments`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(accountAdjustmentReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of adjustments for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List account adjustments
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve adjustments.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account adjustment resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdjustmentsByAccount: async (accountToken: string, count?: number, startIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getAdjustmentsByAccount', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/adjustments`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an adjustment for a credit account.
         * @summary Retrieve account adjustment
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve an adjustment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} adjustmentToken Unique identifier of the adjustment to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/adjustments&#x60; to retrieve existing account adjustment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAdjustment: async (accountToken: string, adjustmentToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveAdjustment', 'accountToken', accountToken)
            // verify required parameter 'adjustmentToken' is not null or undefined
            assertParamExists('retrieveAdjustment', 'adjustmentToken', adjustmentToken)
            const localVarPath = `/accounts/{account_token}/adjustments/{adjustment_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"adjustment_token"}}`, encodeURIComponent(String(adjustmentToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdjustmentsApi - functional programming interface
 */
export const AdjustmentsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AdjustmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an adjustment for an existing credit account.
         * @summary Create account adjustment
         * @param {string} accountToken Unique identifier of the credit account for which you want to create an adjustment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAdjustmentReq} accountAdjustmentReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdjustmentForAccount(accountToken: string, accountAdjustmentReq: AccountAdjustmentReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAdjustmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAdjustmentForAccount(accountToken, accountAdjustmentReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdjustmentsApi.createAdjustmentForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of adjustments for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List account adjustments
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve adjustments.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account adjustment resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdjustmentsByAccount(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAdjustmentPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdjustmentsByAccount(accountToken, count, startIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdjustmentsApi.getAdjustmentsByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an adjustment for a credit account.
         * @summary Retrieve account adjustment
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve an adjustment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} adjustmentToken Unique identifier of the adjustment to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/adjustments&#x60; to retrieve existing account adjustment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAdjustment(accountToken: string, adjustmentToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountAdjustmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAdjustment(accountToken, adjustmentToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdjustmentsApi.retrieveAdjustment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdjustmentsApi - factory interface
 */
export const AdjustmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdjustmentsApiFp(configuration)
    return {
        /**
         * Create an adjustment for an existing credit account.
         * @summary Create account adjustment
         * @param {string} accountToken Unique identifier of the credit account for which you want to create an adjustment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountAdjustmentReq} accountAdjustmentReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdjustmentForAccount(accountToken: string, accountAdjustmentReq: AccountAdjustmentReq, options?: RawAxiosRequestConfig): AxiosPromise<AccountAdjustmentResponse> {
            return localVarFp.createAdjustmentForAccount(accountToken, accountAdjustmentReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of adjustments for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List account adjustments
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve adjustments.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account adjustment resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdjustmentsByAccount(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<AccountAdjustmentPage> {
            return localVarFp.getAdjustmentsByAccount(accountToken, count, startIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an adjustment for a credit account.
         * @summary Retrieve account adjustment
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve an adjustment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} adjustmentToken Unique identifier of the adjustment to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/adjustments&#x60; to retrieve existing account adjustment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAdjustment(accountToken: string, adjustmentToken: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountAdjustmentResponse> {
            return localVarFp.retrieveAdjustment(accountToken, adjustmentToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdjustmentsApi - object-oriented interface
 */
export class AdjustmentsApi extends BaseAPI {
    /**
     * Create an adjustment for an existing credit account.
     * @summary Create account adjustment
     * @param {string} accountToken Unique identifier of the credit account for which you want to create an adjustment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {AccountAdjustmentReq} accountAdjustmentReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAdjustmentForAccount(accountToken: string, accountAdjustmentReq: AccountAdjustmentReq, options?: RawAxiosRequestConfig) {
        return AdjustmentsApiFp(this.configuration).createAdjustmentForAccount(accountToken, accountAdjustmentReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of adjustments for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
     * @summary List account adjustments
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve adjustments.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {number} [count] Number of account adjustment resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAdjustmentsByAccount(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig) {
        return AdjustmentsApiFp(this.configuration).getAdjustmentsByAccount(accountToken, count, startIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an adjustment for a credit account.
     * @summary Retrieve account adjustment
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve an adjustment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} adjustmentToken Unique identifier of the adjustment to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/adjustments&#x60; to retrieve existing account adjustment tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveAdjustment(accountToken: string, adjustmentToken: string, options?: RawAxiosRequestConfig) {
        return AdjustmentsApiFp(this.configuration).retrieveAdjustment(accountToken, adjustmentToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdminApi - axios parameter creator
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Replays all failed statement from statement error processing table
         * @summary Replays all failed statement from statement error processing table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayFailedStatements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/replayfailedstatements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replays all failed statements by short code from statement error processing table
         * @summary Replays all failed statements by short code from statement error processing table
         * @param {string} shortCode Short code of the program
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayFailedStatementsByShortCode: async (shortCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shortCode' is not null or undefined
            assertParamExists('replayFailedStatementsByShortCode', 'shortCode', shortCode)
            const localVarPath = `/admin/replayfailedstatements/{short_code}`
                .replace(`{${"short_code"}}`, encodeURIComponent(String(shortCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and enables a feature flag for a specified program short code
         * @summary Replays single failed statement by short code  and account token from statement error processing table
         * @param {string} shortCode Short code of the program
         * @param {string} accountToken account token of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaySingleFailedStatement: async (shortCode: string, accountToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shortCode' is not null or undefined
            assertParamExists('replaySingleFailedStatement', 'shortCode', shortCode)
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('replaySingleFailedStatement', 'accountToken', accountToken)
            const localVarPath = `/admin/{short_code}/replayfailedstatement/{account_token}`
                .replace(`{${"short_code"}}`, encodeURIComponent(String(shortCode)))
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ACHO ACH transfer for payment who\'s current transfer has failed and is in ERROR state.
         * @summary Create a new ACHO ACH transfer
         * @param {string} shortCode Short code of the program
         * @param {RetryAchPaymentReq} retryAchPaymentReq Create a new ACHO ACH transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryAchPayment: async (shortCode: string, retryAchPaymentReq: RetryAchPaymentReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'shortCode' is not null or undefined
            assertParamExists('retryAchPayment', 'shortCode', shortCode)
            // verify required parameter 'retryAchPaymentReq' is not null or undefined
            assertParamExists('retryAchPayment', 'retryAchPaymentReq', retryAchPaymentReq)
            const localVarPath = `/admin/{short_code}/retryachpayments`
                .replace(`{${"short_code"}}`, encodeURIComponent(String(shortCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(retryAchPaymentReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Schedules statements for applicable accounts
         * @summary Schedules statements for applicable accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleStatements: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/scheduleStatements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Replays all failed statement from statement error processing table
         * @summary Replays all failed statement from statement error processing table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replayFailedStatements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replayFailedStatements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.replayFailedStatements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Replays all failed statements by short code from statement error processing table
         * @summary Replays all failed statements by short code from statement error processing table
         * @param {string} shortCode Short code of the program
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replayFailedStatementsByShortCode(shortCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replayFailedStatementsByShortCode(shortCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.replayFailedStatementsByShortCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates and enables a feature flag for a specified program short code
         * @summary Replays single failed statement by short code  and account token from statement error processing table
         * @param {string} shortCode Short code of the program
         * @param {string} accountToken account token of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaySingleFailedStatement(shortCode: string, accountToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaySingleFailedStatement(shortCode, accountToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.replaySingleFailedStatement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new ACHO ACH transfer for payment who\'s current transfer has failed and is in ERROR state.
         * @summary Create a new ACHO ACH transfer
         * @param {string} shortCode Short code of the program
         * @param {RetryAchPaymentReq} retryAchPaymentReq Create a new ACHO ACH transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryAchPayment(shortCode: string, retryAchPaymentReq: RetryAchPaymentReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetryAchPaymentReq>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retryAchPayment(shortCode, retryAchPaymentReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.retryAchPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Schedules statements for applicable accounts
         * @summary Schedules statements for applicable accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleStatements(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Success>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleStatements(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.scheduleStatements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Replays all failed statement from statement error processing table
         * @summary Replays all failed statement from statement error processing table
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayFailedStatements(options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.replayFailedStatements(options).then((request) => request(axios, basePath));
        },
        /**
         * Replays all failed statements by short code from statement error processing table
         * @summary Replays all failed statements by short code from statement error processing table
         * @param {string} shortCode Short code of the program
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replayFailedStatementsByShortCode(shortCode: string, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.replayFailedStatementsByShortCode(shortCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and enables a feature flag for a specified program short code
         * @summary Replays single failed statement by short code  and account token from statement error processing table
         * @param {string} shortCode Short code of the program
         * @param {string} accountToken account token of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaySingleFailedStatement(shortCode: string, accountToken: string, options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.replaySingleFailedStatement(shortCode, accountToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ACHO ACH transfer for payment who\'s current transfer has failed and is in ERROR state.
         * @summary Create a new ACHO ACH transfer
         * @param {string} shortCode Short code of the program
         * @param {RetryAchPaymentReq} retryAchPaymentReq Create a new ACHO ACH transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryAchPayment(shortCode: string, retryAchPaymentReq: RetryAchPaymentReq, options?: RawAxiosRequestConfig): AxiosPromise<RetryAchPaymentReq> {
            return localVarFp.retryAchPayment(shortCode, retryAchPaymentReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Schedules statements for applicable accounts
         * @summary Schedules statements for applicable accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleStatements(options?: RawAxiosRequestConfig): AxiosPromise<Success> {
            return localVarFp.scheduleStatements(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /**
     * Replays all failed statement from statement error processing table
     * @summary Replays all failed statement from statement error processing table
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public replayFailedStatements(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).replayFailedStatements(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replays all failed statements by short code from statement error processing table
     * @summary Replays all failed statements by short code from statement error processing table
     * @param {string} shortCode Short code of the program
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public replayFailedStatementsByShortCode(shortCode: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).replayFailedStatementsByShortCode(shortCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and enables a feature flag for a specified program short code
     * @summary Replays single failed statement by short code  and account token from statement error processing table
     * @param {string} shortCode Short code of the program
     * @param {string} accountToken account token of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public replaySingleFailedStatement(shortCode: string, accountToken: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).replaySingleFailedStatement(shortCode, accountToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ACHO ACH transfer for payment who\'s current transfer has failed and is in ERROR state.
     * @summary Create a new ACHO ACH transfer
     * @param {string} shortCode Short code of the program
     * @param {RetryAchPaymentReq} retryAchPaymentReq Create a new ACHO ACH transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retryAchPayment(shortCode: string, retryAchPaymentReq: RetryAchPaymentReq, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).retryAchPayment(shortCode, retryAchPaymentReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Schedules statements for applicable accounts
     * @summary Schedules statements for applicable accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scheduleStatements(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).scheduleStatements(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthControlsApi - axios parameter creator
 */
export const AuthControlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all global auth control exceptions for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrols: async (cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authcontrols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cardProduct !== undefined) {
                localVarQueryParameter['card_product'] = cardProduct;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all auth control exempted MIDs for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmids: async (cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/authcontrols/exemptmids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cardProduct !== undefined) {
                localVarQueryParameter['card_product'] = cardProduct;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific auth control exemptmids
         * @param {string} token Auth control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmidsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAuthcontrolsExemptmidsToken', 'token', token)
            const localVarPath = `/authcontrols/exemptmids/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific auth control exception
         * @param {string} token Auth control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAuthcontrolsToken', 'token', token)
            const localVarPath = `/authcontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an auth control exception
         * @param {AuthControlRequest} authControlRequest Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrols: async (authControlRequest: AuthControlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authControlRequest' is not null or undefined
            assertParamExists('postAuthcontrols', 'authControlRequest', authControlRequest)
            const localVarPath = `/authcontrols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(authControlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an auth control for exempting MIDs
         * @param {AuthControlExemptMidsRequest} authControlExemptMidsRequest Auth control exempt MID object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrolsExemptmids: async (authControlExemptMidsRequest: AuthControlExemptMidsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authControlExemptMidsRequest' is not null or undefined
            assertParamExists('postAuthcontrolsExemptmids', 'authControlExemptMidsRequest', authControlExemptMidsRequest)
            const localVarPath = `/authcontrols/exemptmids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(authControlExemptMidsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the status an auth control exemptmids
         * @param {string} token Auth control token
         * @param {AuthControlExemptMidsUpdateRequest} [authControlExemptMidsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsExemptmidsToken: async (token: string, authControlExemptMidsUpdateRequest?: AuthControlExemptMidsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putAuthcontrolsExemptmidsToken', 'token', token)
            const localVarPath = `/authcontrols/exemptmids/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(authControlExemptMidsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an auth control exception
         * @param {string} token Auth control token
         * @param {AuthControlUpdateRequest} authControlUpdateRequest Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsToken: async (token: string, authControlUpdateRequest: AuthControlUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putAuthcontrolsToken', 'token', token)
            // verify required parameter 'authControlUpdateRequest' is not null or undefined
            assertParamExists('putAuthcontrolsToken', 'authControlUpdateRequest', authControlUpdateRequest)
            const localVarPath = `/authcontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(authControlUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControlsApi - functional programming interface
 */
export const AuthControlsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControlsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all global auth control exceptions for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthcontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControlListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthcontrols(cardProduct, user, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControlsApi.getAuthcontrols']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all auth control exempted MIDs for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthcontrolsExemptmids(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControlExemptMidsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthcontrolsExemptmids(cardProduct, user, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControlsApi.getAuthcontrolsExemptmids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific auth control exemptmids
         * @param {string} token Auth control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthcontrolsExemptmidsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControlExemptMidsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthcontrolsExemptmidsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControlsApi.getAuthcontrolsExemptmidsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific auth control exception
         * @param {string} token Auth control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthcontrolsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthcontrolsToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControlsApi.getAuthcontrolsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an auth control exception
         * @param {AuthControlRequest} authControlRequest Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthcontrols(authControlRequest: AuthControlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthcontrols(authControlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControlsApi.postAuthcontrols']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an auth control for exempting MIDs
         * @param {AuthControlExemptMidsRequest} authControlExemptMidsRequest Auth control exempt MID object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthcontrolsExemptmids(authControlExemptMidsRequest: AuthControlExemptMidsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControlExemptMidsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthcontrolsExemptmids(authControlExemptMidsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControlsApi.postAuthcontrolsExemptmids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the status an auth control exemptmids
         * @param {string} token Auth control token
         * @param {AuthControlExemptMidsUpdateRequest} [authControlExemptMidsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAuthcontrolsExemptmidsToken(token: string, authControlExemptMidsUpdateRequest?: AuthControlExemptMidsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAuthcontrolsExemptmidsToken(token, authControlExemptMidsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControlsApi.putAuthcontrolsExemptmidsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an auth control exception
         * @param {string} token Auth control token
         * @param {AuthControlUpdateRequest} authControlUpdateRequest Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAuthcontrolsToken(token: string, authControlUpdateRequest: AuthControlUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAuthcontrolsToken(token, authControlUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthControlsApi.putAuthcontrolsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthControlsApi - factory interface
 */
export const AuthControlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControlsApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all global auth control exceptions for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControlListResponse> {
            return localVarFp.getAuthcontrols(cardProduct, user, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all auth control exempted MIDs for the program
         * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
         * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmids(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControlExemptMidsListResponse> {
            return localVarFp.getAuthcontrolsExemptmids(cardProduct, user, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific auth control exemptmids
         * @param {string} token Auth control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsExemptmidsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControlExemptMidsResponse> {
            return localVarFp.getAuthcontrolsExemptmidsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific auth control exception
         * @param {string} token Auth control token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthcontrolsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthControlResponse> {
            return localVarFp.getAuthcontrolsToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an auth control exception
         * @param {AuthControlRequest} authControlRequest Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrols(authControlRequest: AuthControlRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthControlResponse> {
            return localVarFp.postAuthcontrols(authControlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an auth control for exempting MIDs
         * @param {AuthControlExemptMidsRequest} authControlExemptMidsRequest Auth control exempt MID object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthcontrolsExemptmids(authControlExemptMidsRequest: AuthControlExemptMidsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthControlExemptMidsResponse> {
            return localVarFp.postAuthcontrolsExemptmids(authControlExemptMidsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the status an auth control exemptmids
         * @param {string} token Auth control token
         * @param {AuthControlExemptMidsUpdateRequest} [authControlExemptMidsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsExemptmidsToken(token: string, authControlExemptMidsUpdateRequest?: AuthControlExemptMidsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putAuthcontrolsExemptmidsToken(token, authControlExemptMidsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an auth control exception
         * @param {string} token Auth control token
         * @param {AuthControlUpdateRequest} authControlUpdateRequest Auth control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthcontrolsToken(token: string, authControlUpdateRequest: AuthControlUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthControlResponse> {
            return localVarFp.putAuthcontrolsToken(token, authControlUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControlsApi - object-oriented interface
 */
export class AuthControlsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all global auth control exceptions for the program
     * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
     * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuthcontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return AuthControlsApiFp(this.configuration).getAuthcontrols(cardProduct, user, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all auth control exempted MIDs for the program
     * @param {string} [cardProduct] Card product token. Use \&quot;null\&quot; to get auth controls that are not associated with any card product.
     * @param {string} [user] User token. Use \&quot;null\&quot; to get auth controls that are not associated with any user.
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuthcontrolsExemptmids(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return AuthControlsApiFp(this.configuration).getAuthcontrolsExemptmids(cardProduct, user, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific auth control exemptmids
     * @param {string} token Auth control token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuthcontrolsExemptmidsToken(token: string, options?: RawAxiosRequestConfig) {
        return AuthControlsApiFp(this.configuration).getAuthcontrolsExemptmidsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific auth control exception
     * @param {string} token Auth control token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuthcontrolsToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return AuthControlsApiFp(this.configuration).getAuthcontrolsToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an auth control exception
     * @param {AuthControlRequest} authControlRequest Auth control object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postAuthcontrols(authControlRequest: AuthControlRequest, options?: RawAxiosRequestConfig) {
        return AuthControlsApiFp(this.configuration).postAuthcontrols(authControlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an auth control for exempting MIDs
     * @param {AuthControlExemptMidsRequest} authControlExemptMidsRequest Auth control exempt MID object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postAuthcontrolsExemptmids(authControlExemptMidsRequest: AuthControlExemptMidsRequest, options?: RawAxiosRequestConfig) {
        return AuthControlsApiFp(this.configuration).postAuthcontrolsExemptmids(authControlExemptMidsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the status an auth control exemptmids
     * @param {string} token Auth control token
     * @param {AuthControlExemptMidsUpdateRequest} [authControlExemptMidsUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putAuthcontrolsExemptmidsToken(token: string, authControlExemptMidsUpdateRequest?: AuthControlExemptMidsUpdateRequest, options?: RawAxiosRequestConfig) {
        return AuthControlsApiFp(this.configuration).putAuthcontrolsExemptmidsToken(token, authControlExemptMidsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an auth control exception
     * @param {string} token Auth control token
     * @param {AuthControlUpdateRequest} authControlUpdateRequest Auth control object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putAuthcontrolsToken(token: string, authControlUpdateRequest: AuthControlUpdateRequest, options?: RawAxiosRequestConfig) {
        return AuthControlsApiFp(this.configuration).putAuthcontrolsToken(token, authControlUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AutoReloadsApi - axios parameter creator
 */
export const AutoReloadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all auto reloads for the program
         * @param {string} [cardProduct] Card product token
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloads: async (cardProduct?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/autoreloads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cardProduct !== undefined) {
                localVarQueryParameter['card_product'] = cardProduct;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific auto reload object
         * @param {string} token Auto reload token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloadsToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAutoreloadsToken', 'token', token)
            const localVarPath = `/autoreloads/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an auto reload object
         * @param {AutoReloadModel} autoReloadModel Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAutoreloads: async (autoReloadModel: AutoReloadModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoReloadModel' is not null or undefined
            assertParamExists('postAutoreloads', 'autoReloadModel', autoReloadModel)
            const localVarPath = `/autoreloads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(autoReloadModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific auto reload object
         * @param {string} token 
         * @param {AutoReloadUpdateModel} autoReloadUpdateModel Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAutoreloadsToken: async (token: string, autoReloadUpdateModel: AutoReloadUpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putAutoreloadsToken', 'token', token)
            // verify required parameter 'autoReloadUpdateModel' is not null or undefined
            assertParamExists('putAutoreloadsToken', 'autoReloadUpdateModel', autoReloadUpdateModel)
            const localVarPath = `/autoreloads/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(autoReloadUpdateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoReloadsApi - functional programming interface
 */
export const AutoReloadsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AutoReloadsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all auto reloads for the program
         * @param {string} [cardProduct] Card product token
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoreloads(cardProduct?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoReloadListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoreloads(cardProduct, userToken, businessToken, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutoReloadsApi.getAutoreloads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific auto reload object
         * @param {string} token Auto reload token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoreloadsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoReloadResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoreloadsToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutoReloadsApi.getAutoreloadsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an auto reload object
         * @param {AutoReloadModel} autoReloadModel Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAutoreloads(autoReloadModel: AutoReloadModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoReloadResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAutoreloads(autoReloadModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutoReloadsApi.postAutoreloads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific auto reload object
         * @param {string} token 
         * @param {AutoReloadUpdateModel} autoReloadUpdateModel Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAutoreloadsToken(token: string, autoReloadUpdateModel: AutoReloadUpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoReloadResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAutoreloadsToken(token, autoReloadUpdateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutoReloadsApi.putAutoreloadsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutoReloadsApi - factory interface
 */
export const AutoReloadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutoReloadsApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all auto reloads for the program
         * @param {string} [cardProduct] Card product token
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloads(cardProduct?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<AutoReloadListResponse> {
            return localVarFp.getAutoreloads(cardProduct, userToken, businessToken, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific auto reload object
         * @param {string} token Auto reload token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoreloadsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<AutoReloadResponseModel> {
            return localVarFp.getAutoreloadsToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an auto reload object
         * @param {AutoReloadModel} autoReloadModel Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAutoreloads(autoReloadModel: AutoReloadModel, options?: RawAxiosRequestConfig): AxiosPromise<AutoReloadResponseModel> {
            return localVarFp.postAutoreloads(autoReloadModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific auto reload object
         * @param {string} token 
         * @param {AutoReloadUpdateModel} autoReloadUpdateModel Auto reload object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAutoreloadsToken(token: string, autoReloadUpdateModel: AutoReloadUpdateModel, options?: RawAxiosRequestConfig): AxiosPromise<AutoReloadResponseModel> {
            return localVarFp.putAutoreloadsToken(token, autoReloadUpdateModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutoReloadsApi - object-oriented interface
 */
export class AutoReloadsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all auto reloads for the program
     * @param {string} [cardProduct] Card product token
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAutoreloads(cardProduct?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return AutoReloadsApiFp(this.configuration).getAutoreloads(cardProduct, userToken, businessToken, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific auto reload object
     * @param {string} token Auto reload token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAutoreloadsToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return AutoReloadsApiFp(this.configuration).getAutoreloadsToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an auto reload object
     * @param {AutoReloadModel} autoReloadModel Auto reload object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postAutoreloads(autoReloadModel: AutoReloadModel, options?: RawAxiosRequestConfig) {
        return AutoReloadsApiFp(this.configuration).postAutoreloads(autoReloadModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific auto reload object
     * @param {string} token 
     * @param {AutoReloadUpdateModel} autoReloadUpdateModel Auto reload object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putAutoreloadsToken(token: string, autoReloadUpdateModel: AutoReloadUpdateModel, options?: RawAxiosRequestConfig) {
        return AutoReloadsApiFp(this.configuration).putAutoreloadsToken(token, autoReloadUpdateModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BalanceRefundsApi - axios parameter creator
 */
export const BalanceRefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new balance refund, which can be issued to the account holder if their credit account balance is negative.
         * @summary Create balance refund
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountCreditBalanceRefundReq} accountCreditBalanceRefundReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBalanceRefund: async (accountToken: string, accountCreditBalanceRefundReq: AccountCreditBalanceRefundReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createBalanceRefund', 'accountToken', accountToken)
            // verify required parameter 'accountCreditBalanceRefundReq' is not null or undefined
            assertParamExists('createBalanceRefund', 'accountCreditBalanceRefundReq', accountCreditBalanceRefundReq)
            const localVarPath = `/accounts/{account_token}/creditbalancerefunds`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(accountCreditBalanceRefundReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceRefundsApi - functional programming interface
 */
export const BalanceRefundsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceRefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new balance refund, which can be issued to the account holder if their credit account balance is negative.
         * @summary Create balance refund
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountCreditBalanceRefundReq} accountCreditBalanceRefundReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBalanceRefund(accountToken: string, accountCreditBalanceRefundReq: AccountCreditBalanceRefundReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCreditBalanceRefundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBalanceRefund(accountToken, accountCreditBalanceRefundReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BalanceRefundsApi.createBalanceRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BalanceRefundsApi - factory interface
 */
export const BalanceRefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceRefundsApiFp(configuration)
    return {
        /**
         * Create a new balance refund, which can be issued to the account holder if their credit account balance is negative.
         * @summary Create balance refund
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountCreditBalanceRefundReq} accountCreditBalanceRefundReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBalanceRefund(accountToken: string, accountCreditBalanceRefundReq: AccountCreditBalanceRefundReq, options?: RawAxiosRequestConfig): AxiosPromise<AccountCreditBalanceRefundResponse> {
            return localVarFp.createBalanceRefund(accountToken, accountCreditBalanceRefundReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BalanceRefundsApi - object-oriented interface
 */
export class BalanceRefundsApi extends BaseAPI {
    /**
     * Create a new balance refund, which can be issued to the account holder if their credit account balance is negative.
     * @summary Create balance refund
     * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {AccountCreditBalanceRefundReq} accountCreditBalanceRefundReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBalanceRefund(accountToken: string, accountCreditBalanceRefundReq: AccountCreditBalanceRefundReq, options?: RawAxiosRequestConfig) {
        return BalanceRefundsApiFp(this.configuration).createBalanceRefund(accountToken, accountCreditBalanceRefundReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BankTransfersApi - axios parameter creator
 */
export const BankTransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all bank transfers
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [fundingSourceToken] Funding source token
         * @param {string} [statuses] A comma-delimited list of bank transfer status(s)
         * @param {string} [sortBy] Sort order
         * @param {string} [expand] Object to expand
         * @param {string} [fundingSourceType] Funding source type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAch: async (count?: number, startIndex?: number, userToken?: string, businessToken?: string, fundingSourceToken?: string, statuses?: string, sortBy?: string, expand?: string, fundingSourceType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banktransfers/ach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (fundingSourceToken !== undefined) {
                localVarQueryParameter['funding_source_token'] = fundingSourceToken;
            }

            if (statuses !== undefined) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }

            if (fundingSourceType !== undefined) {
                localVarQueryParameter['funding_source_type'] = fundingSourceType;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a bank transfer entry
         * @param {string} token Bank transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBanktransfersAchToken', 'token', token)
            const localVarPath = `/banktransfers/ach/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all bank transfer transitions
         * @param {number} [count] Number of bank transfer transitions to retrieve
         * @param {string} [token] Bank transfer transition token
         * @param {string} [bankTransferToken] Bank transfer token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [statuses] Comma-delimited list of bank transfer states to display e.g. PENDING | PROCESSING | SUBMITTED | RETURNED |  COMPLETED | CANCELLED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchTransitions: async (count?: number, token?: string, bankTransferToken?: string, startIndex?: number, sortBy?: string, statuses?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/banktransfers/ach/transitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (bankTransferToken !== undefined) {
                localVarQueryParameter['bank_transfer_token'] = bankTransferToken;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (statuses !== undefined) {
                localVarQueryParameter['statuses'] = statuses;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Applies a provisional credit to a bank transfer
         * @param {EarlyFundsRequestModel} earlyFundsRequestModel Early funds request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplyProvisionalCreditToBankTransfer: async (earlyFundsRequestModel: EarlyFundsRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'earlyFundsRequestModel' is not null or undefined
            assertParamExists('postApplyProvisionalCreditToBankTransfer', 'earlyFundsRequestModel', earlyFundsRequestModel)
            const localVarPath = `/banktransfers/ach/earlyfunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(earlyFundsRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an ACH bank transfer
         * @param {BankTransferRequestModel} bankTransferRequestModel Create bank transfer request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAch: async (bankTransferRequestModel: BankTransferRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankTransferRequestModel' is not null or undefined
            assertParamExists('postBanktransfersAch', 'bankTransferRequestModel', bankTransferRequestModel)
            const localVarPath = `/banktransfers/ach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(bankTransferRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an ACH bank transfer transition
         * @param {BankTransferTransitionRequestModel} bankTransferTransitionRequestModel Create bank transfer transition request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAchTransitions: async (bankTransferTransitionRequestModel: BankTransferTransitionRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankTransferTransitionRequestModel' is not null or undefined
            assertParamExists('postBanktransfersAchTransitions', 'bankTransferTransitionRequestModel', bankTransferTransitionRequestModel)
            const localVarPath = `/banktransfers/ach/transitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(bankTransferTransitionRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankTransfersApi - functional programming interface
 */
export const BankTransfersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BankTransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all bank transfers
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [fundingSourceToken] Funding source token
         * @param {string} [statuses] A comma-delimited list of bank transfer status(s)
         * @param {string} [sortBy] Sort order
         * @param {string} [expand] Object to expand
         * @param {string} [fundingSourceType] Funding source type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanktransfersAch(count?: number, startIndex?: number, userToken?: string, businessToken?: string, fundingSourceToken?: string, statuses?: string, sortBy?: string, expand?: string, fundingSourceType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransferListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanktransfersAch(count, startIndex, userToken, businessToken, fundingSourceToken, statuses, sortBy, expand, fundingSourceType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransfersApi.getBanktransfersAch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a bank transfer entry
         * @param {string} token Bank transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanktransfersAchToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransferResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanktransfersAchToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransfersApi.getBanktransfersAchToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all bank transfer transitions
         * @param {number} [count] Number of bank transfer transitions to retrieve
         * @param {string} [token] Bank transfer transition token
         * @param {string} [bankTransferToken] Bank transfer token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [statuses] Comma-delimited list of bank transfer states to display e.g. PENDING | PROCESSING | SUBMITTED | RETURNED |  COMPLETED | CANCELLED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanktransfersAchTransitions(count?: number, token?: string, bankTransferToken?: string, startIndex?: number, sortBy?: string, statuses?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransferTransitionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanktransfersAchTransitions(count, token, bankTransferToken, startIndex, sortBy, statuses, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransfersApi.getBanktransfersAchTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Applies a provisional credit to a bank transfer
         * @param {EarlyFundsRequestModel} earlyFundsRequestModel Early funds request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postApplyProvisionalCreditToBankTransfer(earlyFundsRequestModel: EarlyFundsRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransferResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postApplyProvisionalCreditToBankTransfer(earlyFundsRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransfersApi.postApplyProvisionalCreditToBankTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an ACH bank transfer
         * @param {BankTransferRequestModel} bankTransferRequestModel Create bank transfer request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBanktransfersAch(bankTransferRequestModel: BankTransferRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransferResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBanktransfersAch(bankTransferRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransfersApi.postBanktransfersAch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an ACH bank transfer transition
         * @param {BankTransferTransitionRequestModel} bankTransferTransitionRequestModel Create bank transfer transition request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBanktransfersAchTransitions(bankTransferTransitionRequestModel: BankTransferTransitionRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankTransferTransitionResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBanktransfersAchTransitions(bankTransferTransitionRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BankTransfersApi.postBanktransfersAchTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BankTransfersApi - factory interface
 */
export const BankTransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankTransfersApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all bank transfers
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [fundingSourceToken] Funding source token
         * @param {string} [statuses] A comma-delimited list of bank transfer status(s)
         * @param {string} [sortBy] Sort order
         * @param {string} [expand] Object to expand
         * @param {string} [fundingSourceType] Funding source type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAch(count?: number, startIndex?: number, userToken?: string, businessToken?: string, fundingSourceToken?: string, statuses?: string, sortBy?: string, expand?: string, fundingSourceType?: string, options?: RawAxiosRequestConfig): AxiosPromise<BankTransferListResponse> {
            return localVarFp.getBanktransfersAch(count, startIndex, userToken, businessToken, fundingSourceToken, statuses, sortBy, expand, fundingSourceType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a bank transfer entry
         * @param {string} token Bank transfer token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<BankTransferResponseModel> {
            return localVarFp.getBanktransfersAchToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all bank transfer transitions
         * @param {number} [count] Number of bank transfer transitions to retrieve
         * @param {string} [token] Bank transfer transition token
         * @param {string} [bankTransferToken] Bank transfer token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [statuses] Comma-delimited list of bank transfer states to display e.g. PENDING | PROCESSING | SUBMITTED | RETURNED |  COMPLETED | CANCELLED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanktransfersAchTransitions(count?: number, token?: string, bankTransferToken?: string, startIndex?: number, sortBy?: string, statuses?: string, options?: RawAxiosRequestConfig): AxiosPromise<BankTransferTransitionListResponse> {
            return localVarFp.getBanktransfersAchTransitions(count, token, bankTransferToken, startIndex, sortBy, statuses, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Applies a provisional credit to a bank transfer
         * @param {EarlyFundsRequestModel} earlyFundsRequestModel Early funds request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postApplyProvisionalCreditToBankTransfer(earlyFundsRequestModel: EarlyFundsRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<BankTransferResponseModel> {
            return localVarFp.postApplyProvisionalCreditToBankTransfer(earlyFundsRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an ACH bank transfer
         * @param {BankTransferRequestModel} bankTransferRequestModel Create bank transfer request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAch(bankTransferRequestModel: BankTransferRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<BankTransferResponseModel> {
            return localVarFp.postBanktransfersAch(bankTransferRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an ACH bank transfer transition
         * @param {BankTransferTransitionRequestModel} bankTransferTransitionRequestModel Create bank transfer transition request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBanktransfersAchTransitions(bankTransferTransitionRequestModel: BankTransferTransitionRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<BankTransferTransitionResponseModel> {
            return localVarFp.postBanktransfersAchTransitions(bankTransferTransitionRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankTransfersApi - object-oriented interface
 */
export class BankTransfersApi extends BaseAPI {
    /**
     * 
     * @summary Lists all bank transfers
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {string} [fundingSourceToken] Funding source token
     * @param {string} [statuses] A comma-delimited list of bank transfer status(s)
     * @param {string} [sortBy] Sort order
     * @param {string} [expand] Object to expand
     * @param {string} [fundingSourceType] Funding source type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBanktransfersAch(count?: number, startIndex?: number, userToken?: string, businessToken?: string, fundingSourceToken?: string, statuses?: string, sortBy?: string, expand?: string, fundingSourceType?: string, options?: RawAxiosRequestConfig) {
        return BankTransfersApiFp(this.configuration).getBanktransfersAch(count, startIndex, userToken, businessToken, fundingSourceToken, statuses, sortBy, expand, fundingSourceType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a bank transfer entry
     * @param {string} token Bank transfer token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBanktransfersAchToken(token: string, options?: RawAxiosRequestConfig) {
        return BankTransfersApiFp(this.configuration).getBanktransfersAchToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all bank transfer transitions
     * @param {number} [count] Number of bank transfer transitions to retrieve
     * @param {string} [token] Bank transfer transition token
     * @param {string} [bankTransferToken] Bank transfer token
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {string} [statuses] Comma-delimited list of bank transfer states to display e.g. PENDING | PROCESSING | SUBMITTED | RETURNED |  COMPLETED | CANCELLED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBanktransfersAchTransitions(count?: number, token?: string, bankTransferToken?: string, startIndex?: number, sortBy?: string, statuses?: string, options?: RawAxiosRequestConfig) {
        return BankTransfersApiFp(this.configuration).getBanktransfersAchTransitions(count, token, bankTransferToken, startIndex, sortBy, statuses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Applies a provisional credit to a bank transfer
     * @param {EarlyFundsRequestModel} earlyFundsRequestModel Early funds request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postApplyProvisionalCreditToBankTransfer(earlyFundsRequestModel: EarlyFundsRequestModel, options?: RawAxiosRequestConfig) {
        return BankTransfersApiFp(this.configuration).postApplyProvisionalCreditToBankTransfer(earlyFundsRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an ACH bank transfer
     * @param {BankTransferRequestModel} bankTransferRequestModel Create bank transfer request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBanktransfersAch(bankTransferRequestModel: BankTransferRequestModel, options?: RawAxiosRequestConfig) {
        return BankTransfersApiFp(this.configuration).postBanktransfersAch(bankTransferRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an ACH bank transfer transition
     * @param {BankTransferTransitionRequestModel} bankTransferTransitionRequestModel Create bank transfer transition request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBanktransfersAchTransitions(bankTransferTransitionRequestModel: BankTransferTransitionRequestModel, options?: RawAxiosRequestConfig) {
        return BankTransfersApiFp(this.configuration).postBanktransfersAchTransitions(bankTransferTransitionRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BulkIssuancesApi - axios parameter creator
 */
export const BulkIssuancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all bulk issuance requests
         * @param {number} [count] Number of requests to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuances: async (count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bulkissuances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a bulk issuance request
         * @param {string} token Bulk issuance token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuancesToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBulkissuancesToken', 'token', token)
            const localVarPath = `/bulkissuances/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a bulk issuance request for cards
         * @param {BulkIssuanceRequest} [bulkIssuanceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBulkissuances: async (bulkIssuanceRequest?: BulkIssuanceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bulkissuances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(bulkIssuanceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BulkIssuancesApi - functional programming interface
 */
export const BulkIssuancesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BulkIssuancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all bulk issuance requests
         * @param {number} [count] Number of requests to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBulkissuances(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkCardOrderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBulkissuances(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkIssuancesApi.getBulkissuances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a bulk issuance request
         * @param {string} token Bulk issuance token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBulkissuancesToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkIssuanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBulkissuancesToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkIssuancesApi.getBulkissuancesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a bulk issuance request for cards
         * @param {BulkIssuanceRequest} [bulkIssuanceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBulkissuances(bulkIssuanceRequest?: BulkIssuanceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkIssuanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBulkissuances(bulkIssuanceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkIssuancesApi.postBulkissuances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BulkIssuancesApi - factory interface
 */
export const BulkIssuancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BulkIssuancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all bulk issuance requests
         * @param {number} [count] Number of requests to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuances(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<BulkCardOrderListResponse> {
            return localVarFp.getBulkissuances(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a bulk issuance request
         * @param {string} token Bulk issuance token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkissuancesToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<BulkIssuanceResponse> {
            return localVarFp.getBulkissuancesToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a bulk issuance request for cards
         * @param {BulkIssuanceRequest} [bulkIssuanceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBulkissuances(bulkIssuanceRequest?: BulkIssuanceRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkIssuanceResponse> {
            return localVarFp.postBulkissuances(bulkIssuanceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BulkIssuancesApi - object-oriented interface
 */
export class BulkIssuancesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all bulk issuance requests
     * @param {number} [count] Number of requests to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBulkissuances(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return BulkIssuancesApiFp(this.configuration).getBulkissuances(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a bulk issuance request
     * @param {string} token Bulk issuance token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBulkissuancesToken(token: string, options?: RawAxiosRequestConfig) {
        return BulkIssuancesApiFp(this.configuration).getBulkissuancesToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a bulk issuance request for cards
     * @param {BulkIssuanceRequest} [bulkIssuanceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBulkissuances(bulkIssuanceRequest?: BulkIssuanceRequest, options?: RawAxiosRequestConfig) {
        return BulkIssuancesApiFp(this.configuration).postBulkissuances(bulkIssuanceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BundlesApi - axios parameter creator
 */
export const BundlesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new bundle based on an existing bundle.
         * @summary Clone bundle
         * @param {string} token Unique identifier of the bundle to clone.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing bundle tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneBundle: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('cloneBundle', 'token', token)
            const localVarPath = `/bundles/{token}/clone`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a bundle.
         * @summary Create bundle
         * @param {BundleCreateReq} bundleCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundle: async (bundleCreateReq: BundleCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bundleCreateReq' is not null or undefined
            assertParamExists('createBundle', 'bundleCreateReq', bundleCreateReq)
            const localVarPath = `/bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(bundleCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of bundles.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List bundles
         * @param {number} [count] Number of bundles resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListBundlesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, not by the field names appearing in response bodies: for example, &#x60;last_modified_time&#x60;.
         * @param {Array<BundleResourceStatus>} [status] An array of statuses by which to filter bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBundles: async (count?: number, startIndex?: number, sortBy?: ListBundlesSortByEnum, status?: Array<BundleResourceStatus>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of related product bundles.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List related bundles
         * @param {string} token Unique identifier of the parent product bundle.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing product bundles tokens.
         * @param {number} [count] Number of related bundle product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRelatedBundlesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<BundleResourceStatus>} [status] Array of statuses by which to filter bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelatedBundles: async (token: string, count?: number, startIndex?: number, sortBy?: ListRelatedBundlesSortByEnum, status?: Array<BundleResourceStatus>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('listRelatedBundles', 'token', token)
            const localVarPath = `/bundles/{token}/lineage`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Promote a specific bundle that replaces the current active bundle and activates the promoted bundle.
         * @summary Promote bundle
         * @param {string} token Unique identifier of the bundle to promote.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing bundle tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteBundle: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('promoteBundle', 'token', token)
            const localVarPath = `/bundles/{token}/promote`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific bundle.
         * @summary Retrieve bundle
         * @param {string} token Unique identifier of the bundle to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {Array<PolicyType>} [expandObjects] Embeds the associated object of the specified type into the response. For more, see &lt;&lt;/core-api/object-expansion, object expansion&gt;&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBundle: async (token: string, expandObjects?: Array<PolicyType>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrieveBundle', 'token', token)
            const localVarPath = `/bundles/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (expandObjects) {
                localVarQueryParameter['expand_objects'] = expandObjects;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transition the status of a specific bundle.
         * @summary Transition a bundle
         * @param {string} token Token of the bundle whose status you want to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {BundleTransitionReq} bundleTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionBundle: async (token: string, bundleTransitionReq: BundleTransitionReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('transitionBundle', 'token', token)
            // verify required parameter 'bundleTransitionReq' is not null or undefined
            assertParamExists('transitionBundle', 'bundleTransitionReq', bundleTransitionReq)
            const localVarPath = `/bundles/{token}/transitions`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(bundleTransitionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific bundle that is not `ACTIVE` or `ARCHIVED`. Bundles are created in a `DRAFT` state, and are still modifiable at this point. Using the transitions endpoint, a bundle can be transitioned from `DRAFT`, to `ACTIVE`. Once a bundle is active, it cannot be modified.
         * @summary Update bundle
         * @param {string} token Token of the bundle to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {BundleUpdateReq} bundleUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBundle: async (token: string, bundleUpdateReq: BundleUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateBundle', 'token', token)
            // verify required parameter 'bundleUpdateReq' is not null or undefined
            assertParamExists('updateBundle', 'bundleUpdateReq', bundleUpdateReq)
            const localVarPath = `/bundles/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(bundleUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BundlesApi - functional programming interface
 */
export const BundlesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BundlesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new bundle based on an existing bundle.
         * @summary Clone bundle
         * @param {string} token Unique identifier of the bundle to clone.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing bundle tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneBundle(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneBundle(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BundlesApi.cloneBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a bundle.
         * @summary Create bundle
         * @param {BundleCreateReq} bundleCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBundle(bundleCreateReq: BundleCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBundle(bundleCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BundlesApi.createBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of bundles.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List bundles
         * @param {number} [count] Number of bundles resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListBundlesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, not by the field names appearing in response bodies: for example, &#x60;last_modified_time&#x60;.
         * @param {Array<BundleResourceStatus>} [status] An array of statuses by which to filter bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBundles(count?: number, startIndex?: number, sortBy?: ListBundlesSortByEnum, status?: Array<BundleResourceStatus>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleResponsePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBundles(count, startIndex, sortBy, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BundlesApi.listBundles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of related product bundles.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List related bundles
         * @param {string} token Unique identifier of the parent product bundle.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing product bundles tokens.
         * @param {number} [count] Number of related bundle product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRelatedBundlesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<BundleResourceStatus>} [status] Array of statuses by which to filter bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRelatedBundles(token: string, count?: number, startIndex?: number, sortBy?: ListRelatedBundlesSortByEnum, status?: Array<BundleResourceStatus>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleResponsePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRelatedBundles(token, count, startIndex, sortBy, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BundlesApi.listRelatedBundles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Promote a specific bundle that replaces the current active bundle and activates the promoted bundle.
         * @summary Promote bundle
         * @param {string} token Unique identifier of the bundle to promote.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing bundle tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoteBundle(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoteBundle(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BundlesApi.promoteBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific bundle.
         * @summary Retrieve bundle
         * @param {string} token Unique identifier of the bundle to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {Array<PolicyType>} [expandObjects] Embeds the associated object of the specified type into the response. For more, see &lt;&lt;/core-api/object-expansion, object expansion&gt;&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBundle(token: string, expandObjects?: Array<PolicyType>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBundle(token, expandObjects, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BundlesApi.retrieveBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transition the status of a specific bundle.
         * @summary Transition a bundle
         * @param {string} token Token of the bundle whose status you want to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {BundleTransitionReq} bundleTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionBundle(token: string, bundleTransitionReq: BundleTransitionReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionBundle(token, bundleTransitionReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BundlesApi.transitionBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific bundle that is not `ACTIVE` or `ARCHIVED`. Bundles are created in a `DRAFT` state, and are still modifiable at this point. Using the transitions endpoint, a bundle can be transitioned from `DRAFT`, to `ACTIVE`. Once a bundle is active, it cannot be modified.
         * @summary Update bundle
         * @param {string} token Token of the bundle to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {BundleUpdateReq} bundleUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBundle(token: string, bundleUpdateReq: BundleUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BundleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBundle(token, bundleUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BundlesApi.updateBundle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BundlesApi - factory interface
 */
export const BundlesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BundlesApiFp(configuration)
    return {
        /**
         * Create a new bundle based on an existing bundle.
         * @summary Clone bundle
         * @param {string} token Unique identifier of the bundle to clone.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing bundle tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneBundle(token: string, options?: RawAxiosRequestConfig): AxiosPromise<BundleResponse> {
            return localVarFp.cloneBundle(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a bundle.
         * @summary Create bundle
         * @param {BundleCreateReq} bundleCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundle(bundleCreateReq: BundleCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<BundleResponse> {
            return localVarFp.createBundle(bundleCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of bundles.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List bundles
         * @param {number} [count] Number of bundles resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListBundlesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, not by the field names appearing in response bodies: for example, &#x60;last_modified_time&#x60;.
         * @param {Array<BundleResourceStatus>} [status] An array of statuses by which to filter bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBundles(count?: number, startIndex?: number, sortBy?: ListBundlesSortByEnum, status?: Array<BundleResourceStatus>, options?: RawAxiosRequestConfig): AxiosPromise<BundleResponsePage> {
            return localVarFp.listBundles(count, startIndex, sortBy, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of related product bundles.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List related bundles
         * @param {string} token Unique identifier of the parent product bundle.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing product bundles tokens.
         * @param {number} [count] Number of related bundle product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRelatedBundlesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<BundleResourceStatus>} [status] Array of statuses by which to filter bundles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelatedBundles(token: string, count?: number, startIndex?: number, sortBy?: ListRelatedBundlesSortByEnum, status?: Array<BundleResourceStatus>, options?: RawAxiosRequestConfig): AxiosPromise<BundleResponsePage> {
            return localVarFp.listRelatedBundles(token, count, startIndex, sortBy, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Promote a specific bundle that replaces the current active bundle and activates the promoted bundle.
         * @summary Promote bundle
         * @param {string} token Unique identifier of the bundle to promote.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing bundle tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteBundle(token: string, options?: RawAxiosRequestConfig): AxiosPromise<BundleResponse> {
            return localVarFp.promoteBundle(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific bundle.
         * @summary Retrieve bundle
         * @param {string} token Unique identifier of the bundle to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {Array<PolicyType>} [expandObjects] Embeds the associated object of the specified type into the response. For more, see &lt;&lt;/core-api/object-expansion, object expansion&gt;&gt;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBundle(token: string, expandObjects?: Array<PolicyType>, options?: RawAxiosRequestConfig): AxiosPromise<BundleResponse> {
            return localVarFp.retrieveBundle(token, expandObjects, options).then((request) => request(axios, basePath));
        },
        /**
         * Transition the status of a specific bundle.
         * @summary Transition a bundle
         * @param {string} token Token of the bundle whose status you want to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {BundleTransitionReq} bundleTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionBundle(token: string, bundleTransitionReq: BundleTransitionReq, options?: RawAxiosRequestConfig): AxiosPromise<BundleTransitionResponse> {
            return localVarFp.transitionBundle(token, bundleTransitionReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific bundle that is not `ACTIVE` or `ARCHIVED`. Bundles are created in a `DRAFT` state, and are still modifiable at this point. Using the transitions endpoint, a bundle can be transitioned from `DRAFT`, to `ACTIVE`. Once a bundle is active, it cannot be modified.
         * @summary Update bundle
         * @param {string} token Token of the bundle to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
         * @param {BundleUpdateReq} bundleUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBundle(token: string, bundleUpdateReq: BundleUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<BundleResponse> {
            return localVarFp.updateBundle(token, bundleUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BundlesApi - object-oriented interface
 */
export class BundlesApi extends BaseAPI {
    /**
     * Create a new bundle based on an existing bundle.
     * @summary Clone bundle
     * @param {string} token Unique identifier of the bundle to clone.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing bundle tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cloneBundle(token: string, options?: RawAxiosRequestConfig) {
        return BundlesApiFp(this.configuration).cloneBundle(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a bundle.
     * @summary Create bundle
     * @param {BundleCreateReq} bundleCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createBundle(bundleCreateReq: BundleCreateReq, options?: RawAxiosRequestConfig) {
        return BundlesApiFp(this.configuration).createBundle(bundleCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of bundles.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List bundles
     * @param {number} [count] Number of bundles resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListBundlesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, not by the field names appearing in response bodies: for example, &#x60;last_modified_time&#x60;.
     * @param {Array<BundleResourceStatus>} [status] An array of statuses by which to filter bundles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listBundles(count?: number, startIndex?: number, sortBy?: ListBundlesSortByEnum, status?: Array<BundleResourceStatus>, options?: RawAxiosRequestConfig) {
        return BundlesApiFp(this.configuration).listBundles(count, startIndex, sortBy, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of related product bundles.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List related bundles
     * @param {string} token Unique identifier of the parent product bundle.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing product bundles tokens.
     * @param {number} [count] Number of related bundle product resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListRelatedBundlesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {Array<BundleResourceStatus>} [status] Array of statuses by which to filter bundles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRelatedBundles(token: string, count?: number, startIndex?: number, sortBy?: ListRelatedBundlesSortByEnum, status?: Array<BundleResourceStatus>, options?: RawAxiosRequestConfig) {
        return BundlesApiFp(this.configuration).listRelatedBundles(token, count, startIndex, sortBy, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Promote a specific bundle that replaces the current active bundle and activates the promoted bundle.
     * @summary Promote bundle
     * @param {string} token Unique identifier of the bundle to promote.  Send a &#x60;GET&#x60; request to &#x60;/bundles&#x60; to retrieve existing bundle tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public promoteBundle(token: string, options?: RawAxiosRequestConfig) {
        return BundlesApiFp(this.configuration).promoteBundle(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific bundle.
     * @summary Retrieve bundle
     * @param {string} token Unique identifier of the bundle to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
     * @param {Array<PolicyType>} [expandObjects] Embeds the associated object of the specified type into the response. For more, see &lt;&lt;/core-api/object-expansion, object expansion&gt;&gt;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveBundle(token: string, expandObjects?: Array<PolicyType>, options?: RawAxiosRequestConfig) {
        return BundlesApiFp(this.configuration).retrieveBundle(token, expandObjects, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transition the status of a specific bundle.
     * @summary Transition a bundle
     * @param {string} token Token of the bundle whose status you want to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
     * @param {BundleTransitionReq} bundleTransitionReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transitionBundle(token: string, bundleTransitionReq: BundleTransitionReq, options?: RawAxiosRequestConfig) {
        return BundlesApiFp(this.configuration).transitionBundle(token, bundleTransitionReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific bundle that is not `ACTIVE` or `ARCHIVED`. Bundles are created in a `DRAFT` state, and are still modifiable at this point. Using the transitions endpoint, a bundle can be transitioned from `DRAFT`, to `ACTIVE`. Once a bundle is active, it cannot be modified.
     * @summary Update bundle
     * @param {string} token Token of the bundle to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/bundles&#x60; to retrieve existing  tokens.
     * @param {BundleUpdateReq} bundleUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateBundle(token: string, bundleUpdateReq: BundleUpdateReq, options?: RawAxiosRequestConfig) {
        return BundlesApiFp(this.configuration).updateBundle(token, bundleUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListBundlesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListBundlesSortByEnum = typeof ListBundlesSortByEnum[keyof typeof ListBundlesSortByEnum];
export const ListRelatedBundlesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListRelatedBundlesSortByEnum = typeof ListRelatedBundlesSortByEnum[keyof typeof ListRelatedBundlesSortByEnum];


/**
 * BusinessTransitionsApi - axios parameter creator
 */
export const BusinessTransitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns transitions for a given business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of business transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsBusinessBusinesstoken: async (businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessToken' is not null or undefined
            assertParamExists('getBusinesstransitionsBusinessBusinesstoken', 'businessToken', businessToken)
            const localVarPath = `/businesstransitions/business/{business_token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a business transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBusinesstransitionsToken', 'token', token)
            const localVarPath = `/businesstransitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a business transition
         * @param {BusinessTransitionRequest} [businessTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesstransitions: async (businessTransitionRequest?: BusinessTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/businesstransitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(businessTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessTransitionsApi - functional programming interface
 */
export const BusinessTransitionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessTransitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns transitions for a given business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of business transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinesstransitionsBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessTransitionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinesstransitionsBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessTransitionsApi.getBusinesstransitionsBusinessBusinesstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a business transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinesstransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinesstransitionsToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessTransitionsApi.getBusinesstransitionsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a business transition
         * @param {BusinessTransitionRequest} [businessTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBusinesstransitions(businessTransitionRequest?: BusinessTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBusinesstransitions(businessTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessTransitionsApi.postBusinesstransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BusinessTransitionsApi - factory interface
 */
export const BusinessTransitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessTransitionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns transitions for a given business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of business transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<BusinessTransitionListResponse> {
            return localVarFp.getBusinesstransitionsBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a business transition
         * @param {string} token Transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesstransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<BusinessTransitionResponse> {
            return localVarFp.getBusinesstransitionsToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a business transition
         * @param {BusinessTransitionRequest} [businessTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesstransitions(businessTransitionRequest?: BusinessTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<BusinessTransitionResponse> {
            return localVarFp.postBusinesstransitions(businessTransitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BusinessTransitionsApi - object-oriented interface
 */
export class BusinessTransitionsApi extends BaseAPI {
    /**
     * 
     * @summary Returns transitions for a given business
     * @param {string} businessToken Business token
     * @param {number} [count] Number of business transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinesstransitionsBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return BusinessTransitionsApiFp(this.configuration).getBusinesstransitionsBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a business transition
     * @param {string} token Transition token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinesstransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return BusinessTransitionsApiFp(this.configuration).getBusinesstransitionsToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a business transition
     * @param {BusinessTransitionRequest} [businessTransitionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBusinesstransitions(businessTransitionRequest?: BusinessTransitionRequest, options?: RawAxiosRequestConfig) {
        return BusinessTransitionsApiFp(this.configuration).postBusinesstransitions(businessTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BusinessesApi - axios parameter creator
 */
export const BusinessesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a specific business director
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessDirectorToken: async (businessToken: string, token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessToken' is not null or undefined
            assertParamExists('getBusinessDirectorToken', 'businessToken', businessToken)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBusinessDirectorToken', 'token', token)
            const localVarPath = `/businesses/{business_token}/directors/{token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific business director\'s SSN
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessDirectorTokenSsn: async (businessToken: string, token: string, fullSsn?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessToken' is not null or undefined
            assertParamExists('getBusinessDirectorTokenSsn', 'businessToken', businessToken)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBusinessDirectorTokenSsn', 'token', token)
            const localVarPath = `/businesses/{business_token}/directors/{token}/identifications`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fullSsn !== undefined) {
                localVarQueryParameter['full_ssn'] = fullSsn;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all businesses
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [businessNameDba] Business name DBA
         * @param {string} [businessNameLegal] Business name legal
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesses: async (count?: number, startIndex?: number, businessNameDba?: string, businessNameLegal?: string, searchType?: string, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/businesses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (businessNameDba !== undefined) {
                localVarQueryParameter['business_name_dba'] = businessNameDba;
            }

            if (businessNameLegal !== undefined) {
                localVarQueryParameter['business_name_legal'] = businessNameLegal;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all children of a parent business
         * @param {string} parentToken Token of parent business
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesParenttokenChildren: async (parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentToken' is not null or undefined
            assertParamExists('getBusinessesParenttokenChildren', 'parentToken', parentToken)
            const localVarPath = `/businesses/{parent_token}/children`
                .replace(`{${"parent_token"}}`, encodeURIComponent(String(parentToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {string} token Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBusinessesToken', 'token', token)
            const localVarPath = `/businesses/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists business notes
         * @param {string} token Business token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenNotes: async (token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBusinessesTokenNotes', 'token', token)
            const localVarPath = `/businesses/{token}/notes`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (createdByUserRole !== undefined) {
                localVarQueryParameter['created_by_user_role'] = createdByUserRole;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['include_private'] = includePrivate;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific business proprietor\'s SSN
         * @param {string} token Business token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenSsn: async (token: string, fullSsn?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBusinessesTokenSsn', 'token', token)
            const localVarPath = `/businesses/{token}/ssn`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fullSsn !== undefined) {
                localVarQueryParameter['full_ssn'] = fullSsn;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a business
         * @param {BusinessCardholder} [businessCardholder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesses: async (businessCardholder?: BusinessCardholder, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/businesses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(businessCardholder, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {DDARequest} [dDARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesLookup: async (dDARequest?: DDARequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/businesses/lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(dDARequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a BusinessDirector for a business
         * @param {string} businessToken Business token
         * @param {BusinessDirectorRequestModel} [businessDirectorRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesTokenDirectors: async (businessToken: string, businessDirectorRequestModel?: BusinessDirectorRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessToken' is not null or undefined
            assertParamExists('postBusinessesTokenDirectors', 'businessToken', businessToken)
            const localVarPath = `/businesses/{business_token}/directors`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(businessDirectorRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a note for a business
         * @param {string} token Business token
         * @param {CardholderNoteRequestModel} [cardholderNoteRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesTokenNotes: async (token: string, cardholderNoteRequestModel?: CardholderNoteRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postBusinessesTokenNotes', 'token', token)
            const localVarPath = `/businesses/{token}/notes`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardholderNoteRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific business
         * @param {string} token Business token
         * @param {BusinessCardHolderUpdate} businessCardHolderUpdate Business object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesToken: async (token: string, businessCardHolderUpdate: BusinessCardHolderUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putBusinessesToken', 'token', token)
            // verify required parameter 'businessCardHolderUpdate' is not null or undefined
            assertParamExists('putBusinessesToken', 'businessCardHolderUpdate', businessCardHolderUpdate)
            const localVarPath = `/businesses/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(businessCardHolderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific business director for a business
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {BusinessDirectorRequestModel} [businessDirectorRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesTokenBusinessDirectorToken: async (businessToken: string, token: string, businessDirectorRequestModel?: BusinessDirectorRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessToken' is not null or undefined
            assertParamExists('putBusinessesTokenBusinessDirectorToken', 'businessToken', businessToken)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putBusinessesTokenBusinessDirectorToken', 'token', token)
            const localVarPath = `/businesses/{business_token}/directors/{token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(businessDirectorRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific note for a business
         * @param {string} token Business token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [cardholderNoteUpdateRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesTokenNotesNotestoken: async (token: string, notesToken: string, cardholderNoteUpdateRequestModel?: CardholderNoteUpdateRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putBusinessesTokenNotesNotestoken', 'token', token)
            // verify required parameter 'notesToken' is not null or undefined
            assertParamExists('putBusinessesTokenNotesNotestoken', 'notesToken', notesToken)
            const localVarPath = `/businesses/{token}/notes/{notes_token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"notes_token"}}`, encodeURIComponent(String(notesToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardholderNoteUpdateRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessesApi - functional programming interface
 */
export const BusinessesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a specific business director
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessDirectorToken(businessToken: string, token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessDirectorRequestModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessDirectorToken(businessToken, token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.getBusinessDirectorToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific business director\'s SSN
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessDirectorTokenSsn(businessToken: string, token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsnResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessDirectorTokenSsn(businessToken, token, fullSsn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.getBusinessDirectorTokenSsn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all businesses
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [businessNameDba] Business name DBA
         * @param {string} [businessNameLegal] Business name legal
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinesses(count?: number, startIndex?: number, businessNameDba?: string, businessNameLegal?: string, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessCardHolderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinesses(count, startIndex, businessNameDba, businessNameLegal, searchType, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.getBusinesses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all children of a parent business
         * @param {string} parentToken Token of parent business
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessesParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessUserCardHolderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessesParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.getBusinessesParenttokenChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {string} token Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessesToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessCardHolderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessesToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.getBusinessesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists business notes
         * @param {string} token Business token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessesTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardHolderNoteListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessesTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.getBusinessesTokenNotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific business proprietor\'s SSN
         * @param {string} token Business token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessesTokenSsn(token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsnResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessesTokenSsn(token, fullSsn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.getBusinessesTokenSsn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a business
         * @param {BusinessCardholder} [businessCardholder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBusinesses(businessCardholder?: BusinessCardholder, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessCardHolderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBusinesses(businessCardholder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.postBusinesses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {DDARequest} [dDARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBusinessesLookup(dDARequest?: DDARequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessCardholder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBusinessesLookup(dDARequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.postBusinessesLookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a BusinessDirector for a business
         * @param {string} businessToken Business token
         * @param {BusinessDirectorRequestModel} [businessDirectorRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBusinessesTokenDirectors(businessToken: string, businessDirectorRequestModel?: BusinessDirectorRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderNoteResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBusinessesTokenDirectors(businessToken, businessDirectorRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.postBusinessesTokenDirectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a note for a business
         * @param {string} token Business token
         * @param {CardholderNoteRequestModel} [cardholderNoteRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBusinessesTokenNotes(token: string, cardholderNoteRequestModel?: CardholderNoteRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderNoteResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postBusinessesTokenNotes(token, cardholderNoteRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.postBusinessesTokenNotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific business
         * @param {string} token Business token
         * @param {BusinessCardHolderUpdate} businessCardHolderUpdate Business object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBusinessesToken(token: string, businessCardHolderUpdate: BusinessCardHolderUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessCardholder>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBusinessesToken(token, businessCardHolderUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.putBusinessesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific business director for a business
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {BusinessDirectorRequestModel} [businessDirectorRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBusinessesTokenBusinessDirectorToken(businessToken: string, token: string, businessDirectorRequestModel?: BusinessDirectorRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessDirectorResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBusinessesTokenBusinessDirectorToken(businessToken, token, businessDirectorRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.putBusinessesTokenBusinessDirectorToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific note for a business
         * @param {string} token Business token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [cardholderNoteUpdateRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBusinessesTokenNotesNotestoken(token: string, notesToken: string, cardholderNoteUpdateRequestModel?: CardholderNoteUpdateRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderNoteResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putBusinessesTokenNotesNotestoken(token, notesToken, cardholderNoteUpdateRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessesApi.putBusinessesTokenNotesNotestoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BusinessesApi - factory interface
 */
export const BusinessesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a specific business director
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessDirectorToken(businessToken: string, token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<BusinessDirectorRequestModel> {
            return localVarFp.getBusinessDirectorToken(businessToken, token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific business director\'s SSN
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessDirectorTokenSsn(businessToken: string, token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SsnResponseModel> {
            return localVarFp.getBusinessDirectorTokenSsn(businessToken, token, fullSsn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all businesses
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [businessNameDba] Business name DBA
         * @param {string} [businessNameLegal] Business name legal
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinesses(count?: number, startIndex?: number, businessNameDba?: string, businessNameLegal?: string, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<BusinessCardHolderListResponse> {
            return localVarFp.getBusinesses(count, startIndex, businessNameDba, businessNameLegal, searchType, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all children of a parent business
         * @param {string} parentToken Token of parent business
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<BusinessUserCardHolderListResponse> {
            return localVarFp.getBusinessesParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {string} token Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<BusinessCardHolderResponse> {
            return localVarFp.getBusinessesToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists business notes
         * @param {string} token Business token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardHolderNoteListResponse> {
            return localVarFp.getBusinessesTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific business proprietor\'s SSN
         * @param {string} token Business token
         * @param {boolean} [fullSsn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessesTokenSsn(token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SsnResponseModel> {
            return localVarFp.getBusinessesTokenSsn(token, fullSsn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a business
         * @param {BusinessCardholder} [businessCardholder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinesses(businessCardholder?: BusinessCardholder, options?: RawAxiosRequestConfig): AxiosPromise<BusinessCardHolderResponse> {
            return localVarFp.postBusinesses(businessCardholder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific business
         * @param {DDARequest} [dDARequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesLookup(dDARequest?: DDARequest, options?: RawAxiosRequestConfig): AxiosPromise<BusinessCardholder> {
            return localVarFp.postBusinessesLookup(dDARequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a BusinessDirector for a business
         * @param {string} businessToken Business token
         * @param {BusinessDirectorRequestModel} [businessDirectorRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesTokenDirectors(businessToken: string, businessDirectorRequestModel?: BusinessDirectorRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<CardholderNoteResponseModel> {
            return localVarFp.postBusinessesTokenDirectors(businessToken, businessDirectorRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a note for a business
         * @param {string} token Business token
         * @param {CardholderNoteRequestModel} [cardholderNoteRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBusinessesTokenNotes(token: string, cardholderNoteRequestModel?: CardholderNoteRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<CardholderNoteResponseModel> {
            return localVarFp.postBusinessesTokenNotes(token, cardholderNoteRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific business
         * @param {string} token Business token
         * @param {BusinessCardHolderUpdate} businessCardHolderUpdate Business object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesToken(token: string, businessCardHolderUpdate: BusinessCardHolderUpdate, options?: RawAxiosRequestConfig): AxiosPromise<BusinessCardholder> {
            return localVarFp.putBusinessesToken(token, businessCardHolderUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific business director for a business
         * @param {string} businessToken Business token
         * @param {string} token Business Director token
         * @param {BusinessDirectorRequestModel} [businessDirectorRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesTokenBusinessDirectorToken(businessToken: string, token: string, businessDirectorRequestModel?: BusinessDirectorRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<BusinessDirectorResponseModel> {
            return localVarFp.putBusinessesTokenBusinessDirectorToken(businessToken, token, businessDirectorRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific note for a business
         * @param {string} token Business token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [cardholderNoteUpdateRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBusinessesTokenNotesNotestoken(token: string, notesToken: string, cardholderNoteUpdateRequestModel?: CardholderNoteUpdateRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<CardholderNoteResponseModel> {
            return localVarFp.putBusinessesTokenNotesNotestoken(token, notesToken, cardholderNoteUpdateRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BusinessesApi - object-oriented interface
 */
export class BusinessesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a specific business director
     * @param {string} businessToken Business token
     * @param {string} token Business Director token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinessDirectorToken(businessToken: string, token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).getBusinessDirectorToken(businessToken, token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific business director\'s SSN
     * @param {string} businessToken Business token
     * @param {string} token Business Director token
     * @param {boolean} [fullSsn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinessDirectorTokenSsn(businessToken: string, token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).getBusinessDirectorTokenSsn(businessToken, token, fullSsn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all businesses
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [businessNameDba] Business name DBA
     * @param {string} [businessNameLegal] Business name legal
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinesses(count?: number, startIndex?: number, businessNameDba?: string, businessNameLegal?: string, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).getBusinesses(count, startIndex, businessNameDba, businessNameLegal, searchType, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all children of a parent business
     * @param {string} parentToken Token of parent business
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinessesParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).getBusinessesParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific business
     * @param {string} token Business token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinessesToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).getBusinessesToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists business notes
     * @param {string} token Business token
     * @param {number} [startIndex] Start index
     * @param {number} [count] Number of notes to retrieve
     * @param {string} [createdBy] Created by
     * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
     * @param {boolean} [includePrivate] Include private notes and private fields in note response
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinessesTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).getBusinessesTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific business proprietor\'s SSN
     * @param {string} token Business token
     * @param {boolean} [fullSsn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBusinessesTokenSsn(token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).getBusinessesTokenSsn(token, fullSsn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a business
     * @param {BusinessCardholder} [businessCardholder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBusinesses(businessCardholder?: BusinessCardholder, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).postBusinesses(businessCardholder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific business
     * @param {DDARequest} [dDARequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBusinessesLookup(dDARequest?: DDARequest, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).postBusinessesLookup(dDARequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a BusinessDirector for a business
     * @param {string} businessToken Business token
     * @param {BusinessDirectorRequestModel} [businessDirectorRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBusinessesTokenDirectors(businessToken: string, businessDirectorRequestModel?: BusinessDirectorRequestModel, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).postBusinessesTokenDirectors(businessToken, businessDirectorRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a note for a business
     * @param {string} token Business token
     * @param {CardholderNoteRequestModel} [cardholderNoteRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postBusinessesTokenNotes(token: string, cardholderNoteRequestModel?: CardholderNoteRequestModel, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).postBusinessesTokenNotes(token, cardholderNoteRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific business
     * @param {string} token Business token
     * @param {BusinessCardHolderUpdate} businessCardHolderUpdate Business object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putBusinessesToken(token: string, businessCardHolderUpdate: BusinessCardHolderUpdate, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).putBusinessesToken(token, businessCardHolderUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific business director for a business
     * @param {string} businessToken Business token
     * @param {string} token Business Director token
     * @param {BusinessDirectorRequestModel} [businessDirectorRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putBusinessesTokenBusinessDirectorToken(businessToken: string, token: string, businessDirectorRequestModel?: BusinessDirectorRequestModel, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).putBusinessesTokenBusinessDirectorToken(businessToken, token, businessDirectorRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific note for a business
     * @param {string} token Business token
     * @param {string} notesToken Notes token
     * @param {CardholderNoteUpdateRequestModel} [cardholderNoteUpdateRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putBusinessesTokenNotesNotestoken(token: string, notesToken: string, cardholderNoteUpdateRequestModel?: CardholderNoteUpdateRequestModel, options?: RawAxiosRequestConfig) {
        return BusinessesApiFp(this.configuration).putBusinessesTokenNotesNotestoken(token, notesToken, cardholderNoteUpdateRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CardGroupApi - axios parameter creator
 */
export const CardGroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new card group object
         * @summary Create Card Group
         * @param {CardGroupReq} cardGroupReq Card group to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCardGroup: async (cardGroupReq: CardGroupReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardGroupReq' is not null or undefined
            assertParamExists('createCardGroup', 'cardGroupReq', cardGroupReq)
            const localVarPath = `/cardgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardGroupReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all card groups in the program
         * @summary List Card Groups
         * @param {Array<string>} [cardTokens] list of unique card identifiers to retrieve.
         * @param {number} [count] Number of card group resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCardGroups: async (cardTokens?: Array<string>, count?: number, startIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cardgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cardTokens) {
                localVarQueryParameter['card_tokens'] = cardTokens;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Card Group with the given token
         * @summary Retrieve Card Group
         * @param {string} token Unique identifier of the card group to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCardGroup: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrieveCardGroup', 'token', token)
            const localVarPath = `/cardgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardGroupApi - functional programming interface
 */
export const CardGroupApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CardGroupApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new card group object
         * @summary Create Card Group
         * @param {CardGroupReq} cardGroupReq Card group to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCardGroup(cardGroupReq: CardGroupReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCardGroup(cardGroupReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardGroupApi.createCardGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all card groups in the program
         * @summary List Card Groups
         * @param {Array<string>} [cardTokens] list of unique card identifiers to retrieve.
         * @param {number} [count] Number of card group resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCardGroups(cardTokens?: Array<string>, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardGroupPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCardGroups(cardTokens, count, startIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardGroupApi.listCardGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Card Group with the given token
         * @summary Retrieve Card Group
         * @param {string} token Unique identifier of the card group to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCardGroup(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCardGroup(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardGroupApi.retrieveCardGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardGroupApi - factory interface
 */
export const CardGroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardGroupApiFp(configuration)
    return {
        /**
         * Create a new card group object
         * @summary Create Card Group
         * @param {CardGroupReq} cardGroupReq Card group to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCardGroup(cardGroupReq: CardGroupReq, options?: RawAxiosRequestConfig): AxiosPromise<CardGroup> {
            return localVarFp.createCardGroup(cardGroupReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all card groups in the program
         * @summary List Card Groups
         * @param {Array<string>} [cardTokens] list of unique card identifiers to retrieve.
         * @param {number} [count] Number of card group resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCardGroups(cardTokens?: Array<string>, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<CardGroupPage> {
            return localVarFp.listCardGroups(cardTokens, count, startIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Card Group with the given token
         * @summary Retrieve Card Group
         * @param {string} token Unique identifier of the card group to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCardGroup(token: string, options?: RawAxiosRequestConfig): AxiosPromise<CardGroup> {
            return localVarFp.retrieveCardGroup(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardGroupApi - object-oriented interface
 */
export class CardGroupApi extends BaseAPI {
    /**
     * Create a new card group object
     * @summary Create Card Group
     * @param {CardGroupReq} cardGroupReq Card group to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCardGroup(cardGroupReq: CardGroupReq, options?: RawAxiosRequestConfig) {
        return CardGroupApiFp(this.configuration).createCardGroup(cardGroupReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all card groups in the program
     * @summary List Card Groups
     * @param {Array<string>} [cardTokens] list of unique card identifiers to retrieve.
     * @param {number} [count] Number of card group resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listCardGroups(cardTokens?: Array<string>, count?: number, startIndex?: number, options?: RawAxiosRequestConfig) {
        return CardGroupApiFp(this.configuration).listCardGroups(cardTokens, count, startIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Card Group with the given token
     * @summary Retrieve Card Group
     * @param {string} token Unique identifier of the card group to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveCardGroup(token: string, options?: RawAxiosRequestConfig) {
        return CardGroupApiFp(this.configuration).retrieveCardGroup(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CardProductsApi - axios parameter creator
 */
export const CardProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all card products
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproducts: async (count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cardproducts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific card product
         * @param {string} token Card product token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproductsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCardproductsToken', 'token', token)
            const localVarPath = `/cardproducts/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a card product
         * @param {CardProductRequest} cardProductRequest Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardproducts: async (cardProductRequest: CardProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardProductRequest' is not null or undefined
            assertParamExists('postCardproducts', 'cardProductRequest', cardProductRequest)
            const localVarPath = `/cardproducts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific card product
         * @param {string} token Card product token
         * @param {CardProductUpdateModel} cardProductUpdateModel Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardproductsToken: async (token: string, cardProductUpdateModel: CardProductUpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putCardproductsToken', 'token', token)
            // verify required parameter 'cardProductUpdateModel' is not null or undefined
            assertParamExists('putCardproductsToken', 'cardProductUpdateModel', cardProductUpdateModel)
            const localVarPath = `/cardproducts/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardProductUpdateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardProductsApi - functional programming interface
 */
export const CardProductsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CardProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all card products
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardproducts(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardproducts(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardProductsApi.getCardproducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific card product
         * @param {string} token Card product token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardproductsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardproductsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardProductsApi.getCardproductsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a card product
         * @param {CardProductRequest} cardProductRequest Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCardproducts(cardProductRequest: CardProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCardproducts(cardProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardProductsApi.postCardproducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific card product
         * @param {string} token Card product token
         * @param {CardProductUpdateModel} cardProductUpdateModel Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCardproductsToken(token: string, cardProductUpdateModel: CardProductUpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCardproductsToken(token, cardProductUpdateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardProductsApi.putCardproductsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardProductsApi - factory interface
 */
export const CardProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all card products
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproducts(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardProductListResponse> {
            return localVarFp.getCardproducts(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific card product
         * @param {string} token Card product token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardproductsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<CardProductResponse> {
            return localVarFp.getCardproductsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a card product
         * @param {CardProductRequest} cardProductRequest Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardproducts(cardProductRequest: CardProductRequest, options?: RawAxiosRequestConfig): AxiosPromise<CardProductResponse> {
            return localVarFp.postCardproducts(cardProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific card product
         * @param {string} token Card product token
         * @param {CardProductUpdateModel} cardProductUpdateModel Card product object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardproductsToken(token: string, cardProductUpdateModel: CardProductUpdateModel, options?: RawAxiosRequestConfig): AxiosPromise<CardProductResponse> {
            return localVarFp.putCardproductsToken(token, cardProductUpdateModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardProductsApi - object-oriented interface
 */
export class CardProductsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all card products
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardproducts(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return CardProductsApiFp(this.configuration).getCardproducts(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific card product
     * @param {string} token Card product token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardproductsToken(token: string, options?: RawAxiosRequestConfig) {
        return CardProductsApiFp(this.configuration).getCardproductsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a card product
     * @param {CardProductRequest} cardProductRequest Card product object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCardproducts(cardProductRequest: CardProductRequest, options?: RawAxiosRequestConfig) {
        return CardProductsApiFp(this.configuration).postCardproducts(cardProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific card product
     * @param {string} token Card product token
     * @param {CardProductUpdateModel} cardProductUpdateModel Card product object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putCardproductsToken(token: string, cardProductUpdateModel: CardProductUpdateModel, options?: RawAxiosRequestConfig) {
        return CardProductsApiFp(this.configuration).putCardproductsToken(token, cardProductUpdateModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CardTransitionsApi - axios parameter creator
 */
export const CardTransitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all card transitions
         * @param {string} token Card token
         * @param {number} [count] Number of card transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsCardToken: async (token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCardtransitionsCardToken', 'token', token)
            const localVarPath = `/cardtransitions/card/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a card transition object
         * @param {string} token Card transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCardtransitionsToken', 'token', token)
            const localVarPath = `/cardtransitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a card transition object
         * @param {CardTransitionRequest} [cardTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardtransitions: async (cardTransitionRequest?: CardTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cardtransitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardTransitionsApi - functional programming interface
 */
export const CardTransitionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CardTransitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all card transitions
         * @param {string} token Card token
         * @param {number} [count] Number of card transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardtransitionsCardToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardTransitionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardtransitionsCardToken(token, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardTransitionsApi.getCardtransitionsCardToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a card transition object
         * @param {string} token Card transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardtransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardtransitionsToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardTransitionsApi.getCardtransitionsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a card transition object
         * @param {CardTransitionRequest} [cardTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCardtransitions(cardTransitionRequest?: CardTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCardtransitions(cardTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardTransitionsApi.postCardtransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardTransitionsApi - factory interface
 */
export const CardTransitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardTransitionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all card transitions
         * @param {string} token Card token
         * @param {number} [count] Number of card transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsCardToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardTransitionListResponse> {
            return localVarFp.getCardtransitionsCardToken(token, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a card transition object
         * @param {string} token Card transition token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardtransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardTransitionResponse> {
            return localVarFp.getCardtransitionsToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a card transition object
         * @param {CardTransitionRequest} [cardTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardtransitions(cardTransitionRequest?: CardTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CardTransitionResponse> {
            return localVarFp.postCardtransitions(cardTransitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardTransitionsApi - object-oriented interface
 */
export class CardTransitionsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all card transitions
     * @param {string} token Card token
     * @param {number} [count] Number of card transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardtransitionsCardToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return CardTransitionsApiFp(this.configuration).getCardtransitionsCardToken(token, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a card transition object
     * @param {string} token Card transition token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardtransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return CardTransitionsApiFp(this.configuration).getCardtransitionsToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a card transition object
     * @param {CardTransitionRequest} [cardTransitionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCardtransitions(cardTransitionRequest?: CardTransitionRequest, options?: RawAxiosRequestConfig) {
        return CardTransitionsApiFp(this.configuration).postCardtransitions(cardTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CardholderBalancesApi - axios parameter creator
 */
export const CardholderBalancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * balances/account/{token}
         * @summary Returns account balance for an account
         * @param {string} token The unique token associated with the user or business account. This token is required to fetch the corresponding account balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalancesToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAccountBalancesToken', 'token', token)
            const localVarPath = `/balances/account/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns account balances for a cardholder
         * @param {string} token User or Business token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getBalancesToken', 'token', token)
            const localVarPath = `/balances/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * /balances/user/{token}
         * @summary Returns account balances for a cardholder
         * @param {string} token The unique token identifying the user or business. This token is required to retrieve the associated account balances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountBalances: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getUserAccountBalances', 'token', token)
            const localVarPath = `/balances/user/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardholderBalancesApi - functional programming interface
 */
export const CardholderBalancesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CardholderBalancesApiAxiosParamCreator(configuration)
    return {
        /**
         * balances/account/{token}
         * @summary Returns account balance for an account
         * @param {string} token The unique token associated with the user or business account. This token is required to fetch the corresponding account balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBalancesToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBalancesToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardholderBalancesApi.getAccountBalancesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns account balances for a cardholder
         * @param {string} token User or Business token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBalancesToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderBalances>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBalancesToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardholderBalancesApi.getBalancesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * /balances/user/{token}
         * @summary Returns account balances for a cardholder
         * @param {string} token The unique token identifying the user or business. This token is required to retrieve the associated account balances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAccountBalances(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccountsBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountBalances(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardholderBalancesApi.getUserAccountBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardholderBalancesApi - factory interface
 */
export const CardholderBalancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardholderBalancesApiFp(configuration)
    return {
        /**
         * balances/account/{token}
         * @summary Returns account balance for an account
         * @param {string} token The unique token associated with the user or business account. This token is required to fetch the corresponding account balance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalancesToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountBalanceResponse> {
            return localVarFp.getAccountBalancesToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns account balances for a cardholder
         * @param {string} token User or Business token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBalancesToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<CardholderBalances> {
            return localVarFp.getBalancesToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * /balances/user/{token}
         * @summary Returns account balances for a cardholder
         * @param {string} token The unique token identifying the user or business. This token is required to retrieve the associated account balances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAccountBalances(token: string, options?: RawAxiosRequestConfig): AxiosPromise<UserAccountsBalanceResponse> {
            return localVarFp.getUserAccountBalances(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardholderBalancesApi - object-oriented interface
 */
export class CardholderBalancesApi extends BaseAPI {
    /**
     * balances/account/{token}
     * @summary Returns account balance for an account
     * @param {string} token The unique token associated with the user or business account. This token is required to fetch the corresponding account balance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountBalancesToken(token: string, options?: RawAxiosRequestConfig) {
        return CardholderBalancesApiFp(this.configuration).getAccountBalancesToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns account balances for a cardholder
     * @param {string} token User or Business token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBalancesToken(token: string, options?: RawAxiosRequestConfig) {
        return CardholderBalancesApiFp(this.configuration).getBalancesToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * /balances/user/{token}
     * @summary Returns account balances for a cardholder
     * @param {string} token The unique token identifying the user or business. This token is required to retrieve the associated account balances.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserAccountBalances(token: string, options?: RawAxiosRequestConfig) {
        return CardholderBalancesApiFp(this.configuration).getUserAccountBalances(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CardsApi - axios parameter creator
 */
export const CardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists cards by the last 4 digits
         * @param {string} lastFour Last four digits of card number
         * @param {number} [count] Number of cards to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards: async (lastFour: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'lastFour' is not null or undefined
            assertParamExists('getCards', 'lastFour', lastFour)
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (lastFour !== undefined) {
                localVarQueryParameter['last_four'] = lastFour;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a card\'s metadata
         * @param {string} barcode Barcode
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsBarcodeBarcode: async (barcode: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('getCardsBarcodeBarcode', 'barcode', barcode)
            const localVarPath = `/cards/barcode/{barcode}`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific card
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [expand] Object to expand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsToken: async (token: string, fields?: string, expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCardsToken', 'token', token)
            const localVarPath = `/cards/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsTokenShowpan: async (token: string, fields?: string, showCvvNumber?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCardsTokenShowpan', 'token', token)
            const localVarPath = `/cards/{token}/showpan`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (showCvvNumber !== undefined) {
                localVarQueryParameter['show_cvv_number'] = showCvvNumber;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all cards for a specific user
         * @param {string} token User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsUserToken: async (token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCardsUserToken', 'token', token)
            const localVarPath = `/cards/user/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a card
         * @param {boolean} [showCvvNumber] Show CVV
         * @param {boolean} [showPan] Show PAN
         * @param {CardRequest} [cardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCards: async (showCvvNumber?: boolean, showPan?: boolean, cardRequest?: CardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (showCvvNumber !== undefined) {
                localVarQueryParameter['show_cvv_number'] = showCvvNumber;
            }

            if (showPan !== undefined) {
                localVarQueryParameter['show_pan'] = showPan;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns user and card tokens for the specified PAN
         * @param {PanRequest} [panRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardsGetbypan: async (panRequest?: PanRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cards/getbypan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(panRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific card
         * @param {string} token Card token
         * @param {CardUpdateRequest} [cardUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardsToken: async (token: string, cardUpdateRequest?: CardUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putCardsToken', 'token', token)
            const localVarPath = `/cards/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CardsApi - functional programming interface
 */
export const CardsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CardsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists cards by the last 4 digits
         * @param {string} lastFour Last four digits of card number
         * @param {number} [count] Number of cards to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCards(lastFour: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCards(lastFour, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.getCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a card\'s metadata
         * @param {string} barcode Barcode
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardsBarcodeBarcode(barcode: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardsBarcodeBarcode(barcode, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.getCardsBarcodeBarcode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific card
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [expand] Object to expand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardsToken(token: string, fields?: string, expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardsToken(token, fields, expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.getCardsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardsTokenShowpan(token: string, fields?: string, showCvvNumber?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardsTokenShowpan(token, fields, showCvvNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.getCardsTokenShowpan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all cards for a specific user
         * @param {string} token User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardsUserToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardsUserToken(token, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.getCardsUserToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a card
         * @param {boolean} [showCvvNumber] Show CVV
         * @param {boolean} [showPan] Show PAN
         * @param {CardRequest} [cardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCards(showCvvNumber?: boolean, showPan?: boolean, cardRequest?: CardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCards(showCvvNumber, showPan, cardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.postCards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns user and card tokens for the specified PAN
         * @param {PanRequest} [panRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCardsGetbypan(panRequest?: PanRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCardsGetbypan(panRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.postCardsGetbypan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific card
         * @param {string} token Card token
         * @param {CardUpdateRequest} [cardUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCardsToken(token: string, cardUpdateRequest?: CardUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putCardsToken(token, cardUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CardsApi.putCardsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CardsApi - factory interface
 */
export const CardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CardsApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists cards by the last 4 digits
         * @param {string} lastFour Last four digits of card number
         * @param {number} [count] Number of cards to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCards(lastFour: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardListResponse> {
            return localVarFp.getCards(lastFour, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a card\'s metadata
         * @param {string} barcode Barcode
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsBarcodeBarcode(barcode: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.getCardsBarcodeBarcode(barcode, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific card
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [expand] Object to expand
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsToken(token: string, fields?: string, expand?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.getCardsToken(token, fields, expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific card - PAN visible
         * @param {string} token Card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {boolean} [showCvvNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsTokenShowpan(token: string, fields?: string, showCvvNumber?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.getCardsTokenShowpan(token, fields, showCvvNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all cards for a specific user
         * @param {string} token User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsUserToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardListResponse> {
            return localVarFp.getCardsUserToken(token, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a card
         * @param {boolean} [showCvvNumber] Show CVV
         * @param {boolean} [showPan] Show PAN
         * @param {CardRequest} [cardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCards(showCvvNumber?: boolean, showPan?: boolean, cardRequest?: CardRequest, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.postCards(showCvvNumber, showPan, cardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns user and card tokens for the specified PAN
         * @param {PanRequest} [panRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCardsGetbypan(panRequest?: PanRequest, options?: RawAxiosRequestConfig): AxiosPromise<PanResponse> {
            return localVarFp.postCardsGetbypan(panRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific card
         * @param {string} token Card token
         * @param {CardUpdateRequest} [cardUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCardsToken(token: string, cardUpdateRequest?: CardUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CardResponse> {
            return localVarFp.putCardsToken(token, cardUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CardsApi - object-oriented interface
 */
export class CardsApi extends BaseAPI {
    /**
     * 
     * @summary Lists cards by the last 4 digits
     * @param {string} lastFour Last four digits of card number
     * @param {number} [count] Number of cards to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCards(lastFour: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).getCards(lastFour, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a card\'s metadata
     * @param {string} barcode Barcode
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardsBarcodeBarcode(barcode: string, fields?: string, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).getCardsBarcodeBarcode(barcode, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific card
     * @param {string} token Card token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [expand] Object to expand
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardsToken(token: string, fields?: string, expand?: string, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).getCardsToken(token, fields, expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific card - PAN visible
     * @param {string} token Card token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {boolean} [showCvvNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardsTokenShowpan(token: string, fields?: string, showCvvNumber?: boolean, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).getCardsTokenShowpan(token, fields, showCvvNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all cards for a specific user
     * @param {string} token User token
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardsUserToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).getCardsUserToken(token, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a card
     * @param {boolean} [showCvvNumber] Show CVV
     * @param {boolean} [showPan] Show PAN
     * @param {CardRequest} [cardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCards(showCvvNumber?: boolean, showPan?: boolean, cardRequest?: CardRequest, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).postCards(showCvvNumber, showPan, cardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns user and card tokens for the specified PAN
     * @param {PanRequest} [panRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postCardsGetbypan(panRequest?: PanRequest, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).postCardsGetbypan(panRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific card
     * @param {string} token Card token
     * @param {CardUpdateRequest} [cardUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putCardsToken(token: string, cardUpdateRequest?: CardUpdateRequest, options?: RawAxiosRequestConfig) {
        return CardsApiFp(this.configuration).putCardsToken(token, cardUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChargebacksApi - axios parameter creator
 */
export const ChargebacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all chargebacks
         * @param {number} [count] Number of chargebacks to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [networkReferenceId] Network reference ID
         * @param {string} [transactionToken] Transaction token
         * @param {string} [amount] Amount
         * @param {string} [states] Comma-delimited list of chargeback states to display e.g. INITIATED | REPRESENTMENT | PREARBITRATION | ARBITRATION | CASE_WON | CASE_LOST | NETWORK_REJECTED | WITHDRAWN | WRITTEN_OFF_ISSUER | WRITTEN_OFF_PROGRAM
         * @param {string} [sortBy] Sort order
         * @param {string} [networkCaseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacks: async (count?: number, startIndex?: number, networkReferenceId?: string, transactionToken?: string, amount?: string, states?: string, sortBy?: string, networkCaseId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chargebacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (networkReferenceId !== undefined) {
                localVarQueryParameter['network_reference_id'] = networkReferenceId;
            }

            if (transactionToken !== undefined) {
                localVarQueryParameter['transaction_token'] = transactionToken;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (networkCaseId !== undefined) {
                localVarQueryParameter['network_case_id'] = networkCaseId;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all chargeback transitions that are related to a chargeback
         * @param {string} chargebackToken Chargeback token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksChargebacktokenTransitions: async (chargebackToken: string, count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chargebackToken' is not null or undefined
            assertParamExists('getChargebacksChargebacktokenTransitions', 'chargebackToken', chargebackToken)
            const localVarPath = `/chargebacks/{chargeback_token}/transitions`
                .replace(`{${"chargeback_token"}}`, encodeURIComponent(String(chargebackToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific chargeback
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getChargebacksToken', 'token', token)
            const localVarPath = `/chargebacks/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific chargeback transition
         * @param {string} token Chargeback transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksTransitionsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getChargebacksTransitionsToken', 'token', token)
            const localVarPath = `/chargebacks/transitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a chargeback allocation acknowledgement
         * @param {ChargebackAllocationAckRequest} [chargebackAllocationAckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebackAllocationAcknowledgment: async (chargebackAllocationAckRequest?: ChargebackAllocationAckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chargebacks/allocationacknowledgement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(chargebackAllocationAckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a chargeback
         * @param {ChargebackRequest} [chargebackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacks: async (chargebackRequest?: ChargebackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chargebacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(chargebackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a chargeback transition
         * @param {ChargebackTransitionRequest} [chargebackTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacksTransitions: async (chargebackTransitionRequest?: ChargebackTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chargebacks/transitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(chargebackTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates chargeback data
         * @param {string} token 
         * @param {ChargebackUpdateRequest} [chargebackUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksToken: async (token: string, chargebackUpdateRequest?: ChargebackUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putChargebacksToken', 'token', token)
            const localVarPath = `/chargebacks/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(chargebackUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grants provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenGrantprovisionalcredit: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putChargebacksTokenGrantprovisionalcredit', 'token', token)
            const localVarPath = `/chargebacks/{token}/grantprovisionalcredit`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reverses provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenReverseprovisionalcredit: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putChargebacksTokenReverseprovisionalcredit', 'token', token)
            const localVarPath = `/chargebacks/{token}/reverseprovisionalcredit`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChargebacksApi - functional programming interface
 */
export const ChargebacksApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ChargebacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all chargebacks
         * @param {number} [count] Number of chargebacks to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [networkReferenceId] Network reference ID
         * @param {string} [transactionToken] Transaction token
         * @param {string} [amount] Amount
         * @param {string} [states] Comma-delimited list of chargeback states to display e.g. INITIATED | REPRESENTMENT | PREARBITRATION | ARBITRATION | CASE_WON | CASE_LOST | NETWORK_REJECTED | WITHDRAWN | WRITTEN_OFF_ISSUER | WRITTEN_OFF_PROGRAM
         * @param {string} [sortBy] Sort order
         * @param {string} [networkCaseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargebacks(count?: number, startIndex?: number, networkReferenceId?: string, transactionToken?: string, amount?: string, states?: string, sortBy?: string, networkCaseId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargebacks(count, startIndex, networkReferenceId, transactionToken, amount, states, sortBy, networkCaseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.getChargebacks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all chargeback transitions that are related to a chargeback
         * @param {string} chargebackToken Chargeback token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargebacksChargebacktokenTransitions(chargebackToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackTransitionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargebacksChargebacktokenTransitions(chargebackToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.getChargebacksChargebacktokenTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific chargeback
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargebacksToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargebacksToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.getChargebacksToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific chargeback transition
         * @param {string} token Chargeback transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargebacksTransitionsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargebacksTransitionsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.getChargebacksTransitionsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a chargeback allocation acknowledgement
         * @param {ChargebackAllocationAckRequest} [chargebackAllocationAckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChargebackAllocationAcknowledgment(chargebackAllocationAckRequest?: ChargebackAllocationAckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postChargebackAllocationAcknowledgment(chargebackAllocationAckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.postChargebackAllocationAcknowledgment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a chargeback
         * @param {ChargebackRequest} [chargebackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChargebacks(chargebackRequest?: ChargebackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postChargebacks(chargebackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.postChargebacks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a chargeback transition
         * @param {ChargebackTransitionRequest} [chargebackTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChargebacksTransitions(chargebackTransitionRequest?: ChargebackTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postChargebacksTransitions(chargebackTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.postChargebacksTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates chargeback data
         * @param {string} token 
         * @param {ChargebackUpdateRequest} [chargebackUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChargebacksToken(token: string, chargebackUpdateRequest?: ChargebackUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putChargebacksToken(token, chargebackUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.putChargebacksToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Grants provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChargebacksTokenGrantprovisionalcredit(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putChargebacksTokenGrantprovisionalcredit(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.putChargebacksTokenGrantprovisionalcredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reverses provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChargebacksTokenReverseprovisionalcredit(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargebackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putChargebacksTokenReverseprovisionalcredit(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChargebacksApi.putChargebacksTokenReverseprovisionalcredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChargebacksApi - factory interface
 */
export const ChargebacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChargebacksApiFp(configuration)
    return {
        /**
         * 
         * @summary List all chargebacks
         * @param {number} [count] Number of chargebacks to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [networkReferenceId] Network reference ID
         * @param {string} [transactionToken] Transaction token
         * @param {string} [amount] Amount
         * @param {string} [states] Comma-delimited list of chargeback states to display e.g. INITIATED | REPRESENTMENT | PREARBITRATION | ARBITRATION | CASE_WON | CASE_LOST | NETWORK_REJECTED | WITHDRAWN | WRITTEN_OFF_ISSUER | WRITTEN_OFF_PROGRAM
         * @param {string} [sortBy] Sort order
         * @param {string} [networkCaseId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacks(count?: number, startIndex?: number, networkReferenceId?: string, transactionToken?: string, amount?: string, states?: string, sortBy?: string, networkCaseId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackListResponse> {
            return localVarFp.getChargebacks(count, startIndex, networkReferenceId, transactionToken, amount, states, sortBy, networkCaseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all chargeback transitions that are related to a chargeback
         * @param {string} chargebackToken Chargeback token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksChargebacktokenTransitions(chargebackToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackTransitionListResponse> {
            return localVarFp.getChargebacksChargebacktokenTransitions(chargebackToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific chargeback
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackResponse> {
            return localVarFp.getChargebacksToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific chargeback transition
         * @param {string} token Chargeback transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargebacksTransitionsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackTransitionResponse> {
            return localVarFp.getChargebacksTransitionsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a chargeback allocation acknowledgement
         * @param {ChargebackAllocationAckRequest} [chargebackAllocationAckRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebackAllocationAcknowledgment(chargebackAllocationAckRequest?: ChargebackAllocationAckRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackResponse> {
            return localVarFp.postChargebackAllocationAcknowledgment(chargebackAllocationAckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a chargeback
         * @param {ChargebackRequest} [chargebackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacks(chargebackRequest?: ChargebackRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackResponse> {
            return localVarFp.postChargebacks(chargebackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a chargeback transition
         * @param {ChargebackTransitionRequest} [chargebackTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChargebacksTransitions(chargebackTransitionRequest?: ChargebackTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackTransitionResponse> {
            return localVarFp.postChargebacksTransitions(chargebackTransitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates chargeback data
         * @param {string} token 
         * @param {ChargebackUpdateRequest} [chargebackUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksToken(token: string, chargebackUpdateRequest?: ChargebackUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackResponse> {
            return localVarFp.putChargebacksToken(token, chargebackUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Grants provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenGrantprovisionalcredit(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackResponse> {
            return localVarFp.putChargebacksTokenGrantprovisionalcredit(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reverses provisional credit
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChargebacksTokenReverseprovisionalcredit(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ChargebackResponse> {
            return localVarFp.putChargebacksTokenReverseprovisionalcredit(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChargebacksApi - object-oriented interface
 */
export class ChargebacksApi extends BaseAPI {
    /**
     * 
     * @summary List all chargebacks
     * @param {number} [count] Number of chargebacks to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [networkReferenceId] Network reference ID
     * @param {string} [transactionToken] Transaction token
     * @param {string} [amount] Amount
     * @param {string} [states] Comma-delimited list of chargeback states to display e.g. INITIATED | REPRESENTMENT | PREARBITRATION | ARBITRATION | CASE_WON | CASE_LOST | NETWORK_REJECTED | WITHDRAWN | WRITTEN_OFF_ISSUER | WRITTEN_OFF_PROGRAM
     * @param {string} [sortBy] Sort order
     * @param {string} [networkCaseId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChargebacks(count?: number, startIndex?: number, networkReferenceId?: string, transactionToken?: string, amount?: string, states?: string, sortBy?: string, networkCaseId?: string, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).getChargebacks(count, startIndex, networkReferenceId, transactionToken, amount, states, sortBy, networkCaseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all chargeback transitions that are related to a chargeback
     * @param {string} chargebackToken Chargeback token
     * @param {number} [count] Number of transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChargebacksChargebacktokenTransitions(chargebackToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).getChargebacksChargebacktokenTransitions(chargebackToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific chargeback
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChargebacksToken(token: string, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).getChargebacksToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific chargeback transition
     * @param {string} token Chargeback transition token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getChargebacksTransitionsToken(token: string, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).getChargebacksTransitionsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a chargeback allocation acknowledgement
     * @param {ChargebackAllocationAckRequest} [chargebackAllocationAckRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postChargebackAllocationAcknowledgment(chargebackAllocationAckRequest?: ChargebackAllocationAckRequest, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).postChargebackAllocationAcknowledgment(chargebackAllocationAckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a chargeback
     * @param {ChargebackRequest} [chargebackRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postChargebacks(chargebackRequest?: ChargebackRequest, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).postChargebacks(chargebackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a chargeback transition
     * @param {ChargebackTransitionRequest} [chargebackTransitionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postChargebacksTransitions(chargebackTransitionRequest?: ChargebackTransitionRequest, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).postChargebacksTransitions(chargebackTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates chargeback data
     * @param {string} token 
     * @param {ChargebackUpdateRequest} [chargebackUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putChargebacksToken(token: string, chargebackUpdateRequest?: ChargebackUpdateRequest, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).putChargebacksToken(token, chargebackUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Grants provisional credit
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putChargebacksTokenGrantprovisionalcredit(token: string, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).putChargebacksTokenGrantprovisionalcredit(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reverses provisional credit
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putChargebacksTokenReverseprovisionalcredit(token: string, options?: RawAxiosRequestConfig) {
        return ChargebacksApiFp(this.configuration).putChargebacksTokenReverseprovisionalcredit(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommandoModesApi - axios parameter creator
 */
export const CommandoModesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all commando mode control sets
         * @param {number} [count] Number of commando modes to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodes: async (count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/commandomodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all commando mode transitions related to a commando mode control set
         * @param {string} commandomodeToken Commando mode token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesCommandomodetokenTransitions: async (commandomodeToken: string, count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commandomodeToken' is not null or undefined
            assertParamExists('getCommandomodesCommandomodetokenTransitions', 'commandomodeToken', commandomodeToken)
            const localVarPath = `/commandomodes/{commandomode_token}/transitions`
                .replace(`{${"commandomode_token"}}`, encodeURIComponent(String(commandomodeToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific commando mode control set
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCommandomodesToken', 'token', token)
            const localVarPath = `/commandomodes/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific commando mode transition
         * @param {string} token Commando mode transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesTransitionsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCommandomodesTransitionsToken', 'token', token)
            const localVarPath = `/commandomodes/transitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandoModesApi - functional programming interface
 */
export const CommandoModesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandoModesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all commando mode control sets
         * @param {number} [count] Number of commando modes to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommandomodes(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandoModeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommandomodes(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandoModesApi.getCommandomodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all commando mode transitions related to a commando mode control set
         * @param {string} commandomodeToken Commando mode token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommandomodesCommandomodetokenTransitions(commandomodeToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandoModeTransitionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommandomodesCommandomodetokenTransitions(commandomodeToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandoModesApi.getCommandomodesCommandomodetokenTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific commando mode control set
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommandomodesToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandoModeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommandomodesToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandoModesApi.getCommandomodesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific commando mode transition
         * @param {string} token Commando mode transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommandomodesTransitionsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandoModeTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommandomodesTransitionsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandoModesApi.getCommandomodesTransitionsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommandoModesApi - factory interface
 */
export const CommandoModesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandoModesApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all commando mode control sets
         * @param {number} [count] Number of commando modes to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodes(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<CommandoModeListResponse> {
            return localVarFp.getCommandomodes(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all commando mode transitions related to a commando mode control set
         * @param {string} commandomodeToken Commando mode token
         * @param {number} [count] Number of transitions to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesCommandomodetokenTransitions(commandomodeToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<CommandoModeTransitionListResponse> {
            return localVarFp.getCommandomodesCommandomodetokenTransitions(commandomodeToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific commando mode control set
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<CommandoModeResponse> {
            return localVarFp.getCommandomodesToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific commando mode transition
         * @param {string} token Commando mode transition token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommandomodesTransitionsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<CommandoModeTransitionResponse> {
            return localVarFp.getCommandomodesTransitionsToken(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandoModesApi - object-oriented interface
 */
export class CommandoModesApi extends BaseAPI {
    /**
     * 
     * @summary Lists all commando mode control sets
     * @param {number} [count] Number of commando modes to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommandomodes(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return CommandoModesApiFp(this.configuration).getCommandomodes(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all commando mode transitions related to a commando mode control set
     * @param {string} commandomodeToken Commando mode token
     * @param {number} [count] Number of transitions to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommandomodesCommandomodetokenTransitions(commandomodeToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return CommandoModesApiFp(this.configuration).getCommandomodesCommandomodetokenTransitions(commandomodeToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific commando mode control set
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommandomodesToken(token: string, options?: RawAxiosRequestConfig) {
        return CommandoModesApiFp(this.configuration).getCommandomodesToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific commando mode transition
     * @param {string} token Commando mode transition token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCommandomodesTransitionsToken(token: string, options?: RawAxiosRequestConfig) {
        return CommandoModesApiFp(this.configuration).getCommandomodesTransitionsToken(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CreditAccountDisputesApi - axios parameter creator
 */
export const CreditAccountDisputesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a dispute of a journal entry on a credit account.
         * @summary Create account dispute
         * @param {string} accountToken Unique identifier of the credit account for which to create a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {DisputeCreateReq} disputeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeForAccount: async (accountToken: string, disputeCreateReq: DisputeCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createDisputeForAccount', 'accountToken', accountToken)
            // verify required parameter 'disputeCreateReq' is not null or undefined
            assertParamExists('createDisputeForAccount', 'disputeCreateReq', disputeCreateReq)
            const localVarPath = `/accounts/{account_token}/disputes`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(disputeCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of disputes on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account disputes
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the disputes.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of disputes resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetDisputesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<string>} [ledgerEntryTokens] Unique identifier of the journal entry in dispute. This type of identifier can only be used for &#x60;authorization.clearing&#x60;-type journal entries.
         * @param {Array<DisputeStatus>} [statuses] Status of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisputesByAccount: async (accountToken: string, count?: number, startIndex?: number, sortBy?: GetDisputesByAccountSortByEnum, ledgerEntryTokens?: Array<string>, statuses?: Array<DisputeStatus>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getDisputesByAccount', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/disputes`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (ledgerEntryTokens) {
                localVarQueryParameter['ledger_entry_tokens'] = ledgerEntryTokens;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a dispute from a credit account.
         * @summary Retrieve account dispute
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} disputeToken Unique identifier of the dispute to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/disputes&#x60; to retrieve existing dispute tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute: async (accountToken: string, disputeToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveDispute', 'accountToken', accountToken)
            // verify required parameter 'disputeToken' is not null or undefined
            assertParamExists('retrieveDispute', 'disputeToken', disputeToken)
            const localVarPath = `/accounts/{account_token}/disputes/{dispute_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"dispute_token"}}`, encodeURIComponent(String(disputeToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the amount or status of a dispute on a credit account.
         * @summary Update account dispute
         * @param {string} accountToken Unique identifier of the credit account from which to update a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} disputeToken Unique identifier of the dispute to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/disputes&#x60; to retrieve existing credit account tokens.
         * @param {DisputeTransitionReq} disputeTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionDispute: async (accountToken: string, disputeToken: string, disputeTransitionReq: DisputeTransitionReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('transitionDispute', 'accountToken', accountToken)
            // verify required parameter 'disputeToken' is not null or undefined
            assertParamExists('transitionDispute', 'disputeToken', disputeToken)
            // verify required parameter 'disputeTransitionReq' is not null or undefined
            assertParamExists('transitionDispute', 'disputeTransitionReq', disputeTransitionReq)
            const localVarPath = `/accounts/{account_token}/disputes/{dispute_token}/transitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"dispute_token"}}`, encodeURIComponent(String(disputeToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(disputeTransitionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditAccountDisputesApi - functional programming interface
 */
export const CreditAccountDisputesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditAccountDisputesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a dispute of a journal entry on a credit account.
         * @summary Create account dispute
         * @param {string} accountToken Unique identifier of the credit account for which to create a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {DisputeCreateReq} disputeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDisputeForAccount(accountToken: string, disputeCreateReq: DisputeCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDisputeForAccount(accountToken, disputeCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditAccountDisputesApi.createDisputeForAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of disputes on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account disputes
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the disputes.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of disputes resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetDisputesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<string>} [ledgerEntryTokens] Unique identifier of the journal entry in dispute. This type of identifier can only be used for &#x60;authorization.clearing&#x60;-type journal entries.
         * @param {Array<DisputeStatus>} [statuses] Status of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisputesByAccount(accountToken: string, count?: number, startIndex?: number, sortBy?: GetDisputesByAccountSortByEnum, ledgerEntryTokens?: Array<string>, statuses?: Array<DisputeStatus>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeResponsePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisputesByAccount(accountToken, count, startIndex, sortBy, ledgerEntryTokens, statuses, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditAccountDisputesApi.getDisputesByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a dispute from a credit account.
         * @summary Retrieve account dispute
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} disputeToken Unique identifier of the dispute to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/disputes&#x60; to retrieve existing dispute tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDispute(accountToken: string, disputeToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveDispute(accountToken, disputeToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditAccountDisputesApi.retrieveDispute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the amount or status of a dispute on a credit account.
         * @summary Update account dispute
         * @param {string} accountToken Unique identifier of the credit account from which to update a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} disputeToken Unique identifier of the dispute to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/disputes&#x60; to retrieve existing credit account tokens.
         * @param {DisputeTransitionReq} disputeTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionDispute(accountToken: string, disputeToken: string, disputeTransitionReq: DisputeTransitionReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisputeTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionDispute(accountToken, disputeToken, disputeTransitionReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditAccountDisputesApi.transitionDispute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditAccountDisputesApi - factory interface
 */
export const CreditAccountDisputesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditAccountDisputesApiFp(configuration)
    return {
        /**
         * Create a dispute of a journal entry on a credit account.
         * @summary Create account dispute
         * @param {string} accountToken Unique identifier of the credit account for which to create a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {DisputeCreateReq} disputeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDisputeForAccount(accountToken: string, disputeCreateReq: DisputeCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<DisputeResponse> {
            return localVarFp.createDisputeForAccount(accountToken, disputeCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of disputes on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account disputes
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the disputes.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of disputes resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetDisputesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<string>} [ledgerEntryTokens] Unique identifier of the journal entry in dispute. This type of identifier can only be used for &#x60;authorization.clearing&#x60;-type journal entries.
         * @param {Array<DisputeStatus>} [statuses] Status of the dispute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisputesByAccount(accountToken: string, count?: number, startIndex?: number, sortBy?: GetDisputesByAccountSortByEnum, ledgerEntryTokens?: Array<string>, statuses?: Array<DisputeStatus>, options?: RawAxiosRequestConfig): AxiosPromise<DisputeResponsePage> {
            return localVarFp.getDisputesByAccount(accountToken, count, startIndex, sortBy, ledgerEntryTokens, statuses, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a dispute from a credit account.
         * @summary Retrieve account dispute
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} disputeToken Unique identifier of the dispute to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/disputes&#x60; to retrieve existing dispute tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDispute(accountToken: string, disputeToken: string, options?: RawAxiosRequestConfig): AxiosPromise<DisputeResponse> {
            return localVarFp.retrieveDispute(accountToken, disputeToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the amount or status of a dispute on a credit account.
         * @summary Update account dispute
         * @param {string} accountToken Unique identifier of the credit account from which to update a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} disputeToken Unique identifier of the dispute to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/disputes&#x60; to retrieve existing credit account tokens.
         * @param {DisputeTransitionReq} disputeTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionDispute(accountToken: string, disputeToken: string, disputeTransitionReq: DisputeTransitionReq, options?: RawAxiosRequestConfig): AxiosPromise<DisputeTransitionResponse> {
            return localVarFp.transitionDispute(accountToken, disputeToken, disputeTransitionReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditAccountDisputesApi - object-oriented interface
 */
export class CreditAccountDisputesApi extends BaseAPI {
    /**
     * Create a dispute of a journal entry on a credit account.
     * @summary Create account dispute
     * @param {string} accountToken Unique identifier of the credit account for which to create a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {DisputeCreateReq} disputeCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDisputeForAccount(accountToken: string, disputeCreateReq: DisputeCreateReq, options?: RawAxiosRequestConfig) {
        return CreditAccountDisputesApiFp(this.configuration).createDisputeForAccount(accountToken, disputeCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of disputes on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List account disputes
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve the disputes.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {number} [count] Number of disputes resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetDisputesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {Array<string>} [ledgerEntryTokens] Unique identifier of the journal entry in dispute. This type of identifier can only be used for &#x60;authorization.clearing&#x60;-type journal entries.
     * @param {Array<DisputeStatus>} [statuses] Status of the dispute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDisputesByAccount(accountToken: string, count?: number, startIndex?: number, sortBy?: GetDisputesByAccountSortByEnum, ledgerEntryTokens?: Array<string>, statuses?: Array<DisputeStatus>, options?: RawAxiosRequestConfig) {
        return CreditAccountDisputesApiFp(this.configuration).getDisputesByAccount(accountToken, count, startIndex, sortBy, ledgerEntryTokens, statuses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a dispute from a credit account.
     * @summary Retrieve account dispute
     * @param {string} accountToken Unique identifier of the credit account from which to retrieve a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} disputeToken Unique identifier of the dispute to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/disputes&#x60; to retrieve existing dispute tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveDispute(accountToken: string, disputeToken: string, options?: RawAxiosRequestConfig) {
        return CreditAccountDisputesApiFp(this.configuration).retrieveDispute(accountToken, disputeToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the amount or status of a dispute on a credit account.
     * @summary Update account dispute
     * @param {string} accountToken Unique identifier of the credit account from which to update a dispute.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} disputeToken Unique identifier of the dispute to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/disputes&#x60; to retrieve existing credit account tokens.
     * @param {DisputeTransitionReq} disputeTransitionReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transitionDispute(accountToken: string, disputeToken: string, disputeTransitionReq: DisputeTransitionReq, options?: RawAxiosRequestConfig) {
        return CreditAccountDisputesApiFp(this.configuration).transitionDispute(accountToken, disputeToken, disputeTransitionReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetDisputesByAccountSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type GetDisputesByAccountSortByEnum = typeof GetDisputesByAccountSortByEnum[keyof typeof GetDisputesByAccountSortByEnum];


/**
 * CreditAccountsApi - axios parameter creator
 */
export const CreditAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an array of credit accounts.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List accounts
         * @param {string} [cardToken] Unique identifier of the credit card associated with the account.
         * @param {number} [count] Number of credit account resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListAccountsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {boolean} [lightResponse] If true, returns a lightweight response without any balances and usages.
         * @param {string} [securedAccountToken] Unique identifier of an existing secured account.
         * @param {string} [userToken] Unique identifier of the user to filter accounts by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (cardToken?: string, count?: number, startIndex?: number, sortBy?: ListAccountsSortByEnum, lightResponse?: boolean, securedAccountToken?: string, userToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cardToken !== undefined) {
                localVarQueryParameter['card_token'] = cardToken;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (lightResponse !== undefined) {
                localVarQueryParameter['light_response'] = lightResponse;
            }

            if (securedAccountToken !== undefined) {
                localVarQueryParameter['secured_account_token'] = securedAccountToken;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a credit account.
         * @summary Retrieve account
         * @param {string} accountToken Unique identifier of the credit account to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {boolean} [effectiveFeeScheduleOnly] Display the effective fee schedule only.
         * @param {boolean} [lightResponse] If true, returns a lightweight response without any balances and usages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccount: async (accountToken: string, effectiveFeeScheduleOnly?: boolean, lightResponse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveAccount', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (effectiveFeeScheduleOnly !== undefined) {
                localVarQueryParameter['effective_fee_schedule_only'] = effectiveFeeScheduleOnly;
            }

            if (lightResponse !== undefined) {
                localVarQueryParameter['light_response'] = lightResponse;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a credit account.
         * @summary Update account
         * @param {string} accountToken Unique identifier of the credit account to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountUpdateReq} accountUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (accountToken: string, accountUpdateReq: AccountUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('updateAccount', 'accountToken', accountToken)
            // verify required parameter 'accountUpdateReq' is not null or undefined
            assertParamExists('updateAccount', 'accountUpdateReq', accountUpdateReq)
            const localVarPath = `/accounts/{account_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(accountUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditAccountsApi - functional programming interface
 */
export const CreditAccountsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an array of credit accounts.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List accounts
         * @param {string} [cardToken] Unique identifier of the credit card associated with the account.
         * @param {number} [count] Number of credit account resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListAccountsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {boolean} [lightResponse] If true, returns a lightweight response without any balances and usages.
         * @param {string} [securedAccountToken] Unique identifier of an existing secured account.
         * @param {string} [userToken] Unique identifier of the user to filter accounts by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(cardToken?: string, count?: number, startIndex?: number, sortBy?: ListAccountsSortByEnum, lightResponse?: boolean, securedAccountToken?: string, userToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(cardToken, count, startIndex, sortBy, lightResponse, securedAccountToken, userToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditAccountsApi.listAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a credit account.
         * @summary Retrieve account
         * @param {string} accountToken Unique identifier of the credit account to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {boolean} [effectiveFeeScheduleOnly] Display the effective fee schedule only.
         * @param {boolean} [lightResponse] If true, returns a lightweight response without any balances and usages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccount(accountToken: string, effectiveFeeScheduleOnly?: boolean, lightResponse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccount(accountToken, effectiveFeeScheduleOnly, lightResponse, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditAccountsApi.retrieveAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a credit account.
         * @summary Update account
         * @param {string} accountToken Unique identifier of the credit account to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountUpdateReq} accountUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(accountToken: string, accountUpdateReq: AccountUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountToken, accountUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditAccountsApi.updateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditAccountsApi - factory interface
 */
export const CreditAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditAccountsApiFp(configuration)
    return {
        /**
         * Retrieve an array of credit accounts.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List accounts
         * @param {string} [cardToken] Unique identifier of the credit card associated with the account.
         * @param {number} [count] Number of credit account resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListAccountsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {boolean} [lightResponse] If true, returns a lightweight response without any balances and usages.
         * @param {string} [securedAccountToken] Unique identifier of an existing secured account.
         * @param {string} [userToken] Unique identifier of the user to filter accounts by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(cardToken?: string, count?: number, startIndex?: number, sortBy?: ListAccountsSortByEnum, lightResponse?: boolean, securedAccountToken?: string, userToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountsPage> {
            return localVarFp.listAccounts(cardToken, count, startIndex, sortBy, lightResponse, securedAccountToken, userToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a credit account.
         * @summary Retrieve account
         * @param {string} accountToken Unique identifier of the credit account to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {boolean} [effectiveFeeScheduleOnly] Display the effective fee schedule only.
         * @param {boolean} [lightResponse] If true, returns a lightweight response without any balances and usages.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccount(accountToken: string, effectiveFeeScheduleOnly?: boolean, lightResponse?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.retrieveAccount(accountToken, effectiveFeeScheduleOnly, lightResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a credit account.
         * @summary Update account
         * @param {string} accountToken Unique identifier of the credit account to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountUpdateReq} accountUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(accountToken: string, accountUpdateReq: AccountUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<AccountResponse> {
            return localVarFp.updateAccount(accountToken, accountUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditAccountsApi - object-oriented interface
 */
export class CreditAccountsApi extends BaseAPI {
    /**
     * Retrieve an array of credit accounts.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List accounts
     * @param {string} [cardToken] Unique identifier of the credit card associated with the account.
     * @param {number} [count] Number of credit account resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListAccountsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {boolean} [lightResponse] If true, returns a lightweight response without any balances and usages.
     * @param {string} [securedAccountToken] Unique identifier of an existing secured account.
     * @param {string} [userToken] Unique identifier of the user to filter accounts by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAccounts(cardToken?: string, count?: number, startIndex?: number, sortBy?: ListAccountsSortByEnum, lightResponse?: boolean, securedAccountToken?: string, userToken?: string, options?: RawAxiosRequestConfig) {
        return CreditAccountsApiFp(this.configuration).listAccounts(cardToken, count, startIndex, sortBy, lightResponse, securedAccountToken, userToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a credit account.
     * @summary Retrieve account
     * @param {string} accountToken Unique identifier of the credit account to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {boolean} [effectiveFeeScheduleOnly] Display the effective fee schedule only.
     * @param {boolean} [lightResponse] If true, returns a lightweight response without any balances and usages.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveAccount(accountToken: string, effectiveFeeScheduleOnly?: boolean, lightResponse?: boolean, options?: RawAxiosRequestConfig) {
        return CreditAccountsApiFp(this.configuration).retrieveAccount(accountToken, effectiveFeeScheduleOnly, lightResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a credit account.
     * @summary Update account
     * @param {string} accountToken Unique identifier of the credit account to update.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {AccountUpdateReq} accountUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAccount(accountToken: string, accountUpdateReq: AccountUpdateReq, options?: RawAxiosRequestConfig) {
        return CreditAccountsApiFp(this.configuration).updateAccount(accountToken, accountUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListAccountsSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListAccountsSortByEnum = typeof ListAccountsSortByEnum[keyof typeof ListAccountsSortByEnum];


/**
 * CreditProductsApi - axios parameter creator
 */
export const CreditProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a credit product.
         * @summary Create credit product
         * @param {ProductCreateReq} productCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (productCreateReq: ProductCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productCreateReq' is not null or undefined
            assertParamExists('createProduct', 'productCreateReq', productCreateReq)
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(productCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the lineage of a credit product, which is an array of related credit products whose lineage can be traced back to the same original credit product.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve credit product lineage
         * @param {string} token Unique identifier of the credit product whose lineage you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/products&#x60; to retrieve existing credit product tokens.
         * @param {Array<ResourceStatus>} [status] An array of statuses by which to filter credit products.
         * @param {number} [count] Number of credit product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {LineageProductsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineageProducts: async (token: string, status?: Array<ResourceStatus>, count?: number, startIndex?: number, sortBy?: LineageProductsSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('lineageProducts', 'token', token)
            const localVarPath = `/products/{token}/lineage`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of credit products.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List credit products
         * @param {Array<ResourceStatus>} [status] An array of statuses by which to filter credit products.
         * @param {number} [count] Number of credit product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProductsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts: async (status?: Array<ResourceStatus>, count?: number, startIndex?: number, sortBy?: ListProductsSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a credit product.
         * @summary Retrieve credit product
         * @param {string} token Unique identifier of the credit product to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/products&#x60; to retrieve existing credit product tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProduct: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrieveProduct', 'token', token)
            const localVarPath = `/products/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditProductsApi - functional programming interface
 */
export const CreditProductsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a credit product.
         * @summary Create credit product
         * @param {ProductCreateReq} productCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(productCreateReq: ProductCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(productCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditProductsApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the lineage of a credit product, which is an array of related credit products whose lineage can be traced back to the same original credit product.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve credit product lineage
         * @param {string} token Unique identifier of the credit product whose lineage you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/products&#x60; to retrieve existing credit product tokens.
         * @param {Array<ResourceStatus>} [status] An array of statuses by which to filter credit products.
         * @param {number} [count] Number of credit product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {LineageProductsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lineageProducts(token: string, status?: Array<ResourceStatus>, count?: number, startIndex?: number, sortBy?: LineageProductsSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lineageProducts(token, status, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditProductsApi.lineageProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of credit products.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List credit products
         * @param {Array<ResourceStatus>} [status] An array of statuses by which to filter credit products.
         * @param {number} [count] Number of credit product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProductsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProducts(status?: Array<ResourceStatus>, count?: number, startIndex?: number, sortBy?: ListProductsSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProducts(status, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditProductsApi.listProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a credit product.
         * @summary Retrieve credit product
         * @param {string} token Unique identifier of the credit product to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/products&#x60; to retrieve existing credit product tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProduct(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProduct(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditProductsApi.retrieveProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditProductsApi - factory interface
 */
export const CreditProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditProductsApiFp(configuration)
    return {
        /**
         * Create a credit product.
         * @summary Create credit product
         * @param {ProductCreateReq} productCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(productCreateReq: ProductCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.createProduct(productCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the lineage of a credit product, which is an array of related credit products whose lineage can be traced back to the same original credit product.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve credit product lineage
         * @param {string} token Unique identifier of the credit product whose lineage you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/products&#x60; to retrieve existing credit product tokens.
         * @param {Array<ResourceStatus>} [status] An array of statuses by which to filter credit products.
         * @param {number} [count] Number of credit product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {LineageProductsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lineageProducts(token: string, status?: Array<ResourceStatus>, count?: number, startIndex?: number, sortBy?: LineageProductsSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProductsPage> {
            return localVarFp.lineageProducts(token, status, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of credit products.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List credit products
         * @param {Array<ResourceStatus>} [status] An array of statuses by which to filter credit products.
         * @param {number} [count] Number of credit product resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProductsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProducts(status?: Array<ResourceStatus>, count?: number, startIndex?: number, sortBy?: ListProductsSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProductsPage> {
            return localVarFp.listProducts(status, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a credit product.
         * @summary Retrieve credit product
         * @param {string} token Unique identifier of the credit product to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/products&#x60; to retrieve existing credit product tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProduct(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.retrieveProduct(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditProductsApi - object-oriented interface
 */
export class CreditProductsApi extends BaseAPI {
    /**
     * Create a credit product.
     * @summary Create credit product
     * @param {ProductCreateReq} productCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProduct(productCreateReq: ProductCreateReq, options?: RawAxiosRequestConfig) {
        return CreditProductsApiFp(this.configuration).createProduct(productCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the lineage of a credit product, which is an array of related credit products whose lineage can be traced back to the same original credit product.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary Retrieve credit product lineage
     * @param {string} token Unique identifier of the credit product whose lineage you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/products&#x60; to retrieve existing credit product tokens.
     * @param {Array<ResourceStatus>} [status] An array of statuses by which to filter credit products.
     * @param {number} [count] Number of credit product resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {LineageProductsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public lineageProducts(token: string, status?: Array<ResourceStatus>, count?: number, startIndex?: number, sortBy?: LineageProductsSortByEnum, options?: RawAxiosRequestConfig) {
        return CreditProductsApiFp(this.configuration).lineageProducts(token, status, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of credit products.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List credit products
     * @param {Array<ResourceStatus>} [status] An array of statuses by which to filter credit products.
     * @param {number} [count] Number of credit product resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListProductsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProducts(status?: Array<ResourceStatus>, count?: number, startIndex?: number, sortBy?: ListProductsSortByEnum, options?: RawAxiosRequestConfig) {
        return CreditProductsApiFp(this.configuration).listProducts(status, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a credit product.
     * @summary Retrieve credit product
     * @param {string} token Unique identifier of the credit product to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/products&#x60; to retrieve existing credit product tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveProduct(token: string, options?: RawAxiosRequestConfig) {
        return CreditProductsApiFp(this.configuration).retrieveProduct(token, options).then((request) => request(this.axios, this.basePath));
    }
}

export const LineageProductsSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type LineageProductsSortByEnum = typeof LineageProductsSortByEnum[keyof typeof LineageProductsSortByEnum];
export const ListProductsSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListProductsSortByEnum = typeof ListProductsSortByEnum[keyof typeof ListProductsSortByEnum];


/**
 * CreditSubstatusesApi - axios parameter creator
 */
export const CreditSubstatusesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new substatus for a credit account, user, or business.
         * @summary Create substatus
         * @param {SubstatusCreateReq} substatusCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubStatus: async (substatusCreateReq: SubstatusCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'substatusCreateReq' is not null or undefined
            assertParamExists('createSubStatus', 'substatusCreateReq', substatusCreateReq)
            const localVarPath = `/substatuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(substatusCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of substatuses. This endpoint supports <</core-api/sorting-and-pagination,sorting and pagination>>.
         * @summary List substatuses
         * @param {string} [accountToken] Unique identifier of the account for which to retrieve substatuses.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing account tokens.
         * @param {string} [userToken] Unique identifier of the user for which to retrieve substatuses.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve existing user tokens.
         * @param {boolean} [isActive] Denotes whether a substatus is active.
         * @param {Array<ListSubStatusesSubstatusesEnum>} [substatuses] Comma-delimited list of substatus types to include. Allowable values: &#x60;HARDSHIP&#x60;, &#x60;FRAUD&#x60;, &#x60;MLA&#x60;, &#x60;SCRA&#x60;, &#x60;DECEASED&#x60;, &#x60;BANKRUPTCY&#x60;, &#x60;POWER_OF_ATTORNEY&#x60;
         * @param {number} [count] The number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListSubStatusesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubStatuses: async (accountToken?: string, userToken?: string, isActive?: boolean, substatuses?: Array<ListSubStatusesSubstatusesEnum>, count?: number, startIndex?: number, sortBy?: ListSubStatusesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/substatuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountToken !== undefined) {
                localVarQueryParameter['account_token'] = accountToken;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (substatuses) {
                localVarQueryParameter['substatuses'] = substatuses;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent: async (eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('resendWebhookEvent', 'eventType', eventType)
            // verify required parameter 'resourceToken' is not null or undefined
            assertParamExists('resendWebhookEvent', 'resourceToken', resourceToken)
            const localVarPath = `/webhooks/{event_type}/{resource_token}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"resource_token"}}`, encodeURIComponent(String(resourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a user or account substatus.
         * @summary Retrieve substatus
         * @param {string} substatusToken Unique identifier of the substatus to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSubStatus: async (substatusToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'substatusToken' is not null or undefined
            assertParamExists('retrieveSubStatus', 'substatusToken', substatusToken)
            const localVarPath = `/substatuses/{substatus_token}`
                .replace(`{${"substatus_token"}}`, encodeURIComponent(String(substatusToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating a substatus registers a new event that changes the substatus\' state.
         * @summary Update substatus
         * @param {string} substatusToken Unique identifier of the account substatus resource to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens.
         * @param {SubstatusUpdateReq} substatusUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubStatus: async (substatusToken: string, substatusUpdateReq: SubstatusUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'substatusToken' is not null or undefined
            assertParamExists('updateSubStatus', 'substatusToken', substatusToken)
            // verify required parameter 'substatusUpdateReq' is not null or undefined
            assertParamExists('updateSubStatus', 'substatusUpdateReq', substatusUpdateReq)
            const localVarPath = `/substatuses/{substatus_token}`
                .replace(`{${"substatus_token"}}`, encodeURIComponent(String(substatusToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(substatusUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CreditSubstatusesApi - functional programming interface
 */
export const CreditSubstatusesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = CreditSubstatusesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new substatus for a credit account, user, or business.
         * @summary Create substatus
         * @param {SubstatusCreateReq} substatusCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubStatus(substatusCreateReq: SubstatusCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubstatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubStatus(substatusCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditSubstatusesApi.createSubStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of substatuses. This endpoint supports <</core-api/sorting-and-pagination,sorting and pagination>>.
         * @summary List substatuses
         * @param {string} [accountToken] Unique identifier of the account for which to retrieve substatuses.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing account tokens.
         * @param {string} [userToken] Unique identifier of the user for which to retrieve substatuses.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve existing user tokens.
         * @param {boolean} [isActive] Denotes whether a substatus is active.
         * @param {Array<ListSubStatusesSubstatusesEnum>} [substatuses] Comma-delimited list of substatus types to include. Allowable values: &#x60;HARDSHIP&#x60;, &#x60;FRAUD&#x60;, &#x60;MLA&#x60;, &#x60;SCRA&#x60;, &#x60;DECEASED&#x60;, &#x60;BANKRUPTCY&#x60;, &#x60;POWER_OF_ATTORNEY&#x60;
         * @param {number} [count] The number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListSubStatusesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSubStatuses(accountToken?: string, userToken?: string, isActive?: boolean, substatuses?: Array<ListSubStatusesSubstatusesEnum>, count?: number, startIndex?: number, sortBy?: ListSubStatusesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubstatusPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSubStatuses(accountToken, userToken, isActive, substatuses, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditSubstatusesApi.listSubStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResendContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhookEvent(eventType, resourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditSubstatusesApi.resendWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a user or account substatus.
         * @summary Retrieve substatus
         * @param {string} substatusToken Unique identifier of the substatus to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSubStatus(substatusToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubstatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSubStatus(substatusToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditSubstatusesApi.retrieveSubStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updating a substatus registers a new event that changes the substatus\' state.
         * @summary Update substatus
         * @param {string} substatusToken Unique identifier of the account substatus resource to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens.
         * @param {SubstatusUpdateReq} substatusUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSubStatus(substatusToken: string, substatusUpdateReq: SubstatusUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubstatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubStatus(substatusToken, substatusUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CreditSubstatusesApi.updateSubStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CreditSubstatusesApi - factory interface
 */
export const CreditSubstatusesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CreditSubstatusesApiFp(configuration)
    return {
        /**
         * Create a new substatus for a credit account, user, or business.
         * @summary Create substatus
         * @param {SubstatusCreateReq} substatusCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubStatus(substatusCreateReq: SubstatusCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<SubstatusResponse> {
            return localVarFp.createSubStatus(substatusCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of substatuses. This endpoint supports <</core-api/sorting-and-pagination,sorting and pagination>>.
         * @summary List substatuses
         * @param {string} [accountToken] Unique identifier of the account for which to retrieve substatuses.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing account tokens.
         * @param {string} [userToken] Unique identifier of the user for which to retrieve substatuses.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve existing user tokens.
         * @param {boolean} [isActive] Denotes whether a substatus is active.
         * @param {Array<ListSubStatusesSubstatusesEnum>} [substatuses] Comma-delimited list of substatus types to include. Allowable values: &#x60;HARDSHIP&#x60;, &#x60;FRAUD&#x60;, &#x60;MLA&#x60;, &#x60;SCRA&#x60;, &#x60;DECEASED&#x60;, &#x60;BANKRUPTCY&#x60;, &#x60;POWER_OF_ATTORNEY&#x60;
         * @param {number} [count] The number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListSubStatusesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubStatuses(accountToken?: string, userToken?: string, isActive?: boolean, substatuses?: Array<ListSubStatusesSubstatusesEnum>, count?: number, startIndex?: number, sortBy?: ListSubStatusesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<SubstatusPage> {
            return localVarFp.listSubStatuses(accountToken, userToken, isActive, substatuses, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResendContainerResponse> {
            return localVarFp.resendWebhookEvent(eventType, resourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a user or account substatus.
         * @summary Retrieve substatus
         * @param {string} substatusToken Unique identifier of the substatus to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSubStatus(substatusToken: string, options?: RawAxiosRequestConfig): AxiosPromise<SubstatusResponse> {
            return localVarFp.retrieveSubStatus(substatusToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating a substatus registers a new event that changes the substatus\' state.
         * @summary Update substatus
         * @param {string} substatusToken Unique identifier of the account substatus resource to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens.
         * @param {SubstatusUpdateReq} substatusUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubStatus(substatusToken: string, substatusUpdateReq: SubstatusUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<SubstatusResponse> {
            return localVarFp.updateSubStatus(substatusToken, substatusUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CreditSubstatusesApi - object-oriented interface
 */
export class CreditSubstatusesApi extends BaseAPI {
    /**
     * Create a new substatus for a credit account, user, or business.
     * @summary Create substatus
     * @param {SubstatusCreateReq} substatusCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSubStatus(substatusCreateReq: SubstatusCreateReq, options?: RawAxiosRequestConfig) {
        return CreditSubstatusesApiFp(this.configuration).createSubStatus(substatusCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of substatuses. This endpoint supports <</core-api/sorting-and-pagination,sorting and pagination>>.
     * @summary List substatuses
     * @param {string} [accountToken] Unique identifier of the account for which to retrieve substatuses.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing account tokens.
     * @param {string} [userToken] Unique identifier of the user for which to retrieve substatuses.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve existing user tokens.
     * @param {boolean} [isActive] Denotes whether a substatus is active.
     * @param {Array<ListSubStatusesSubstatusesEnum>} [substatuses] Comma-delimited list of substatus types to include. Allowable values: &#x60;HARDSHIP&#x60;, &#x60;FRAUD&#x60;, &#x60;MLA&#x60;, &#x60;SCRA&#x60;, &#x60;DECEASED&#x60;, &#x60;BANKRUPTCY&#x60;, &#x60;POWER_OF_ATTORNEY&#x60;
     * @param {number} [count] The number of resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListSubStatusesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listSubStatuses(accountToken?: string, userToken?: string, isActive?: boolean, substatuses?: Array<ListSubStatusesSubstatusesEnum>, count?: number, startIndex?: number, sortBy?: ListSubStatusesSortByEnum, options?: RawAxiosRequestConfig) {
        return CreditSubstatusesApiFp(this.configuration).listSubStatuses(accountToken, userToken, isActive, substatuses, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
     * @summary Resend credit event notification
     * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig) {
        return CreditSubstatusesApiFp(this.configuration).resendWebhookEvent(eventType, resourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a user or account substatus.
     * @summary Retrieve substatus
     * @param {string} substatusToken Unique identifier of the substatus to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveSubStatus(substatusToken: string, options?: RawAxiosRequestConfig) {
        return CreditSubstatusesApiFp(this.configuration).retrieveSubStatus(substatusToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating a substatus registers a new event that changes the substatus\' state.
     * @summary Update substatus
     * @param {string} substatusToken Unique identifier of the account substatus resource to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens.
     * @param {SubstatusUpdateReq} substatusUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateSubStatus(substatusToken: string, substatusUpdateReq: SubstatusUpdateReq, options?: RawAxiosRequestConfig) {
        return CreditSubstatusesApiFp(this.configuration).updateSubStatus(substatusToken, substatusUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListSubStatusesSubstatusesEnum = {
    Hardship: 'HARDSHIP',
    Fraud: 'FRAUD',
    Mla: 'MLA',
    Scra: 'SCRA',
    Deceased: 'DECEASED',
    Bankruptcy: 'BANKRUPTCY',
    PowerOfAttorney: 'POWER_OF_ATTORNEY'
} as const;
export type ListSubStatusesSubstatusesEnum = typeof ListSubStatusesSubstatusesEnum[keyof typeof ListSubStatusesSubstatusesEnum];
export const ListSubStatusesSortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime'
} as const;
export type ListSubStatusesSortByEnum = typeof ListSubStatusesSortByEnum[keyof typeof ListSubStatusesSortByEnum];
export const ResendWebhookEventEventTypeEnum = {
    Ledgerentry: 'ledgerentry',
    Journalentry: 'journalentry',
    Accounttransition: 'accounttransition',
    Accountstatement: 'accountstatement',
    Paymenttransition: 'paymenttransition',
    Delinquencytransition: 'delinquencytransition',
    Paymentreminders: 'paymentreminders',
    Substatus: 'substatus',
    Accountsignupbonus: 'accountsignupbonus'
} as const;
export type ResendWebhookEventEventTypeEnum = typeof ResendWebhookEventEventTypeEnum[keyof typeof ResendWebhookEventEventTypeEnum];


/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpace: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/spaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create space for key.
         * @param {string} space 
         * @param {string} key 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpaceForKey: async (space: string, key: string, timeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'space' is not null or undefined
            assertParamExists('createSpaceForKey', 'space', space)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('createSpaceForKey', 'key', key)
            const localVarPath = `/spaces/{space}/{key}`
                .replace(`{${"space"}}`, encodeURIComponent(String(space)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue: async (queueName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'queueName' is not null or undefined
            assertParamExists('deleteQueue', 'queueName', queueName)
            const localVarPath = `/spaces/redis-queue/{queueName}`
                .replace(`{${"queueName"}}`, encodeURIComponent(String(queueName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete space.
         * @param {string} space 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpace: async (space: string, key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'space' is not null or undefined
            assertParamExists('deleteSpace', 'space', space)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteSpace', 'key', key)
            const localVarPath = `/spaces/{space}/{key}`
                .replace(`{${"space"}}`, encodeURIComponent(String(space)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is to get a fraud feedback from the customer.
         * @summary Creates a fraud feedback
         * @param {FraudFeedbackRequest} fraudFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackFraudPost: async (fraudFeedbackRequest: FraudFeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fraudFeedbackRequest' is not null or undefined
            assertParamExists('feedbackFraudPost', 'fraudFeedbackRequest', fraudFeedbackRequest)
            const localVarPath = `/feedback/fraud`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(fraudFeedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get deposit account user token.
         * @param {string} token Token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDepositAccountUserToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDepositAccountUserToken', 'token', token)
            const localVarPath = `/depositaccounts/user/{token}/direct`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get space.
         * @param {string} space 
         * @param {string} key 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpace: async (space: string, key: string, timeout?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'space' is not null or undefined
            assertParamExists('getSpace', 'space', space)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getSpace', 'key', key)
            const localVarPath = `/spaces/{space}/{key}`
                .replace(`{${"space"}}`, encodeURIComponent(String(space)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get spaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/spaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of transitions associated with the refund.
         * @summary List transitions associated with a refund
         * @param {string} accountToken Unique identifier of the credit account
         * @param {string} refundToken Unique identifier of the refund
         * @param {number} [count] The number of resources to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {RetrieveRefundTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRefundTransitions: async (accountToken: string, refundToken: string, count?: number, startIndex?: number, sortBy?: RetrieveRefundTransitionsSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveRefundTransitions', 'accountToken', accountToken)
            // verify required parameter 'refundToken' is not null or undefined
            assertParamExists('retrieveRefundTransitions', 'refundToken', refundToken)
            const localVarPath = `/accounts/{account_token}/refunds/{refund_token}/transitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"refund_token"}}`, encodeURIComponent(String(refundToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpace(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSpace(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createSpace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create space for key.
         * @param {string} space 
         * @param {string} key 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpaceForKey(space: string, key: string, timeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSpaceForKey(space, key, timeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.createSpaceForKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQueue(queueName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQueue(queueName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete space.
         * @param {string} space 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSpace(space: string, key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSpace(space, key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.deleteSpace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is to get a fraud feedback from the customer.
         * @summary Creates a fraud feedback
         * @param {FraudFeedbackRequest} fraudFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedbackFraudPost(fraudFeedbackRequest: FraudFeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FraudFeedbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedbackFraudPost(fraudFeedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.feedbackFraudPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get deposit account user token.
         * @param {string} token Token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getDepositAccountUserToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepositAccountUserToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getDepositAccountUserToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get space.
         * @param {string} space 
         * @param {string} key 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpace(space: string, key: string, timeout?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpace(space, key, timeout, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSpace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get spaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpaces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSpaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of transitions associated with the refund.
         * @summary List transitions associated with a refund
         * @param {string} accountToken Unique identifier of the credit account
         * @param {string} refundToken Unique identifier of the refund
         * @param {number} [count] The number of resources to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {RetrieveRefundTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRefundTransitions(accountToken: string, refundToken: string, count?: number, startIndex?: number, sortBy?: RetrieveRefundTransitionsSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundTransitionsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRefundTransitions(accountToken, refundToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.retrieveRefundTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Create space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpace(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createSpace(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create space for key.
         * @param {string} space 
         * @param {string} key 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpaceForKey(space: string, key: string, timeout?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createSpaceForKey(space, key, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} queueName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQueue(queueName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteQueue(queueName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete space.
         * @param {string} space 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSpace(space: string, key: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSpace(space, key, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is to get a fraud feedback from the customer.
         * @summary Creates a fraud feedback
         * @param {FraudFeedbackRequest} fraudFeedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackFraudPost(fraudFeedbackRequest: FraudFeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<FraudFeedbackResponse> {
            return localVarFp.feedbackFraudPost(fraudFeedbackRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get deposit account user token.
         * @param {string} token Token
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDepositAccountUserToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDepositAccountUserToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get space.
         * @param {string} space 
         * @param {string} key 
         * @param {number} [timeout] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpace(space: string, key: string, timeout?: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSpace(space, key, timeout, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get spaces.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpaces(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSpaces(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of transitions associated with the refund.
         * @summary List transitions associated with a refund
         * @param {string} accountToken Unique identifier of the credit account
         * @param {string} refundToken Unique identifier of the refund
         * @param {number} [count] The number of resources to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {RetrieveRefundTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRefundTransitions(accountToken: string, refundToken: string, count?: number, startIndex?: number, sortBy?: RetrieveRefundTransitionsSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<RefundTransitionsPage> {
            return localVarFp.retrieveRefundTransitions(accountToken, refundToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Create space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSpace(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createSpace(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create space for key.
     * @param {string} space 
     * @param {string} key 
     * @param {number} [timeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createSpaceForKey(space: string, key: string, timeout?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createSpaceForKey(space, key, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} queueName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteQueue(queueName: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteQueue(queueName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete space.
     * @param {string} space 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteSpace(space: string, key: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteSpace(space, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is to get a fraud feedback from the customer.
     * @summary Creates a fraud feedback
     * @param {FraudFeedbackRequest} fraudFeedbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feedbackFraudPost(fraudFeedbackRequest: FraudFeedbackRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).feedbackFraudPost(fraudFeedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get deposit account user token.
     * @param {string} token Token
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getDepositAccountUserToken(token: string, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getDepositAccountUserToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get space.
     * @param {string} space 
     * @param {string} key 
     * @param {number} [timeout] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSpace(space: string, key: string, timeout?: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSpace(space, key, timeout, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get spaces.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSpaces(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSpaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of transitions associated with the refund.
     * @summary List transitions associated with a refund
     * @param {string} accountToken Unique identifier of the credit account
     * @param {string} refundToken Unique identifier of the refund
     * @param {number} [count] The number of resources to retrieve.
     * @param {number} [startIndex] The sort order index of the first resource in the returned array.
     * @param {RetrieveRefundTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveRefundTransitions(accountToken: string, refundToken: string, count?: number, startIndex?: number, sortBy?: RetrieveRefundTransitionsSortByEnum, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).retrieveRefundTransitions(accountToken, refundToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}

export const RetrieveRefundTransitionsSortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime'
} as const;
export type RetrieveRefundTransitionsSortByEnum = typeof RetrieveRefundTransitionsSortByEnum[keyof typeof RetrieveRefundTransitionsSortByEnum];


/**
 * DelinquencyApi - axios parameter creator
 */
export const DelinquencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent: async (eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('resendWebhookEvent', 'eventType', eventType)
            // verify required parameter 'resourceToken' is not null or undefined
            assertParamExists('resendWebhookEvent', 'resourceToken', resourceToken)
            const localVarPath = `/webhooks/{event_type}/{resource_token}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"resource_token"}}`, encodeURIComponent(String(resourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of the current delinquency state of a credit account.  An account is delinquent when it is past due on payments and current when it is up to date on payments.
         * @summary Retrieve delinquency state
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDelinquencyState: async (accountToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveDelinquencyState', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/delinquencystate`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific delinquency state transition on a credit account.  A delinquency state transition occurs when an account\'s delinquency state transitions between delinquent and current. An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.
         * @summary Retrieve delinquency state transition
         * @param {string} accountToken Unique identifier of the credit account whose delinquency state transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} delinquencyTransitionToken Unique identifier of the delinquency state transition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDelinquencyTransition: async (accountToken: string, delinquencyTransitionToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveDelinquencyTransition', 'accountToken', accountToken)
            // verify required parameter 'delinquencyTransitionToken' is not null or undefined
            assertParamExists('retrieveDelinquencyTransition', 'delinquencyTransitionToken', delinquencyTransitionToken)
            const localVarPath = `/accounts/{account_token}/delinquencystate/transitions/{delinquency_transition_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"delinquency_transition_token"}}`, encodeURIComponent(String(delinquencyTransitionToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of delinquency state transitions for a credit account.  A delinquency state transition occurs when an account\'s delinquency state transitions between delinquent and current. An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.
         * @summary List delinquency state transitions
         * @param {string} accountToken Unique identifier of the credit account whose delinquency state transitions you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrieveDelinquencyTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;impactTime&#x60;, and not by the field names appearing in response bodies such as &#x60;impact_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDelinquencyTransitions: async (accountToken: string, count?: number, startIndex?: number, sortBy?: RetrieveDelinquencyTransitionsSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveDelinquencyTransitions', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/delinquencystate/transitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DelinquencyApi - functional programming interface
 */
export const DelinquencyApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DelinquencyApiAxiosParamCreator(configuration)
    return {
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResendContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhookEvent(eventType, resourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DelinquencyApi.resendWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of the current delinquency state of a credit account.  An account is delinquent when it is past due on payments and current when it is up to date on payments.
         * @summary Retrieve delinquency state
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDelinquencyState(accountToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelinquencyStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveDelinquencyState(accountToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DelinquencyApi.retrieveDelinquencyState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific delinquency state transition on a credit account.  A delinquency state transition occurs when an account\'s delinquency state transitions between delinquent and current. An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.
         * @summary Retrieve delinquency state transition
         * @param {string} accountToken Unique identifier of the credit account whose delinquency state transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} delinquencyTransitionToken Unique identifier of the delinquency state transition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDelinquencyTransition(accountToken: string, delinquencyTransitionToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelinquencyTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveDelinquencyTransition(accountToken, delinquencyTransitionToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DelinquencyApi.retrieveDelinquencyTransition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of delinquency state transitions for a credit account.  A delinquency state transition occurs when an account\'s delinquency state transitions between delinquent and current. An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.
         * @summary List delinquency state transitions
         * @param {string} accountToken Unique identifier of the credit account whose delinquency state transitions you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrieveDelinquencyTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;impactTime&#x60;, and not by the field names appearing in response bodies such as &#x60;impact_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDelinquencyTransitions(accountToken: string, count?: number, startIndex?: number, sortBy?: RetrieveDelinquencyTransitionsSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DelinquencyTransitionsResponsePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveDelinquencyTransitions(accountToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DelinquencyApi.retrieveDelinquencyTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DelinquencyApi - factory interface
 */
export const DelinquencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DelinquencyApiFp(configuration)
    return {
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResendContainerResponse> {
            return localVarFp.resendWebhookEvent(eventType, resourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of the current delinquency state of a credit account.  An account is delinquent when it is past due on payments and current when it is up to date on payments.
         * @summary Retrieve delinquency state
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDelinquencyState(accountToken: string, options?: RawAxiosRequestConfig): AxiosPromise<DelinquencyStateResponse> {
            return localVarFp.retrieveDelinquencyState(accountToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific delinquency state transition on a credit account.  A delinquency state transition occurs when an account\'s delinquency state transitions between delinquent and current. An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.
         * @summary Retrieve delinquency state transition
         * @param {string} accountToken Unique identifier of the credit account whose delinquency state transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} delinquencyTransitionToken Unique identifier of the delinquency state transition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDelinquencyTransition(accountToken: string, delinquencyTransitionToken: string, options?: RawAxiosRequestConfig): AxiosPromise<DelinquencyTransitionResponse> {
            return localVarFp.retrieveDelinquencyTransition(accountToken, delinquencyTransitionToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of delinquency state transitions for a credit account.  A delinquency state transition occurs when an account\'s delinquency state transitions between delinquent and current. An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.
         * @summary List delinquency state transitions
         * @param {string} accountToken Unique identifier of the credit account whose delinquency state transitions you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrieveDelinquencyTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;impactTime&#x60;, and not by the field names appearing in response bodies such as &#x60;impact_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDelinquencyTransitions(accountToken: string, count?: number, startIndex?: number, sortBy?: RetrieveDelinquencyTransitionsSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<DelinquencyTransitionsResponsePage> {
            return localVarFp.retrieveDelinquencyTransitions(accountToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DelinquencyApi - object-oriented interface
 */
export class DelinquencyApi extends BaseAPI {
    /**
     * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
     * @summary Resend credit event notification
     * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig) {
        return DelinquencyApiFp(this.configuration).resendWebhookEvent(eventType, resourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of the current delinquency state of a credit account.  An account is delinquent when it is past due on payments and current when it is up to date on payments.
     * @summary Retrieve delinquency state
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve delinquency state details.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveDelinquencyState(accountToken: string, options?: RawAxiosRequestConfig) {
        return DelinquencyApiFp(this.configuration).retrieveDelinquencyState(accountToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific delinquency state transition on a credit account.  A delinquency state transition occurs when an account\'s delinquency state transitions between delinquent and current. An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.
     * @summary Retrieve delinquency state transition
     * @param {string} accountToken Unique identifier of the credit account whose delinquency state transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} delinquencyTransitionToken Unique identifier of the delinquency state transition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveDelinquencyTransition(accountToken: string, delinquencyTransitionToken: string, options?: RawAxiosRequestConfig) {
        return DelinquencyApiFp(this.configuration).retrieveDelinquencyTransition(accountToken, delinquencyTransitionToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of delinquency state transitions for a credit account.  A delinquency state transition occurs when an account\'s delinquency state transitions between delinquent and current. An account becomes delinquent when it falls behind on payments and becomes current when payments are made up to date.
     * @summary List delinquency state transitions
     * @param {string} accountToken Unique identifier of the credit account whose delinquency state transitions you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {number} [count] Number of resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {RetrieveDelinquencyTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;impactTime&#x60;, and not by the field names appearing in response bodies such as &#x60;impact_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveDelinquencyTransitions(accountToken: string, count?: number, startIndex?: number, sortBy?: RetrieveDelinquencyTransitionsSortByEnum, options?: RawAxiosRequestConfig) {
        return DelinquencyApiFp(this.configuration).retrieveDelinquencyTransitions(accountToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}


export const RetrieveDelinquencyTransitionsSortByEnum = {
    ImpactTime: 'impactTime',
    ImpactTime2: '-impactTime'
} as const;
export type RetrieveDelinquencyTransitionsSortByEnum = typeof RetrieveDelinquencyTransitionsSortByEnum[keyof typeof RetrieveDelinquencyTransitionsSortByEnum];


/**
 * DigitalWalletsManagementApi - axios parameter creator
 */
export const DigitalWalletsManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create additional aliases associated with an existing main alias.
         * @summary Create an additional alias
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsCreateAdditionalAliasesRequest} adsCreateAdditionalAliasesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdditionalAliases: async (aliasId: string, reqSysId: string, adsCreateAdditionalAliasesRequest: AdsCreateAdditionalAliasesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasId' is not null or undefined
            assertParamExists('createAdditionalAliases', 'aliasId', aliasId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('createAdditionalAliases', 'reqSysId', reqSysId)
            // verify required parameter 'adsCreateAdditionalAliasesRequest' is not null or undefined
            assertParamExists('createAdditionalAliases', 'adsCreateAdditionalAliasesRequest', adsCreateAdditionalAliasesRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/{aliasId}/additionalAlias`
                .replace(`{${"aliasId"}}`, encodeURIComponent(String(aliasId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adsCreateAdditionalAliasesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create an alias.
         * @summary Create an alias
         * @param {string} reqSysId 
         * @param {AdsCreateAliasRequest} adsCreateAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias: async (reqSysId: string, adsCreateAliasRequest: AdsCreateAliasRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('createAlias', 'reqSysId', reqSysId)
            // verify required parameter 'adsCreateAliasRequest' is not null or undefined
            assertParamExists('createAlias', 'adsCreateAliasRequest', adsCreateAliasRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adsCreateAliasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create a payment credential associated with an alias.
         * @summary Create alias payment credential
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsCardDetailsRequest} adsCardDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCardByAlias: async (aliasId: string, reqSysId: string, adsCardDetailsRequest: AdsCardDetailsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasId' is not null or undefined
            assertParamExists('createCardByAlias', 'aliasId', aliasId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('createCardByAlias', 'reqSysId', reqSysId)
            // verify required parameter 'adsCardDetailsRequest' is not null or undefined
            assertParamExists('createCardByAlias', 'adsCardDetailsRequest', adsCardDetailsRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/{aliasId}/cards`
                .replace(`{${"aliasId"}}`, encodeURIComponent(String(aliasId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adsCardDetailsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create a new report request.
         * @summary Create a report request
         * @param {string} reqSysId 
         * @param {AdsCreateReportRequest} adsCreateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport: async (reqSysId: string, adsCreateReportRequest: AdsCreateReportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('createReport', 'reqSysId', reqSysId)
            // verify required parameter 'adsCreateReportRequest' is not null or undefined
            assertParamExists('createReport', 'adsCreateReportRequest', adsCreateReportRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adsCreateReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete an additional alias by additional alias ID.
         * @summary Delete an additional alias
         * @param {string} additionalAliasId Unique identifier of the additional alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdditionalAliasById: async (additionalAliasId: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'additionalAliasId' is not null or undefined
            assertParamExists('deleteAdditionalAliasById', 'additionalAliasId', additionalAliasId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('deleteAdditionalAliasById', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/additionalAliases/{additionalAliasId}`
                .replace(`{${"additionalAliasId"}}`, encodeURIComponent(String(additionalAliasId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete an alias by alias ID.
         * @summary Delete alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAliasById: async (aliasId: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasId' is not null or undefined
            assertParamExists('deleteAliasById', 'aliasId', aliasId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('deleteAliasById', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/{aliasId}`
                .replace(`{${"aliasId"}}`, encodeURIComponent(String(aliasId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete a payment credential associated with a card token.
         * @summary Delete card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardByCardToken: async (cardToken: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardToken' is not null or undefined
            assertParamExists('deleteCardByCardToken', 'cardToken', cardToken)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('deleteCardByCardToken', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/cards/{cardToken}`
                .replace(`{${"cardToken"}}`, encodeURIComponent(String(cardToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete cardholder information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Delete cardholder information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardHolderInfo: async (reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('deleteCardHolderInfo', 'reqSysId', reqSysId)
            const localVarPath = `/clicktopay/visa/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete card information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Delete card information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardInfo: async (reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('deleteCardInfo', 'reqSysId', reqSysId)
            const localVarPath = `/clicktopay/visa/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to enroll a new card for an existing cardholder in Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a card to Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayEnrollCardsRequest} visaClickToPayEnrollCardsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollCard: async (reqSysId: string, visaClickToPayEnrollCardsRequest: VisaClickToPayEnrollCardsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('enrollCard', 'reqSysId', reqSysId)
            // verify required parameter 'visaClickToPayEnrollCardsRequest' is not null or undefined
            assertParamExists('enrollCard', 'visaClickToPayEnrollCardsRequest', visaClickToPayEnrollCardsRequest)
            const localVarPath = `/clicktopay/visa/enrollcards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(visaClickToPayEnrollCardsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to enroll a new cardholder in Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a cardholder to Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayEnrollRequest} visaClickToPayEnrollRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollCardholder: async (reqSysId: string, visaClickToPayEnrollRequest: VisaClickToPayEnrollRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('enrollCardholder', 'reqSysId', reqSysId)
            // verify required parameter 'visaClickToPayEnrollRequest' is not null or undefined
            assertParamExists('enrollCardholder', 'visaClickToPayEnrollRequest', visaClickToPayEnrollRequest)
            const localVarPath = `/clicktopay/visa/enroll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(visaClickToPayEnrollRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to add a card to Apple Wallet via a web application.
         * @summary Create request for Apple Wallet web push provisioning
         * @param {string} reqSysId Random pseudo-unique value used for troubleshooting between multiple parties.
         * @param {RequestForApplePayWppJWT} requestForApplePayWppJWT 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApplePayWPPJWT: async (reqSysId: string, requestForApplePayWppJWT: RequestForApplePayWppJWT, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('generateApplePayWPPJWT', 'reqSysId', reqSysId)
            // verify required parameter 'requestForApplePayWppJWT' is not null or undefined
            assertParamExists('generateApplePayWPPJWT', 'requestForApplePayWppJWT', requestForApplePayWppJWT)
            const localVarPath = `/digitalwallets/wpp/applePayJWT`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(requestForApplePayWppJWT, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve an alias by external ID.
         * @summary Retrieve alias by external ID
         * @param {string} reqSysId 
         * @param {AdsGetByExternalIdRequest} adsGetByExternalIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasByExternalId: async (reqSysId: string, adsGetByExternalIdRequest: AdsGetByExternalIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getAliasByExternalId', 'reqSysId', reqSysId)
            // verify required parameter 'adsGetByExternalIdRequest' is not null or undefined
            assertParamExists('getAliasByExternalId', 'adsGetByExternalIdRequest', adsGetByExternalIdRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/getByExternalId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adsGetByExternalIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve an alias by alias ID.
         * @summary Retrieve alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasById: async (aliasId: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasId' is not null or undefined
            assertParamExists('getAliasById', 'aliasId', aliasId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getAliasById', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/{aliasId}`
                .replace(`{${"aliasId"}}`, encodeURIComponent(String(aliasId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve the internal ID associated with an alias.
         * @summary Retrieve alias internal ID
         * @param {string} reqSysId 
         * @param {GetAliasIdByValueRequest} getAliasIdByValueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasIdByValue: async (reqSysId: string, getAliasIdByValueRequest: GetAliasIdByValueRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getAliasIdByValue', 'reqSysId', reqSysId)
            // verify required parameter 'getAliasIdByValueRequest' is not null or undefined
            assertParamExists('getAliasIdByValue', 'getAliasIdByValueRequest', getAliasIdByValueRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/aliasId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(getAliasIdByValueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a payment credential associated with a card token.
         * @summary Retrieve card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardByCardToken: async (cardToken: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardToken' is not null or undefined
            assertParamExists('getCardByCardToken', 'cardToken', cardToken)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getCardByCardToken', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/cards/{cardToken}`
                .replace(`{${"cardToken"}}`, encodeURIComponent(String(cardToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a list of payment credentials associated with an alias.
         * @summary Retrieve alias payment credentials
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsByAlias: async (aliasId: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasId' is not null or undefined
            assertParamExists('getCardsByAlias', 'aliasId', aliasId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getCardsByAlias', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/{aliasId}/cards`
                .replace(`{${"aliasId"}}`, encodeURIComponent(String(aliasId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to check if a provided BIN prefix is eligible for Click to Pay for Mastercard.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Check eligibility for Click to Pay for Mastercard
         * @param {string} binPrefix Prefix of the bank identification number.
         * @param {string} reqSysId 
         * @param {boolean} [includeAsset] Returns a list of image assets for the Click to Pay logo if set to &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicktopayMastercardCheckeligibility: async (binPrefix: string, reqSysId: string, includeAsset?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'binPrefix' is not null or undefined
            assertParamExists('getClicktopayMastercardCheckeligibility', 'binPrefix', binPrefix)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getClicktopayMastercardCheckeligibility', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/clicktopay/mastercard/checkeligibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (binPrefix !== undefined) {
                localVarQueryParameter['bin_prefix'] = binPrefix;
            }

            if (includeAsset !== undefined) {
                localVarQueryParameter['include_asset'] = includeAsset;
            }



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to return the status of a specific Click to Pay for Mastercard request.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve Click to Pay for Mastercard enrollment status
         * @param {string} token Unique identifier of the Click to Pay request.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicktopayMastercardStatusToken: async (token: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getClicktopayMastercardStatusToken', 'token', token)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getClicktopayMastercardStatusToken', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/clicktopay/mastercard/status/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a list of digital wallet tokens.
         * @summary List digital wallet tokens
         * @param {number} [count] Number of digital wallet token resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first digital wallet token resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] Date when the digital wallet token becomes active.
         * @param {string} [endDate] Expiration date of the digital wallet token.
         * @param {string} [panReferenceId] Unique identifier of the digital wallet token primary account number (PAN) within the card network. This value may vary, depending on the digital wallet. For example, the &#x60;pan_reference_id&#x60; may be different in Apple Wallet and Google Wallet for the same digital wallet token.
         * @param {string} [tokenReferenceId] Unique identifier of the digital wallet token within the card network. The &#x60;token_reference_id&#x60; is unique at the card network level.
         * @param {string} [correlationId] Unique value representing a tokenization request (Mastercard only).
         * @param {string} [tokenType] Comma-delimited list of digital wallet token types to display.
         * @param {string} [tokenRequestorName] Name of the token requestor within the card network.  *NOTE:* The list of example values for this field is maintained by the card networks and is subject to change.
         * @param {string} [state] Comma-delimited list of digital wallet token states to display.
         * @param {GetDigitalwallettokensEmbedEnum} [embed] An optional embedded user object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokens: async (count?: number, startIndex?: number, fields?: string, sortBy?: string, startDate?: string, endDate?: string, panReferenceId?: string, tokenReferenceId?: string, correlationId?: string, tokenType?: string, tokenRequestorName?: string, state?: string, embed?: GetDigitalwallettokensEmbedEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalwallettokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (panReferenceId !== undefined) {
                localVarQueryParameter['pan_reference_id'] = panReferenceId;
            }

            if (tokenReferenceId !== undefined) {
                localVarQueryParameter['token_reference_id'] = tokenReferenceId;
            }

            if (correlationId !== undefined) {
                localVarQueryParameter['correlation_id'] = correlationId;
            }

            if (tokenType !== undefined) {
                localVarQueryParameter['token_type'] = tokenType;
            }

            if (tokenRequestorName !== undefined) {
                localVarQueryParameter['token_requestor_name'] = tokenRequestorName;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to return an array of all digital wallet tokens for a particular card.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List digital wallet tokens for card
         * @param {string} cardToken Unique identifier of the card. Used to minimize the need to exchange card details during subsequent calls, and also for troubleshooting.
         * @param {number} [count] Number of digital wallet token resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first digital wallet token resource in the returned array.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensCardCardtoken: async (cardToken: string, count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardToken' is not null or undefined
            assertParamExists('getDigitalwallettokensCardCardtoken', 'cardToken', cardToken)
            const localVarPath = `/digitalwallettokens/card/{card_token}`
                .replace(`{${"card_token"}}`, encodeURIComponent(String(cardToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a specific digital wallet token.
         * @summary Retrieve digital wallet token
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDigitalwallettokensToken', 'token', token)
            const localVarPath = `/digitalwallettokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a digital wallet token with the entire primary account number (PAN) displayed. The PAN returned is of the digital wallet token and not of the card. (For security reasons, the PAN is not fully visible on the digital wallet token returned by `GET` `/digitalwallettokens/{token}`.)  [WARNING] Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.
         * @summary Retrieve digital wallet token PAN
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensTokenShowtokenpan: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDigitalwallettokensTokenShowtokenpan', 'token', token)
            const localVarPath = `/digitalwallettokens/{token}/showtokenpan`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to return an array of all transitions for a particular digital wallet token.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List transitions for digital wallet token
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {number} [count] Number of digital wallet transitions to retrieve.
         * @param {number} [startIndex] The sort order index of the first digital wallet token in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsDigitalwallettokenToken: async (token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDigitalwallettokentransitionsDigitalwallettokenToken', 'token', token)
            const localVarPath = `/digitalwallettokentransitions/digitalwallettoken/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a specific digital wallet token transition.  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary Retrieve digital wallet token transition
         * @param {string} token Unique identifier of the digital wallet token (DWT) transition.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDigitalwallettokentransitionsToken', 'token', token)
            const localVarPath = `/digitalwallettokentransitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a file by file ID and report ID.
         * @summary Retrieve file by file ID and report ID
         * @param {string} reportId Unique identifier of the report.
         * @param {string} fileId Unique identifier of the file.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByReportAndFileId: async (reportId: string, fileId: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getFileByReportAndFileId', 'reportId', reportId)
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('getFileByReportAndFileId', 'fileId', fileId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getFileByReportAndFileId', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/reports/{reportId}/file/{fileId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve the status of a report by report ID.
         * @summary Retrieve report status by report ID
         * @param {string} reportId Unique identifier of the report.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportById: async (reportId: string, reqSysId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            assertParamExists('getReportById', 'reportId', reportId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getReportById', 'reqSysId', reqSysId)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/reports/{reportId}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to return the status of a Click to Pay for Visa request.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve Click to Pay for Visa request status
         * @param {string} reqSysId 
         * @param {string} requestTraceId Unique identifier of the Visa Click to Pay request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (reqSysId: string, requestTraceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getStatus', 'reqSysId', reqSysId)
            // verify required parameter 'requestTraceId' is not null or undefined
            assertParamExists('getStatus', 'requestTraceId', requestTraceId)
            const localVarPath = `/clicktopay/visa/status/{requestTraceId}`
                .replace(`{${"requestTraceId"}}`, encodeURIComponent(String(requestTraceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to get user data for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve user data for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {string} userToken Unique identifier of the cardholder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserData: async (reqSysId: string, userToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getUserData', 'reqSysId', reqSysId)
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('getUserData', 'userToken', userToken)
            const localVarPath = `/clicktopay/visa/getdata/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to enroll a card in Click to Pay for Mastercard.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a card to Click to Pay for Mastercard
         * @param {string} reqSysId 
         * @param {ClickToPayEnrollRequest} clickToPayEnrollRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postClicktopayMastercardEnroll: async (reqSysId: string, clickToPayEnrollRequest: ClickToPayEnrollRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('postClicktopayMastercardEnroll', 'reqSysId', reqSysId)
            // verify required parameter 'clickToPayEnrollRequest' is not null or undefined
            assertParamExists('postClicktopayMastercardEnroll', 'clickToPayEnrollRequest', clickToPayEnrollRequest)
            const localVarPath = `/digitalwallets/clicktopay/mastercard/enroll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(clickToPayEnrollRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to return card data for use in provisioning a digital wallet token into Google Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Google Wallet
         * @param {DigitalWalletAndroidPayProvisionRequest} [digitalWalletAndroidPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsAndroidpay: async (digitalWalletAndroidPayProvisionRequest?: DigitalWalletAndroidPayProvisionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalwalletprovisionrequests/androidpay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(digitalWalletAndroidPayProvisionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to return card data for use in provisioning a digital wallet token into Apple Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Apple Wallet
         * @param {DigitalWalletApplePayProvisionRequest} [digitalWalletApplePayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsApplepay: async (digitalWalletApplePayProvisionRequest?: DigitalWalletApplePayProvisionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalwalletprovisionrequests/applepay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(digitalWalletApplePayProvisionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [NOTE] This endpoint is limited in availability. For more information, contact your Marqeta representative.  Use this endpoint to return card data for use in provisioning a digital wallet token into Samsung Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Samsung Wallet
         * @param {DigitalWalletSamsungPayProvisionRequest} [digitalWalletSamsungPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsSamsungpay: async (digitalWalletSamsungPayProvisionRequest?: DigitalWalletSamsungPayProvisionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalwalletprovisionrequests/samsungpay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(digitalWalletSamsungPayProvisionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [NOTE] This endpoint is limited in availability. For more information, contact your Marqeta representative.  Use this endpoint to return card data for use in provisioning a digital wallet token into an XPay digital wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for XPay
         * @param {DigitalWalletXPayProvisionRequest} [digitalWalletXPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsXPay: async (digitalWalletXPayProvisionRequest?: DigitalWalletXPayProvisionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalwalletprovisionrequests/xpay`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(digitalWalletXPayProvisionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to transition a digital wallet token from one state to another.
         * @summary Create digital wallet token transition
         * @param {DigitalWalletTokenTransitionRequest} [digitalWalletTokenTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwallettokentransitions: async (digitalWalletTokenTransitionRequest?: DigitalWalletTokenTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/digitalwallettokentransitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(digitalWalletTokenTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to submit a post-tokenization authentication decision from the customer to MQ in a secure card on file scenario.   MQ validates the request, stores it, and forwards the authentication decision to Mastercard MDES in real time.   MQ then returns the MDES response back to the customer synchronously.   This enables issuers to notify MDES of the cardholders authentication outcome following tokenization,   ensuring that the token requestor receives timely and accurate decisioning.
         * @param {PostTokenizationAuthenticationDecisionRequest} postTokenizationAuthenticationDecisionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTokenizationAuthenticationDecision: async (postTokenizationAuthenticationDecisionRequest: PostTokenizationAuthenticationDecisionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postTokenizationAuthenticationDecisionRequest' is not null or undefined
            assertParamExists('postTokenizationAuthenticationDecision', 'postTokenizationAuthenticationDecisionRequest', postTokenizationAuthenticationDecisionRequest)
            const localVarPath = `/digitalwallets/postTokenizationAuthenticationDecision`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(postTokenizationAuthenticationDecisionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to add a card to Google Wallet via a web application.  This endpoint does not return a payload in response to a request. Instead, a successful call will return a response code only.
         * @summary Create request for Google Wallet web push provisioning
         * @param {string} reqSysId Random pseudo-unique value used for troubleshooting between multiple parties.
         * @param {SendingProvisioningDataToGooglePayBackendRequest} sendingProvisioningDataToGooglePayBackendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOPCDataToGooglePay: async (reqSysId: string, sendingProvisioningDataToGooglePayBackendRequest: SendingProvisioningDataToGooglePayBackendRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('sendOPCDataToGooglePay', 'reqSysId', reqSysId)
            // verify required parameter 'sendingProvisioningDataToGooglePayBackendRequest' is not null or undefined
            assertParamExists('sendOPCDataToGooglePay', 'sendingProvisioningDataToGooglePayBackendRequest', sendingProvisioningDataToGooglePayBackendRequest)
            const localVarPath = `/digitalwallets/wpp/googlePayPushProvisioningNotification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(sendingProvisioningDataToGooglePayBackendRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update an alias by alias ID.
         * @summary Update alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsUpdateAliasRequest} adsUpdateAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAliasById: async (aliasId: string, reqSysId: string, adsUpdateAliasRequest: AdsUpdateAliasRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasId' is not null or undefined
            assertParamExists('updateAliasById', 'aliasId', aliasId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('updateAliasById', 'reqSysId', reqSysId)
            // verify required parameter 'adsUpdateAliasRequest' is not null or undefined
            assertParamExists('updateAliasById', 'adsUpdateAliasRequest', adsUpdateAliasRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/{aliasId}`
                .replace(`{${"aliasId"}}`, encodeURIComponent(String(aliasId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adsUpdateAliasRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update the status of an alias.
         * @summary Update alias status
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {UpdateAliasStatusRequest} updateAliasStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAliasStatus: async (aliasId: string, reqSysId: string, updateAliasStatusRequest: UpdateAliasStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aliasId' is not null or undefined
            assertParamExists('updateAliasStatus', 'aliasId', aliasId)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('updateAliasStatus', 'reqSysId', reqSysId)
            // verify required parameter 'updateAliasStatusRequest' is not null or undefined
            assertParamExists('updateAliasStatus', 'updateAliasStatusRequest', updateAliasStatusRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/aliases/{aliasId}/status`
                .replace(`{${"aliasId"}}`, encodeURIComponent(String(aliasId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(updateAliasStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update a payment credential associated with a card token.
         * @summary Update card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {AdsCardDetailsRequest} adsCardDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCardByCardToken: async (cardToken: string, reqSysId: string, adsCardDetailsRequest: AdsCardDetailsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardToken' is not null or undefined
            assertParamExists('updateCardByCardToken', 'cardToken', cardToken)
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('updateCardByCardToken', 'reqSysId', reqSysId)
            // verify required parameter 'adsCardDetailsRequest' is not null or undefined
            assertParamExists('updateCardByCardToken', 'adsCardDetailsRequest', adsCardDetailsRequest)
            const localVarPath = `/digitalwallets/aliasdirectory/visa/cards/{cardToken}`
                .replace(`{${"cardToken"}}`, encodeURIComponent(String(cardToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(adsCardDetailsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update cardholder information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Update cardholder information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayUpdateCardholderRequest} visaClickToPayUpdateCardholderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCardHolderInfo: async (reqSysId: string, visaClickToPayUpdateCardholderRequest: VisaClickToPayUpdateCardholderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('updateCardHolderInfo', 'reqSysId', reqSysId)
            // verify required parameter 'visaClickToPayUpdateCardholderRequest' is not null or undefined
            assertParamExists('updateCardHolderInfo', 'visaClickToPayUpdateCardholderRequest', visaClickToPayUpdateCardholderRequest)
            const localVarPath = `/clicktopay/visa/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(visaClickToPayUpdateCardholderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update card information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Update card information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayUpdateCardRequest} visaClickToPayUpdateCardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCardInfo: async (reqSysId: string, visaClickToPayUpdateCardRequest: VisaClickToPayUpdateCardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('updateCardInfo', 'reqSysId', reqSysId)
            // verify required parameter 'visaClickToPayUpdateCardRequest' is not null or undefined
            assertParamExists('updateCardInfo', 'visaClickToPayUpdateCardRequest', visaClickToPayUpdateCardRequest)
            const localVarPath = `/clicktopay/visa/cards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(visaClickToPayUpdateCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DigitalWalletsManagementApi - functional programming interface
 */
export const DigitalWalletsManagementApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DigitalWalletsManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create additional aliases associated with an existing main alias.
         * @summary Create an additional alias
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsCreateAdditionalAliasesRequest} adsCreateAdditionalAliasesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdditionalAliases(aliasId: string, reqSysId: string, adsCreateAdditionalAliasesRequest: AdsCreateAdditionalAliasesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsCreateAdditionalAliasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAdditionalAliases(aliasId, reqSysId, adsCreateAdditionalAliasesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.createAdditionalAliases']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to create an alias.
         * @summary Create an alias
         * @param {string} reqSysId 
         * @param {AdsCreateAliasRequest} adsCreateAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlias(reqSysId: string, adsCreateAliasRequest: AdsCreateAliasRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsCreateAliasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAlias(reqSysId, adsCreateAliasRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.createAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to create a payment credential associated with an alias.
         * @summary Create alias payment credential
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsCardDetailsRequest} adsCardDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCardByAlias(aliasId: string, reqSysId: string, adsCardDetailsRequest: AdsCardDetailsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsCreateCardDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCardByAlias(aliasId, reqSysId, adsCardDetailsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.createCardByAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to create a new report request.
         * @summary Create a report request
         * @param {string} reqSysId 
         * @param {AdsCreateReportRequest} adsCreateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReport(reqSysId: string, adsCreateReportRequest: AdsCreateReportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateReport200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReport(reqSysId, adsCreateReportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.createReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to delete an additional alias by additional alias ID.
         * @summary Delete an additional alias
         * @param {string} additionalAliasId Unique identifier of the additional alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAdditionalAliasById(additionalAliasId: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAdditionalAliasById(additionalAliasId, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.deleteAdditionalAliasById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to delete an alias by alias ID.
         * @summary Delete alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAliasById(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAliasById(aliasId, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.deleteAliasById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to delete a payment credential associated with a card token.
         * @summary Delete card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCardByCardToken(cardToken: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCardByCardToken(cardToken, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.deleteCardByCardToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to delete cardholder information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Delete cardholder information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCardHolderInfo(reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisaClickToPayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCardHolderInfo(reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.deleteCardHolderInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to delete card information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Delete card information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCardInfo(reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisaClickToPayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCardInfo(reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.deleteCardInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to enroll a new card for an existing cardholder in Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a card to Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayEnrollCardsRequest} visaClickToPayEnrollCardsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollCard(reqSysId: string, visaClickToPayEnrollCardsRequest: VisaClickToPayEnrollCardsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisaClickToPayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollCard(reqSysId, visaClickToPayEnrollCardsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.enrollCard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to enroll a new cardholder in Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a cardholder to Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayEnrollRequest} visaClickToPayEnrollRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enrollCardholder(reqSysId: string, visaClickToPayEnrollRequest: VisaClickToPayEnrollRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisaClickToPayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enrollCardholder(reqSysId, visaClickToPayEnrollRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.enrollCardholder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to add a card to Apple Wallet via a web application.
         * @summary Create request for Apple Wallet web push provisioning
         * @param {string} reqSysId Random pseudo-unique value used for troubleshooting between multiple parties.
         * @param {RequestForApplePayWppJWT} requestForApplePayWppJWT 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateApplePayWPPJWT(reqSysId: string, requestForApplePayWppJWT: RequestForApplePayWppJWT, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebPushProvisioningApplePayJWTResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateApplePayWPPJWT(reqSysId, requestForApplePayWppJWT, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.generateApplePayWPPJWT']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve an alias by external ID.
         * @summary Retrieve alias by external ID
         * @param {string} reqSysId 
         * @param {AdsGetByExternalIdRequest} adsGetByExternalIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAliasByExternalId(reqSysId: string, adsGetByExternalIdRequest: AdsGetByExternalIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsGetByExternalIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAliasByExternalId(reqSysId, adsGetByExternalIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getAliasByExternalId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve an alias by alias ID.
         * @summary Retrieve alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAliasById(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsAliasResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAliasById(aliasId, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getAliasById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve the internal ID associated with an alias.
         * @summary Retrieve alias internal ID
         * @param {string} reqSysId 
         * @param {GetAliasIdByValueRequest} getAliasIdByValueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAliasIdByValue(reqSysId: string, getAliasIdByValueRequest: GetAliasIdByValueRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAliasIdByValue200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAliasIdByValue(reqSysId, getAliasIdByValueRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getAliasIdByValue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a payment credential associated with a card token.
         * @summary Retrieve card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardByCardToken(cardToken: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsCardsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardByCardToken(cardToken, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getCardByCardToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a list of payment credentials associated with an alias.
         * @summary Retrieve alias payment credentials
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCardsByAlias(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsCardsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCardsByAlias(aliasId, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getCardsByAlias']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to check if a provided BIN prefix is eligible for Click to Pay for Mastercard.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Check eligibility for Click to Pay for Mastercard
         * @param {string} binPrefix Prefix of the bank identification number.
         * @param {string} reqSysId 
         * @param {boolean} [includeAsset] Returns a list of image assets for the Click to Pay logo if set to &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClicktopayMastercardCheckeligibility(binPrefix: string, reqSysId: string, includeAsset?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClickToPayCheckEligibilityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClicktopayMastercardCheckeligibility(binPrefix, reqSysId, includeAsset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getClicktopayMastercardCheckeligibility']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to return the status of a specific Click to Pay for Mastercard request.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve Click to Pay for Mastercard enrollment status
         * @param {string} token Unique identifier of the Click to Pay request.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClicktopayMastercardStatusToken(token: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClickToPayStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClicktopayMastercardStatusToken(token, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getClicktopayMastercardStatusToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a list of digital wallet tokens.
         * @summary List digital wallet tokens
         * @param {number} [count] Number of digital wallet token resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first digital wallet token resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] Date when the digital wallet token becomes active.
         * @param {string} [endDate] Expiration date of the digital wallet token.
         * @param {string} [panReferenceId] Unique identifier of the digital wallet token primary account number (PAN) within the card network. This value may vary, depending on the digital wallet. For example, the &#x60;pan_reference_id&#x60; may be different in Apple Wallet and Google Wallet for the same digital wallet token.
         * @param {string} [tokenReferenceId] Unique identifier of the digital wallet token within the card network. The &#x60;token_reference_id&#x60; is unique at the card network level.
         * @param {string} [correlationId] Unique value representing a tokenization request (Mastercard only).
         * @param {string} [tokenType] Comma-delimited list of digital wallet token types to display.
         * @param {string} [tokenRequestorName] Name of the token requestor within the card network.  *NOTE:* The list of example values for this field is maintained by the card networks and is subject to change.
         * @param {string} [state] Comma-delimited list of digital wallet token states to display.
         * @param {GetDigitalwallettokensEmbedEnum} [embed] An optional embedded user object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDigitalwallettokens(count?: number, startIndex?: number, fields?: string, sortBy?: string, startDate?: string, endDate?: string, panReferenceId?: string, tokenReferenceId?: string, correlationId?: string, tokenType?: string, tokenRequestorName?: string, state?: string, embed?: GetDigitalwallettokensEmbedEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletTokenListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDigitalwallettokens(count, startIndex, fields, sortBy, startDate, endDate, panReferenceId, tokenReferenceId, correlationId, tokenType, tokenRequestorName, state, embed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getDigitalwallettokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to return an array of all digital wallet tokens for a particular card.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List digital wallet tokens for card
         * @param {string} cardToken Unique identifier of the card. Used to minimize the need to exchange card details during subsequent calls, and also for troubleshooting.
         * @param {number} [count] Number of digital wallet token resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first digital wallet token resource in the returned array.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDigitalwallettokensCardCardtoken(cardToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletTokenListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDigitalwallettokensCardCardtoken(cardToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getDigitalwallettokensCardCardtoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a specific digital wallet token.
         * @summary Retrieve digital wallet token
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDigitalwallettokensToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDigitalwallettokensToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getDigitalwallettokensToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a digital wallet token with the entire primary account number (PAN) displayed. The PAN returned is of the digital wallet token and not of the card. (For security reasons, the PAN is not fully visible on the digital wallet token returned by `GET` `/digitalwallettokens/{token}`.)  [WARNING] Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.
         * @summary Retrieve digital wallet token PAN
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDigitalwallettokensTokenShowtokenpan(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDigitalwallettokensTokenShowtokenpan(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getDigitalwallettokensTokenShowtokenpan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to return an array of all transitions for a particular digital wallet token.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List transitions for digital wallet token
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {number} [count] Number of digital wallet transitions to retrieve.
         * @param {number} [startIndex] The sort order index of the first digital wallet token in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDigitalwallettokentransitionsDigitalwallettokenToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletTokenTransitionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDigitalwallettokentransitionsDigitalwallettokenToken(token, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getDigitalwallettokentransitionsDigitalwallettokenToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a specific digital wallet token transition.  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary Retrieve digital wallet token transition
         * @param {string} token Unique identifier of the digital wallet token (DWT) transition.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDigitalwallettokentransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletTokenTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDigitalwallettokentransitionsToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getDigitalwallettokentransitionsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a file by file ID and report ID.
         * @summary Retrieve file by file ID and report ID
         * @param {string} reportId Unique identifier of the report.
         * @param {string} fileId Unique identifier of the file.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileByReportAndFileId(reportId: string, fileId: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdsReportFileResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileByReportAndFileId(reportId, fileId, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getFileByReportAndFileId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve the status of a report by report ID.
         * @summary Retrieve report status by report ID
         * @param {string} reportId Unique identifier of the report.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportById(reportId: string, reqSysId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsGetReportStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReportById(reportId, reqSysId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getReportById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to return the status of a Click to Pay for Visa request.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve Click to Pay for Visa request status
         * @param {string} reqSysId 
         * @param {string} requestTraceId Unique identifier of the Visa Click to Pay request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(reqSysId: string, requestTraceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisaClickToPayStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(reqSysId, requestTraceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to get user data for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve user data for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {string} userToken Unique identifier of the cardholder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserData(reqSysId: string, userToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisaClickToPayGetUserDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserData(reqSysId, userToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.getUserData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to enroll a card in Click to Pay for Mastercard.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a card to Click to Pay for Mastercard
         * @param {string} reqSysId 
         * @param {ClickToPayEnrollRequest} clickToPayEnrollRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postClicktopayMastercardEnroll(reqSysId: string, clickToPayEnrollRequest: ClickToPayEnrollRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClickToPayEnrollResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postClicktopayMastercardEnroll(reqSysId, clickToPayEnrollRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.postClicktopayMastercardEnroll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to return card data for use in provisioning a digital wallet token into Google Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Google Wallet
         * @param {DigitalWalletAndroidPayProvisionRequest} [digitalWalletAndroidPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDigitalwalletprovisionrequestsAndroidpay(digitalWalletAndroidPayProvisionRequest?: DigitalWalletAndroidPayProvisionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletAndroidPayProvisionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDigitalwalletprovisionrequestsAndroidpay(digitalWalletAndroidPayProvisionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.postDigitalwalletprovisionrequestsAndroidpay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to return card data for use in provisioning a digital wallet token into Apple Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Apple Wallet
         * @param {DigitalWalletApplePayProvisionRequest} [digitalWalletApplePayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDigitalwalletprovisionrequestsApplepay(digitalWalletApplePayProvisionRequest?: DigitalWalletApplePayProvisionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletApplePayProvisionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDigitalwalletprovisionrequestsApplepay(digitalWalletApplePayProvisionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.postDigitalwalletprovisionrequestsApplepay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [NOTE] This endpoint is limited in availability. For more information, contact your Marqeta representative.  Use this endpoint to return card data for use in provisioning a digital wallet token into Samsung Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Samsung Wallet
         * @param {DigitalWalletSamsungPayProvisionRequest} [digitalWalletSamsungPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDigitalwalletprovisionrequestsSamsungpay(digitalWalletSamsungPayProvisionRequest?: DigitalWalletSamsungPayProvisionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletSamsungPayProvisionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDigitalwalletprovisionrequestsSamsungpay(digitalWalletSamsungPayProvisionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.postDigitalwalletprovisionrequestsSamsungpay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [NOTE] This endpoint is limited in availability. For more information, contact your Marqeta representative.  Use this endpoint to return card data for use in provisioning a digital wallet token into an XPay digital wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for XPay
         * @param {DigitalWalletXPayProvisionRequest} [digitalWalletXPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDigitalwalletprovisionrequestsXPay(digitalWalletXPayProvisionRequest?: DigitalWalletXPayProvisionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletXPayProvisionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDigitalwalletprovisionrequestsXPay(digitalWalletXPayProvisionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.postDigitalwalletprovisionrequestsXPay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to transition a digital wallet token from one state to another.
         * @summary Create digital wallet token transition
         * @param {DigitalWalletTokenTransitionRequest} [digitalWalletTokenTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDigitalwallettokentransitions(digitalWalletTokenTransitionRequest?: DigitalWalletTokenTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DigitalWalletTokenTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDigitalwallettokentransitions(digitalWalletTokenTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.postDigitalwallettokentransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to submit a post-tokenization authentication decision from the customer to MQ in a secure card on file scenario.   MQ validates the request, stores it, and forwards the authentication decision to Mastercard MDES in real time.   MQ then returns the MDES response back to the customer synchronously.   This enables issuers to notify MDES of the cardholders authentication outcome following tokenization,   ensuring that the token requestor receives timely and accurate decisioning.
         * @param {PostTokenizationAuthenticationDecisionRequest} postTokenizationAuthenticationDecisionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTokenizationAuthenticationDecision(postTokenizationAuthenticationDecisionRequest: PostTokenizationAuthenticationDecisionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostTokenizationAuthenticationDecisionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTokenizationAuthenticationDecision(postTokenizationAuthenticationDecisionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.postTokenizationAuthenticationDecision']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to add a card to Google Wallet via a web application.  This endpoint does not return a payload in response to a request. Instead, a successful call will return a response code only.
         * @summary Create request for Google Wallet web push provisioning
         * @param {string} reqSysId Random pseudo-unique value used for troubleshooting between multiple parties.
         * @param {SendingProvisioningDataToGooglePayBackendRequest} sendingProvisioningDataToGooglePayBackendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendOPCDataToGooglePay(reqSysId: string, sendingProvisioningDataToGooglePayBackendRequest: SendingProvisioningDataToGooglePayBackendRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendOPCDataToGooglePay(reqSysId, sendingProvisioningDataToGooglePayBackendRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.sendOPCDataToGooglePay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update an alias by alias ID.
         * @summary Update alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsUpdateAliasRequest} adsUpdateAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAliasById(aliasId: string, reqSysId: string, adsUpdateAliasRequest: AdsUpdateAliasRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAliasById(aliasId, reqSysId, adsUpdateAliasRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.updateAliasById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update the status of an alias.
         * @summary Update alias status
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {UpdateAliasStatusRequest} updateAliasStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAliasStatus(aliasId: string, reqSysId: string, updateAliasStatusRequest: UpdateAliasStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAliasStatus(aliasId, reqSysId, updateAliasStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.updateAliasStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update a payment credential associated with a card token.
         * @summary Update card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {AdsCardDetailsRequest} adsCardDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCardByCardToken(cardToken: string, reqSysId: string, adsCardDetailsRequest: AdsCardDetailsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCardByCardToken(cardToken, reqSysId, adsCardDetailsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.updateCardByCardToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update cardholder information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Update cardholder information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayUpdateCardholderRequest} visaClickToPayUpdateCardholderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCardHolderInfo(reqSysId: string, visaClickToPayUpdateCardholderRequest: VisaClickToPayUpdateCardholderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisaClickToPayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCardHolderInfo(reqSysId, visaClickToPayUpdateCardholderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.updateCardHolderInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update card information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Update card information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayUpdateCardRequest} visaClickToPayUpdateCardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCardInfo(reqSysId: string, visaClickToPayUpdateCardRequest: VisaClickToPayUpdateCardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VisaClickToPayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCardInfo(reqSysId, visaClickToPayUpdateCardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DigitalWalletsManagementApi.updateCardInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DigitalWalletsManagementApi - factory interface
 */
export const DigitalWalletsManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DigitalWalletsManagementApiFp(configuration)
    return {
        /**
         * Use this endpoint to create additional aliases associated with an existing main alias.
         * @summary Create an additional alias
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsCreateAdditionalAliasesRequest} adsCreateAdditionalAliasesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdditionalAliases(aliasId: string, reqSysId: string, adsCreateAdditionalAliasesRequest: AdsCreateAdditionalAliasesRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdsCreateAdditionalAliasResponse> {
            return localVarFp.createAdditionalAliases(aliasId, reqSysId, adsCreateAdditionalAliasesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create an alias.
         * @summary Create an alias
         * @param {string} reqSysId 
         * @param {AdsCreateAliasRequest} adsCreateAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(reqSysId: string, adsCreateAliasRequest: AdsCreateAliasRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdsCreateAliasResponse> {
            return localVarFp.createAlias(reqSysId, adsCreateAliasRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create a payment credential associated with an alias.
         * @summary Create alias payment credential
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsCardDetailsRequest} adsCardDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCardByAlias(aliasId: string, reqSysId: string, adsCardDetailsRequest: AdsCardDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdsCreateCardDetailsResponse> {
            return localVarFp.createCardByAlias(aliasId, reqSysId, adsCardDetailsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create a new report request.
         * @summary Create a report request
         * @param {string} reqSysId 
         * @param {AdsCreateReportRequest} adsCreateReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReport(reqSysId: string, adsCreateReportRequest: AdsCreateReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateReport200Response> {
            return localVarFp.createReport(reqSysId, adsCreateReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete an additional alias by additional alias ID.
         * @summary Delete an additional alias
         * @param {string} additionalAliasId Unique identifier of the additional alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAdditionalAliasById(additionalAliasId: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAdditionalAliasById(additionalAliasId, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete an alias by alias ID.
         * @summary Delete alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAliasById(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAliasById(aliasId, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete a payment credential associated with a card token.
         * @summary Delete card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardByCardToken(cardToken: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteCardByCardToken(cardToken, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete cardholder information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Delete cardholder information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardHolderInfo(reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<VisaClickToPayResponse> {
            return localVarFp.deleteCardHolderInfo(reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete card information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Delete card information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCardInfo(reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<VisaClickToPayResponse> {
            return localVarFp.deleteCardInfo(reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to enroll a new card for an existing cardholder in Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a card to Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayEnrollCardsRequest} visaClickToPayEnrollCardsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollCard(reqSysId: string, visaClickToPayEnrollCardsRequest: VisaClickToPayEnrollCardsRequest, options?: RawAxiosRequestConfig): AxiosPromise<VisaClickToPayResponse> {
            return localVarFp.enrollCard(reqSysId, visaClickToPayEnrollCardsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to enroll a new cardholder in Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a cardholder to Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayEnrollRequest} visaClickToPayEnrollRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollCardholder(reqSysId: string, visaClickToPayEnrollRequest: VisaClickToPayEnrollRequest, options?: RawAxiosRequestConfig): AxiosPromise<VisaClickToPayResponse> {
            return localVarFp.enrollCardholder(reqSysId, visaClickToPayEnrollRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to add a card to Apple Wallet via a web application.
         * @summary Create request for Apple Wallet web push provisioning
         * @param {string} reqSysId Random pseudo-unique value used for troubleshooting between multiple parties.
         * @param {RequestForApplePayWppJWT} requestForApplePayWppJWT 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateApplePayWPPJWT(reqSysId: string, requestForApplePayWppJWT: RequestForApplePayWppJWT, options?: RawAxiosRequestConfig): AxiosPromise<WebPushProvisioningApplePayJWTResponse> {
            return localVarFp.generateApplePayWPPJWT(reqSysId, requestForApplePayWppJWT, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve an alias by external ID.
         * @summary Retrieve alias by external ID
         * @param {string} reqSysId 
         * @param {AdsGetByExternalIdRequest} adsGetByExternalIdRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasByExternalId(reqSysId: string, adsGetByExternalIdRequest: AdsGetByExternalIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdsGetByExternalIdResponse> {
            return localVarFp.getAliasByExternalId(reqSysId, adsGetByExternalIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve an alias by alias ID.
         * @summary Retrieve alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasById(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdsAliasResponse> {
            return localVarFp.getAliasById(aliasId, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve the internal ID associated with an alias.
         * @summary Retrieve alias internal ID
         * @param {string} reqSysId 
         * @param {GetAliasIdByValueRequest} getAliasIdByValueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasIdByValue(reqSysId: string, getAliasIdByValueRequest: GetAliasIdByValueRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetAliasIdByValue200Response> {
            return localVarFp.getAliasIdByValue(reqSysId, getAliasIdByValueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a payment credential associated with a card token.
         * @summary Retrieve card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardByCardToken(cardToken: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdsCardsResponse> {
            return localVarFp.getCardByCardToken(cardToken, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a list of payment credentials associated with an alias.
         * @summary Retrieve alias payment credentials
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCardsByAlias(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdsCardsResponse> {
            return localVarFp.getCardsByAlias(aliasId, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to check if a provided BIN prefix is eligible for Click to Pay for Mastercard.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Check eligibility for Click to Pay for Mastercard
         * @param {string} binPrefix Prefix of the bank identification number.
         * @param {string} reqSysId 
         * @param {boolean} [includeAsset] Returns a list of image assets for the Click to Pay logo if set to &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicktopayMastercardCheckeligibility(binPrefix: string, reqSysId: string, includeAsset?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ClickToPayCheckEligibilityResponse> {
            return localVarFp.getClicktopayMastercardCheckeligibility(binPrefix, reqSysId, includeAsset, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to return the status of a specific Click to Pay for Mastercard request.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve Click to Pay for Mastercard enrollment status
         * @param {string} token Unique identifier of the Click to Pay request.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClicktopayMastercardStatusToken(token: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<ClickToPayStatusResponse> {
            return localVarFp.getClicktopayMastercardStatusToken(token, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a list of digital wallet tokens.
         * @summary List digital wallet tokens
         * @param {number} [count] Number of digital wallet token resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first digital wallet token resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] Date when the digital wallet token becomes active.
         * @param {string} [endDate] Expiration date of the digital wallet token.
         * @param {string} [panReferenceId] Unique identifier of the digital wallet token primary account number (PAN) within the card network. This value may vary, depending on the digital wallet. For example, the &#x60;pan_reference_id&#x60; may be different in Apple Wallet and Google Wallet for the same digital wallet token.
         * @param {string} [tokenReferenceId] Unique identifier of the digital wallet token within the card network. The &#x60;token_reference_id&#x60; is unique at the card network level.
         * @param {string} [correlationId] Unique value representing a tokenization request (Mastercard only).
         * @param {string} [tokenType] Comma-delimited list of digital wallet token types to display.
         * @param {string} [tokenRequestorName] Name of the token requestor within the card network.  *NOTE:* The list of example values for this field is maintained by the card networks and is subject to change.
         * @param {string} [state] Comma-delimited list of digital wallet token states to display.
         * @param {GetDigitalwallettokensEmbedEnum} [embed] An optional embedded user object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokens(count?: number, startIndex?: number, fields?: string, sortBy?: string, startDate?: string, endDate?: string, panReferenceId?: string, tokenReferenceId?: string, correlationId?: string, tokenType?: string, tokenRequestorName?: string, state?: string, embed?: GetDigitalwallettokensEmbedEnum, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletTokenListResponse> {
            return localVarFp.getDigitalwallettokens(count, startIndex, fields, sortBy, startDate, endDate, panReferenceId, tokenReferenceId, correlationId, tokenType, tokenRequestorName, state, embed, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to return an array of all digital wallet tokens for a particular card.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List digital wallet tokens for card
         * @param {string} cardToken Unique identifier of the card. Used to minimize the need to exchange card details during subsequent calls, and also for troubleshooting.
         * @param {number} [count] Number of digital wallet token resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first digital wallet token resource in the returned array.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensCardCardtoken(cardToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletTokenListResponse> {
            return localVarFp.getDigitalwallettokensCardCardtoken(cardToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a specific digital wallet token.
         * @summary Retrieve digital wallet token
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletToken> {
            return localVarFp.getDigitalwallettokensToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a digital wallet token with the entire primary account number (PAN) displayed. The PAN returned is of the digital wallet token and not of the card. (For security reasons, the PAN is not fully visible on the digital wallet token returned by `GET` `/digitalwallettokens/{token}`.)  [WARNING] Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.
         * @summary Retrieve digital wallet token PAN
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokensTokenShowtokenpan(token: string, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletToken> {
            return localVarFp.getDigitalwallettokensTokenShowtokenpan(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to return an array of all transitions for a particular digital wallet token.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List transitions for digital wallet token
         * @param {string} token Unique identifier of the digital wallet token (DWT).
         * @param {number} [count] Number of digital wallet transitions to retrieve.
         * @param {number} [startIndex] The sort order index of the first digital wallet token in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsDigitalwallettokenToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletTokenTransitionListResponse> {
            return localVarFp.getDigitalwallettokentransitionsDigitalwallettokenToken(token, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a specific digital wallet token transition.  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary Retrieve digital wallet token transition
         * @param {string} token Unique identifier of the digital wallet token (DWT) transition.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDigitalwallettokentransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletTokenTransitionResponse> {
            return localVarFp.getDigitalwallettokentransitionsToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a file by file ID and report ID.
         * @summary Retrieve file by file ID and report ID
         * @param {string} reportId Unique identifier of the report.
         * @param {string} fileId Unique identifier of the file.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileByReportAndFileId(reportId: string, fileId: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AdsReportFileResponse>> {
            return localVarFp.getFileByReportAndFileId(reportId, fileId, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve the status of a report by report ID.
         * @summary Retrieve report status by report ID
         * @param {string} reportId Unique identifier of the report.
         * @param {string} reqSysId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportById(reportId: string, reqSysId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdsGetReportStatusResponse> {
            return localVarFp.getReportById(reportId, reqSysId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to return the status of a Click to Pay for Visa request.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve Click to Pay for Visa request status
         * @param {string} reqSysId 
         * @param {string} requestTraceId Unique identifier of the Visa Click to Pay request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(reqSysId: string, requestTraceId: string, options?: RawAxiosRequestConfig): AxiosPromise<VisaClickToPayStatusResponse> {
            return localVarFp.getStatus(reqSysId, requestTraceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to get user data for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Retrieve user data for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {string} userToken Unique identifier of the cardholder.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserData(reqSysId: string, userToken: string, options?: RawAxiosRequestConfig): AxiosPromise<VisaClickToPayGetUserDataResponse> {
            return localVarFp.getUserData(reqSysId, userToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to enroll a card in Click to Pay for Mastercard.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Enroll a card to Click to Pay for Mastercard
         * @param {string} reqSysId 
         * @param {ClickToPayEnrollRequest} clickToPayEnrollRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postClicktopayMastercardEnroll(reqSysId: string, clickToPayEnrollRequest: ClickToPayEnrollRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClickToPayEnrollResponse> {
            return localVarFp.postClicktopayMastercardEnroll(reqSysId, clickToPayEnrollRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to return card data for use in provisioning a digital wallet token into Google Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Google Wallet
         * @param {DigitalWalletAndroidPayProvisionRequest} [digitalWalletAndroidPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsAndroidpay(digitalWalletAndroidPayProvisionRequest?: DigitalWalletAndroidPayProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletAndroidPayProvisionResponse> {
            return localVarFp.postDigitalwalletprovisionrequestsAndroidpay(digitalWalletAndroidPayProvisionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to return card data for use in provisioning a digital wallet token into Apple Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Apple Wallet
         * @param {DigitalWalletApplePayProvisionRequest} [digitalWalletApplePayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsApplepay(digitalWalletApplePayProvisionRequest?: DigitalWalletApplePayProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletApplePayProvisionResponse> {
            return localVarFp.postDigitalwalletprovisionrequestsApplepay(digitalWalletApplePayProvisionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * [NOTE] This endpoint is limited in availability. For more information, contact your Marqeta representative.  Use this endpoint to return card data for use in provisioning a digital wallet token into Samsung Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for Samsung Wallet
         * @param {DigitalWalletSamsungPayProvisionRequest} [digitalWalletSamsungPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsSamsungpay(digitalWalletSamsungPayProvisionRequest?: DigitalWalletSamsungPayProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletSamsungPayProvisionResponse> {
            return localVarFp.postDigitalwalletprovisionrequestsSamsungpay(digitalWalletSamsungPayProvisionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * [NOTE] This endpoint is limited in availability. For more information, contact your Marqeta representative.  Use this endpoint to return card data for use in provisioning a digital wallet token into an XPay digital wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
         * @summary Create digital wallet token provisioning request for XPay
         * @param {DigitalWalletXPayProvisionRequest} [digitalWalletXPayProvisionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwalletprovisionrequestsXPay(digitalWalletXPayProvisionRequest?: DigitalWalletXPayProvisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletXPayProvisionResponse> {
            return localVarFp.postDigitalwalletprovisionrequestsXPay(digitalWalletXPayProvisionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to transition a digital wallet token from one state to another.
         * @summary Create digital wallet token transition
         * @param {DigitalWalletTokenTransitionRequest} [digitalWalletTokenTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDigitalwallettokentransitions(digitalWalletTokenTransitionRequest?: DigitalWalletTokenTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DigitalWalletTokenTransitionResponse> {
            return localVarFp.postDigitalwallettokentransitions(digitalWalletTokenTransitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to submit a post-tokenization authentication decision from the customer to MQ in a secure card on file scenario.   MQ validates the request, stores it, and forwards the authentication decision to Mastercard MDES in real time.   MQ then returns the MDES response back to the customer synchronously.   This enables issuers to notify MDES of the cardholders authentication outcome following tokenization,   ensuring that the token requestor receives timely and accurate decisioning.
         * @param {PostTokenizationAuthenticationDecisionRequest} postTokenizationAuthenticationDecisionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTokenizationAuthenticationDecision(postTokenizationAuthenticationDecisionRequest: PostTokenizationAuthenticationDecisionRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostTokenizationAuthenticationDecisionResponse> {
            return localVarFp.postTokenizationAuthenticationDecision(postTokenizationAuthenticationDecisionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to add a card to Google Wallet via a web application.  This endpoint does not return a payload in response to a request. Instead, a successful call will return a response code only.
         * @summary Create request for Google Wallet web push provisioning
         * @param {string} reqSysId Random pseudo-unique value used for troubleshooting between multiple parties.
         * @param {SendingProvisioningDataToGooglePayBackendRequest} sendingProvisioningDataToGooglePayBackendRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOPCDataToGooglePay(reqSysId: string, sendingProvisioningDataToGooglePayBackendRequest: SendingProvisioningDataToGooglePayBackendRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendOPCDataToGooglePay(reqSysId, sendingProvisioningDataToGooglePayBackendRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update an alias by alias ID.
         * @summary Update alias by alias ID
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {AdsUpdateAliasRequest} adsUpdateAliasRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAliasById(aliasId: string, reqSysId: string, adsUpdateAliasRequest: AdsUpdateAliasRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAliasById(aliasId, reqSysId, adsUpdateAliasRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update the status of an alias.
         * @summary Update alias status
         * @param {string} aliasId Unique identifier of the Visa Alias.
         * @param {string} reqSysId 
         * @param {UpdateAliasStatusRequest} updateAliasStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAliasStatus(aliasId: string, reqSysId: string, updateAliasStatusRequest: UpdateAliasStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAliasStatus(aliasId, reqSysId, updateAliasStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update a payment credential associated with a card token.
         * @summary Update card token payment credential
         * @param {string} cardToken Unique identifier of the card token.
         * @param {string} reqSysId 
         * @param {AdsCardDetailsRequest} adsCardDetailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCardByCardToken(cardToken: string, reqSysId: string, adsCardDetailsRequest: AdsCardDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateCardByCardToken(cardToken, reqSysId, adsCardDetailsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update cardholder information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Update cardholder information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayUpdateCardholderRequest} visaClickToPayUpdateCardholderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCardHolderInfo(reqSysId: string, visaClickToPayUpdateCardholderRequest: VisaClickToPayUpdateCardholderRequest, options?: RawAxiosRequestConfig): AxiosPromise<VisaClickToPayResponse> {
            return localVarFp.updateCardHolderInfo(reqSysId, visaClickToPayUpdateCardholderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update card information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
         * @summary Update card information for Click to Pay for Visa
         * @param {string} reqSysId 
         * @param {VisaClickToPayUpdateCardRequest} visaClickToPayUpdateCardRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCardInfo(reqSysId: string, visaClickToPayUpdateCardRequest: VisaClickToPayUpdateCardRequest, options?: RawAxiosRequestConfig): AxiosPromise<VisaClickToPayResponse> {
            return localVarFp.updateCardInfo(reqSysId, visaClickToPayUpdateCardRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DigitalWalletsManagementApi - object-oriented interface
 */
export class DigitalWalletsManagementApi extends BaseAPI {
    /**
     * Use this endpoint to create additional aliases associated with an existing main alias.
     * @summary Create an additional alias
     * @param {string} aliasId Unique identifier of the Visa Alias.
     * @param {string} reqSysId 
     * @param {AdsCreateAdditionalAliasesRequest} adsCreateAdditionalAliasesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAdditionalAliases(aliasId: string, reqSysId: string, adsCreateAdditionalAliasesRequest: AdsCreateAdditionalAliasesRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).createAdditionalAliases(aliasId, reqSysId, adsCreateAdditionalAliasesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create an alias.
     * @summary Create an alias
     * @param {string} reqSysId 
     * @param {AdsCreateAliasRequest} adsCreateAliasRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAlias(reqSysId: string, adsCreateAliasRequest: AdsCreateAliasRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).createAlias(reqSysId, adsCreateAliasRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create a payment credential associated with an alias.
     * @summary Create alias payment credential
     * @param {string} aliasId Unique identifier of the Visa Alias.
     * @param {string} reqSysId 
     * @param {AdsCardDetailsRequest} adsCardDetailsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCardByAlias(aliasId: string, reqSysId: string, adsCardDetailsRequest: AdsCardDetailsRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).createCardByAlias(aliasId, reqSysId, adsCardDetailsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create a new report request.
     * @summary Create a report request
     * @param {string} reqSysId 
     * @param {AdsCreateReportRequest} adsCreateReportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createReport(reqSysId: string, adsCreateReportRequest: AdsCreateReportRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).createReport(reqSysId, adsCreateReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete an additional alias by additional alias ID.
     * @summary Delete an additional alias
     * @param {string} additionalAliasId Unique identifier of the additional alias.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAdditionalAliasById(additionalAliasId: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).deleteAdditionalAliasById(additionalAliasId, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete an alias by alias ID.
     * @summary Delete alias by alias ID
     * @param {string} aliasId Unique identifier of the Visa Alias.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteAliasById(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).deleteAliasById(aliasId, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete a payment credential associated with a card token.
     * @summary Delete card token payment credential
     * @param {string} cardToken Unique identifier of the card token.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCardByCardToken(cardToken: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).deleteCardByCardToken(cardToken, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete cardholder information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Delete cardholder information for Click to Pay for Visa
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCardHolderInfo(reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).deleteCardHolderInfo(reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete card information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Delete card information for Click to Pay for Visa
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteCardInfo(reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).deleteCardInfo(reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to enroll a new card for an existing cardholder in Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Enroll a card to Click to Pay for Visa
     * @param {string} reqSysId 
     * @param {VisaClickToPayEnrollCardsRequest} visaClickToPayEnrollCardsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enrollCard(reqSysId: string, visaClickToPayEnrollCardsRequest: VisaClickToPayEnrollCardsRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).enrollCard(reqSysId, visaClickToPayEnrollCardsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to enroll a new cardholder in Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Enroll a cardholder to Click to Pay for Visa
     * @param {string} reqSysId 
     * @param {VisaClickToPayEnrollRequest} visaClickToPayEnrollRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enrollCardholder(reqSysId: string, visaClickToPayEnrollRequest: VisaClickToPayEnrollRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).enrollCardholder(reqSysId, visaClickToPayEnrollRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to add a card to Apple Wallet via a web application.
     * @summary Create request for Apple Wallet web push provisioning
     * @param {string} reqSysId Random pseudo-unique value used for troubleshooting between multiple parties.
     * @param {RequestForApplePayWppJWT} requestForApplePayWppJWT 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateApplePayWPPJWT(reqSysId: string, requestForApplePayWppJWT: RequestForApplePayWppJWT, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).generateApplePayWPPJWT(reqSysId, requestForApplePayWppJWT, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve an alias by external ID.
     * @summary Retrieve alias by external ID
     * @param {string} reqSysId 
     * @param {AdsGetByExternalIdRequest} adsGetByExternalIdRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAliasByExternalId(reqSysId: string, adsGetByExternalIdRequest: AdsGetByExternalIdRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getAliasByExternalId(reqSysId, adsGetByExternalIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve an alias by alias ID.
     * @summary Retrieve alias by alias ID
     * @param {string} aliasId Unique identifier of the Visa Alias.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAliasById(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getAliasById(aliasId, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve the internal ID associated with an alias.
     * @summary Retrieve alias internal ID
     * @param {string} reqSysId 
     * @param {GetAliasIdByValueRequest} getAliasIdByValueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAliasIdByValue(reqSysId: string, getAliasIdByValueRequest: GetAliasIdByValueRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getAliasIdByValue(reqSysId, getAliasIdByValueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a payment credential associated with a card token.
     * @summary Retrieve card token payment credential
     * @param {string} cardToken Unique identifier of the card token.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardByCardToken(cardToken: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getCardByCardToken(cardToken, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a list of payment credentials associated with an alias.
     * @summary Retrieve alias payment credentials
     * @param {string} aliasId Unique identifier of the Visa Alias.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCardsByAlias(aliasId: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getCardsByAlias(aliasId, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to check if a provided BIN prefix is eligible for Click to Pay for Mastercard.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Check eligibility for Click to Pay for Mastercard
     * @param {string} binPrefix Prefix of the bank identification number.
     * @param {string} reqSysId 
     * @param {boolean} [includeAsset] Returns a list of image assets for the Click to Pay logo if set to &#x60;true&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClicktopayMastercardCheckeligibility(binPrefix: string, reqSysId: string, includeAsset?: boolean, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getClicktopayMastercardCheckeligibility(binPrefix, reqSysId, includeAsset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to return the status of a specific Click to Pay for Mastercard request.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Retrieve Click to Pay for Mastercard enrollment status
     * @param {string} token Unique identifier of the Click to Pay request.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClicktopayMastercardStatusToken(token: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getClicktopayMastercardStatusToken(token, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a list of digital wallet tokens.
     * @summary List digital wallet tokens
     * @param {number} [count] Number of digital wallet token resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first digital wallet token resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {string} [startDate] Date when the digital wallet token becomes active.
     * @param {string} [endDate] Expiration date of the digital wallet token.
     * @param {string} [panReferenceId] Unique identifier of the digital wallet token primary account number (PAN) within the card network. This value may vary, depending on the digital wallet. For example, the &#x60;pan_reference_id&#x60; may be different in Apple Wallet and Google Wallet for the same digital wallet token.
     * @param {string} [tokenReferenceId] Unique identifier of the digital wallet token within the card network. The &#x60;token_reference_id&#x60; is unique at the card network level.
     * @param {string} [correlationId] Unique value representing a tokenization request (Mastercard only).
     * @param {string} [tokenType] Comma-delimited list of digital wallet token types to display.
     * @param {string} [tokenRequestorName] Name of the token requestor within the card network.  *NOTE:* The list of example values for this field is maintained by the card networks and is subject to change.
     * @param {string} [state] Comma-delimited list of digital wallet token states to display.
     * @param {GetDigitalwallettokensEmbedEnum} [embed] An optional embedded user object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDigitalwallettokens(count?: number, startIndex?: number, fields?: string, sortBy?: string, startDate?: string, endDate?: string, panReferenceId?: string, tokenReferenceId?: string, correlationId?: string, tokenType?: string, tokenRequestorName?: string, state?: string, embed?: GetDigitalwallettokensEmbedEnum, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getDigitalwallettokens(count, startIndex, fields, sortBy, startDate, endDate, panReferenceId, tokenReferenceId, correlationId, tokenType, tokenRequestorName, state, embed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to return an array of all digital wallet tokens for a particular card.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
     * @summary List digital wallet tokens for card
     * @param {string} cardToken Unique identifier of the card. Used to minimize the need to exchange card details during subsequent calls, and also for troubleshooting.
     * @param {number} [count] Number of digital wallet token resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first digital wallet token resource in the returned array.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDigitalwallettokensCardCardtoken(cardToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getDigitalwallettokensCardCardtoken(cardToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a specific digital wallet token.
     * @summary Retrieve digital wallet token
     * @param {string} token Unique identifier of the digital wallet token (DWT).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDigitalwallettokensToken(token: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getDigitalwallettokensToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a digital wallet token with the entire primary account number (PAN) displayed. The PAN returned is of the digital wallet token and not of the card. (For security reasons, the PAN is not fully visible on the digital wallet token returned by `GET` `/digitalwallettokens/{token}`.)  [WARNING] Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.
     * @summary Retrieve digital wallet token PAN
     * @param {string} token Unique identifier of the digital wallet token (DWT).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDigitalwallettokensTokenShowtokenpan(token: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getDigitalwallettokensTokenShowtokenpan(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to return an array of all transitions for a particular digital wallet token.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
     * @summary List transitions for digital wallet token
     * @param {string} token Unique identifier of the digital wallet token (DWT).
     * @param {number} [count] Number of digital wallet transitions to retrieve.
     * @param {number} [startIndex] The sort order index of the first digital wallet token in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDigitalwallettokentransitionsDigitalwallettokenToken(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getDigitalwallettokentransitionsDigitalwallettokenToken(token, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a specific digital wallet token transition.  This endpoint supports <</core-api/field-filtering, field filtering>>.
     * @summary Retrieve digital wallet token transition
     * @param {string} token Unique identifier of the digital wallet token (DWT) transition.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDigitalwallettokentransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getDigitalwallettokentransitionsToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a file by file ID and report ID.
     * @summary Retrieve file by file ID and report ID
     * @param {string} reportId Unique identifier of the report.
     * @param {string} fileId Unique identifier of the file.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFileByReportAndFileId(reportId: string, fileId: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getFileByReportAndFileId(reportId, fileId, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve the status of a report by report ID.
     * @summary Retrieve report status by report ID
     * @param {string} reportId Unique identifier of the report.
     * @param {string} reqSysId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getReportById(reportId: string, reqSysId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getReportById(reportId, reqSysId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to return the status of a Click to Pay for Visa request.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Retrieve Click to Pay for Visa request status
     * @param {string} reqSysId 
     * @param {string} requestTraceId Unique identifier of the Visa Click to Pay request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatus(reqSysId: string, requestTraceId: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getStatus(reqSysId, requestTraceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to get user data for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Retrieve user data for Click to Pay for Visa
     * @param {string} reqSysId 
     * @param {string} userToken Unique identifier of the cardholder.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserData(reqSysId: string, userToken: string, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).getUserData(reqSysId, userToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to enroll a card in Click to Pay for Mastercard.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Enroll a card to Click to Pay for Mastercard
     * @param {string} reqSysId 
     * @param {ClickToPayEnrollRequest} clickToPayEnrollRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postClicktopayMastercardEnroll(reqSysId: string, clickToPayEnrollRequest: ClickToPayEnrollRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).postClicktopayMastercardEnroll(reqSysId, clickToPayEnrollRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to return card data for use in provisioning a digital wallet token into Google Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
     * @summary Create digital wallet token provisioning request for Google Wallet
     * @param {DigitalWalletAndroidPayProvisionRequest} [digitalWalletAndroidPayProvisionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDigitalwalletprovisionrequestsAndroidpay(digitalWalletAndroidPayProvisionRequest?: DigitalWalletAndroidPayProvisionRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).postDigitalwalletprovisionrequestsAndroidpay(digitalWalletAndroidPayProvisionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to return card data for use in provisioning a digital wallet token into Apple Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
     * @summary Create digital wallet token provisioning request for Apple Wallet
     * @param {DigitalWalletApplePayProvisionRequest} [digitalWalletApplePayProvisionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDigitalwalletprovisionrequestsApplepay(digitalWalletApplePayProvisionRequest?: DigitalWalletApplePayProvisionRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).postDigitalwalletprovisionrequestsApplepay(digitalWalletApplePayProvisionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [NOTE] This endpoint is limited in availability. For more information, contact your Marqeta representative.  Use this endpoint to return card data for use in provisioning a digital wallet token into Samsung Wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
     * @summary Create digital wallet token provisioning request for Samsung Wallet
     * @param {DigitalWalletSamsungPayProvisionRequest} [digitalWalletSamsungPayProvisionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDigitalwalletprovisionrequestsSamsungpay(digitalWalletSamsungPayProvisionRequest?: DigitalWalletSamsungPayProvisionRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).postDigitalwalletprovisionrequestsSamsungpay(digitalWalletSamsungPayProvisionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [NOTE] This endpoint is limited in availability. For more information, contact your Marqeta representative.  Use this endpoint to return card data for use in provisioning a digital wallet token into an XPay digital wallet.  The returned card data is encrypted using the digital wallet provider\'s encryption key, thereby reducing your PCI compliance overhead.
     * @summary Create digital wallet token provisioning request for XPay
     * @param {DigitalWalletXPayProvisionRequest} [digitalWalletXPayProvisionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDigitalwalletprovisionrequestsXPay(digitalWalletXPayProvisionRequest?: DigitalWalletXPayProvisionRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).postDigitalwalletprovisionrequestsXPay(digitalWalletXPayProvisionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to transition a digital wallet token from one state to another.
     * @summary Create digital wallet token transition
     * @param {DigitalWalletTokenTransitionRequest} [digitalWalletTokenTransitionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDigitalwallettokentransitions(digitalWalletTokenTransitionRequest?: DigitalWalletTokenTransitionRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).postDigitalwallettokentransitions(digitalWalletTokenTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to submit a post-tokenization authentication decision from the customer to MQ in a secure card on file scenario.   MQ validates the request, stores it, and forwards the authentication decision to Mastercard MDES in real time.   MQ then returns the MDES response back to the customer synchronously.   This enables issuers to notify MDES of the cardholders authentication outcome following tokenization,   ensuring that the token requestor receives timely and accurate decisioning.
     * @param {PostTokenizationAuthenticationDecisionRequest} postTokenizationAuthenticationDecisionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postTokenizationAuthenticationDecision(postTokenizationAuthenticationDecisionRequest: PostTokenizationAuthenticationDecisionRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).postTokenizationAuthenticationDecision(postTokenizationAuthenticationDecisionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to add a card to Google Wallet via a web application.  This endpoint does not return a payload in response to a request. Instead, a successful call will return a response code only.
     * @summary Create request for Google Wallet web push provisioning
     * @param {string} reqSysId Random pseudo-unique value used for troubleshooting between multiple parties.
     * @param {SendingProvisioningDataToGooglePayBackendRequest} sendingProvisioningDataToGooglePayBackendRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendOPCDataToGooglePay(reqSysId: string, sendingProvisioningDataToGooglePayBackendRequest: SendingProvisioningDataToGooglePayBackendRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).sendOPCDataToGooglePay(reqSysId, sendingProvisioningDataToGooglePayBackendRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update an alias by alias ID.
     * @summary Update alias by alias ID
     * @param {string} aliasId Unique identifier of the Visa Alias.
     * @param {string} reqSysId 
     * @param {AdsUpdateAliasRequest} adsUpdateAliasRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAliasById(aliasId: string, reqSysId: string, adsUpdateAliasRequest: AdsUpdateAliasRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).updateAliasById(aliasId, reqSysId, adsUpdateAliasRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update the status of an alias.
     * @summary Update alias status
     * @param {string} aliasId Unique identifier of the Visa Alias.
     * @param {string} reqSysId 
     * @param {UpdateAliasStatusRequest} updateAliasStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAliasStatus(aliasId: string, reqSysId: string, updateAliasStatusRequest: UpdateAliasStatusRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).updateAliasStatus(aliasId, reqSysId, updateAliasStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update a payment credential associated with a card token.
     * @summary Update card token payment credential
     * @param {string} cardToken Unique identifier of the card token.
     * @param {string} reqSysId 
     * @param {AdsCardDetailsRequest} adsCardDetailsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCardByCardToken(cardToken: string, reqSysId: string, adsCardDetailsRequest: AdsCardDetailsRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).updateCardByCardToken(cardToken, reqSysId, adsCardDetailsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update cardholder information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Update cardholder information for Click to Pay for Visa
     * @param {string} reqSysId 
     * @param {VisaClickToPayUpdateCardholderRequest} visaClickToPayUpdateCardholderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCardHolderInfo(reqSysId: string, visaClickToPayUpdateCardholderRequest: VisaClickToPayUpdateCardholderRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).updateCardHolderInfo(reqSysId, visaClickToPayUpdateCardholderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update card information for Click to Pay for Visa.  For more information about this ecommerce checkout solution, see <</developer-guides/digital-wallets-and-tokenization/#_click_to_pay, Click to Pay>>.
     * @summary Update card information for Click to Pay for Visa
     * @param {string} reqSysId 
     * @param {VisaClickToPayUpdateCardRequest} visaClickToPayUpdateCardRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCardInfo(reqSysId: string, visaClickToPayUpdateCardRequest: VisaClickToPayUpdateCardRequest, options?: RawAxiosRequestConfig) {
        return DigitalWalletsManagementApiFp(this.configuration).updateCardInfo(reqSysId, visaClickToPayUpdateCardRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetDigitalwallettokensEmbedEnum = {
    User: 'user'
} as const;
export type GetDigitalwallettokensEmbedEnum = typeof GetDigitalwallettokensEmbedEnum[keyof typeof GetDigitalwallettokensEmbedEnum];


/**
 * DirectDepositAccountsApi - axios parameter creator
 */
export const DirectDepositAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates new direct deposit account for cardholder.
         * @param {DirectDepositAccountRequest} directDepositAccountRequest Create direct deposit account for cardholder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: async (directDepositAccountRequest: DirectDepositAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directDepositAccountRequest' is not null or undefined
            assertParamExists('createAccount', 'directDepositAccountRequest', directDepositAccountRequest)
            const localVarPath = `/depositaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(directDepositAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates new transition for a direct deposit account.
         * @param {DirectDepositAccountTransitionRequest} directDepositAccountTransitionRequest Create transition for direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransition: async (directDepositAccountTransitionRequest: DirectDepositAccountTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directDepositAccountTransitionRequest' is not null or undefined
            assertParamExists('createTransition', 'directDepositAccountTransitionRequest', directDepositAccountTransitionRequest)
            const localVarPath = `/depositaccounts/transitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(directDepositAccountTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} token Get CDD info for a specific DDA token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCDDInfo: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getCDDInfo', 'token', token)
            const localVarPath = `/depositaccounts/{token}/cdd`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct deposit account.
         * @param {string} token Get specific direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccount: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDirectDepositAccount', 'token', token)
            const localVarPath = `/depositaccounts/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition.
         * @param {string} token Get specific direct deposit account transition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccountTransition: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDirectDepositAccountTransition', 'token', token)
            const localVarPath = `/depositaccounts/transitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} userToken Get direct deposit account transition list for user
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransitionList: async (userToken: string, count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('getTransitionList', 'userToken', userToken)
            const localVarPath = `/depositaccounts/{user_token}/transitions`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all specific direct deposit accounts.
         * @param {string} token Get specific direct deposit account
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {GetUserDirectDepositAccountsStateEnum} [state] Direct deposit account status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDirectDepositAccounts: async (token: string, count?: number, startIndex?: number, sortBy?: string, state?: GetUserDirectDepositAccountsStateEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getUserDirectDepositAccounts', 'token', token)
            const localVarPath = `/depositaccounts/user/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get User for Plain Text Account Number
         * @param {string} accountNumber Get user associated with direct deposit account number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserForDirectDepositAccount: async (accountNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountNumber' is not null or undefined
            assertParamExists('getUserForDirectDepositAccount', 'accountNumber', accountNumber)
            const localVarPath = `/depositaccounts/account/{account_number}/user`
                .replace(`{${"account_number"}}`, encodeURIComponent(String(accountNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update direct deposit account.
         * @param {string} token 
         * @param {DepositAccountUpdateRequest} depositAccountUpdateRequest Update direct deposit account
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        update: async (token: string, depositAccountUpdateRequest: DepositAccountUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('update', 'token', token)
            // verify required parameter 'depositAccountUpdateRequest' is not null or undefined
            assertParamExists('update', 'depositAccountUpdateRequest', depositAccountUpdateRequest)
            const localVarPath = `/depositaccounts/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(depositAccountUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update CDD answers for Direct Deposit Account
         * @param {string} token 
         * @param {string} cddtoken 
         * @param {CustomerDueDiligenceUpdateRequest} customerDueDiligenceUpdateRequest Update CDD answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCDDInfo: async (token: string, cddtoken: string, customerDueDiligenceUpdateRequest: CustomerDueDiligenceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateCDDInfo', 'token', token)
            // verify required parameter 'cddtoken' is not null or undefined
            assertParamExists('updateCDDInfo', 'cddtoken', cddtoken)
            // verify required parameter 'customerDueDiligenceUpdateRequest' is not null or undefined
            assertParamExists('updateCDDInfo', 'customerDueDiligenceUpdateRequest', customerDueDiligenceUpdateRequest)
            const localVarPath = `/depositaccounts/{token}/cdd/{cddtoken}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"cddtoken"}}`, encodeURIComponent(String(cddtoken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(customerDueDiligenceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectDepositAccountsApi - functional programming interface
 */
export const DirectDepositAccountsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DirectDepositAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates new direct deposit account for cardholder.
         * @param {DirectDepositAccountRequest} directDepositAccountRequest Create direct deposit account for cardholder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccount(directDepositAccountRequest: DirectDepositAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccount(directDepositAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.createAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates new transition for a direct deposit account.
         * @param {DirectDepositAccountTransitionRequest} directDepositAccountTransitionRequest Create transition for direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTransition(directDepositAccountTransitionRequest: DirectDepositAccountTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositAccountTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransition(directDepositAccountTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.createTransition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} token Get CDD info for a specific DDA token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCDDInfo(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerDueDiligenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCDDInfo(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.getCDDInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get direct deposit account.
         * @param {string} token Get specific direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectDepositAccount(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectDepositAccount(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.getDirectDepositAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get direct deposit account transition.
         * @param {string} token Get specific direct deposit account transition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectDepositAccountTransition(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositAccountTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectDepositAccountTransition(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.getDirectDepositAccountTransition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} userToken Get direct deposit account transition list for user
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransitionList(userToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositAccountTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransitionList(userToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.getTransitionList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all specific direct deposit accounts.
         * @param {string} token Get specific direct deposit account
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {GetUserDirectDepositAccountsStateEnum} [state] Direct deposit account status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDirectDepositAccounts(token: string, count?: number, startIndex?: number, sortBy?: string, state?: GetUserDirectDepositAccountsStateEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositAccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDirectDepositAccounts(token, count, startIndex, sortBy, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.getUserDirectDepositAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get User for Plain Text Account Number
         * @param {string} accountNumber Get user associated with direct deposit account number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserForDirectDepositAccount(accountNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserForDirectDepositAccount(accountNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.getUserForDirectDepositAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update direct deposit account.
         * @param {string} token 
         * @param {DepositAccountUpdateRequest} depositAccountUpdateRequest Update direct deposit account
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async update(token: string, depositAccountUpdateRequest: DepositAccountUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(token, depositAccountUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update CDD answers for Direct Deposit Account
         * @param {string} token 
         * @param {string} cddtoken 
         * @param {CustomerDueDiligenceUpdateRequest} customerDueDiligenceUpdateRequest Update CDD answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCDDInfo(token: string, cddtoken: string, customerDueDiligenceUpdateRequest: CustomerDueDiligenceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerDueDiligenceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCDDInfo(token, cddtoken, customerDueDiligenceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositAccountsApi.updateCDDInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DirectDepositAccountsApi - factory interface
 */
export const DirectDepositAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DirectDepositAccountsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates new direct deposit account for cardholder.
         * @param {DirectDepositAccountRequest} directDepositAccountRequest Create direct deposit account for cardholder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(directDepositAccountRequest: DirectDepositAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositAccountResponse> {
            return localVarFp.createAccount(directDepositAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates new transition for a direct deposit account.
         * @param {DirectDepositAccountTransitionRequest} directDepositAccountTransitionRequest Create transition for direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransition(directDepositAccountTransitionRequest: DirectDepositAccountTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositAccountTransitionResponse> {
            return localVarFp.createTransition(directDepositAccountTransitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} token Get CDD info for a specific DDA token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCDDInfo(token: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerDueDiligenceResponse> {
            return localVarFp.getCDDInfo(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get direct deposit account.
         * @param {string} token Get specific direct deposit account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccount(token: string, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositAccountResponse> {
            return localVarFp.getDirectDepositAccount(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get direct deposit account transition.
         * @param {string} token Get specific direct deposit account transition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectDepositAccountTransition(token: string, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositAccountTransitionResponse> {
            return localVarFp.getDirectDepositAccountTransition(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get direct deposit account transition list for card holder.
         * @param {string} userToken Get direct deposit account transition list for user
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransitionList(userToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositAccountTransitionResponse> {
            return localVarFp.getTransitionList(userToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all specific direct deposit accounts.
         * @param {string} token Get specific direct deposit account
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {GetUserDirectDepositAccountsStateEnum} [state] Direct deposit account status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDirectDepositAccounts(token: string, count?: number, startIndex?: number, sortBy?: string, state?: GetUserDirectDepositAccountsStateEnum, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositAccountListResponse> {
            return localVarFp.getUserDirectDepositAccounts(token, count, startIndex, sortBy, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get User for Plain Text Account Number
         * @param {string} accountNumber Get user associated with direct deposit account number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserForDirectDepositAccount(accountNumber: string, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositAccountResponse> {
            return localVarFp.getUserForDirectDepositAccount(accountNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update direct deposit account.
         * @param {string} token 
         * @param {DepositAccountUpdateRequest} depositAccountUpdateRequest Update direct deposit account
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        update(token: string, depositAccountUpdateRequest: DepositAccountUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositAccountResponse> {
            return localVarFp.update(token, depositAccountUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update CDD answers for Direct Deposit Account
         * @param {string} token 
         * @param {string} cddtoken 
         * @param {CustomerDueDiligenceUpdateRequest} customerDueDiligenceUpdateRequest Update CDD answers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCDDInfo(token: string, cddtoken: string, customerDueDiligenceUpdateRequest: CustomerDueDiligenceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomerDueDiligenceResponse> {
            return localVarFp.updateCDDInfo(token, cddtoken, customerDueDiligenceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DirectDepositAccountsApi - object-oriented interface
 */
export class DirectDepositAccountsApi extends BaseAPI {
    /**
     * 
     * @summary Creates new direct deposit account for cardholder.
     * @param {DirectDepositAccountRequest} directDepositAccountRequest Create direct deposit account for cardholder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAccount(directDepositAccountRequest: DirectDepositAccountRequest, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).createAccount(directDepositAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates new transition for a direct deposit account.
     * @param {DirectDepositAccountTransitionRequest} directDepositAccountTransitionRequest Create transition for direct deposit account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createTransition(directDepositAccountTransitionRequest: DirectDepositAccountTransitionRequest, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).createTransition(directDepositAccountTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get direct deposit account transition list for card holder.
     * @param {string} token Get CDD info for a specific DDA token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCDDInfo(token: string, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).getCDDInfo(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get direct deposit account.
     * @param {string} token Get specific direct deposit account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDirectDepositAccount(token: string, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).getDirectDepositAccount(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get direct deposit account transition.
     * @param {string} token Get specific direct deposit account transition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDirectDepositAccountTransition(token: string, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).getDirectDepositAccountTransition(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get direct deposit account transition list for card holder.
     * @param {string} userToken Get direct deposit account transition list for user
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransitionList(userToken: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).getTransitionList(userToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all specific direct deposit accounts.
     * @param {string} token Get specific direct deposit account
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {GetUserDirectDepositAccountsStateEnum} [state] Direct deposit account status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserDirectDepositAccounts(token: string, count?: number, startIndex?: number, sortBy?: string, state?: GetUserDirectDepositAccountsStateEnum, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).getUserDirectDepositAccounts(token, count, startIndex, sortBy, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get User for Plain Text Account Number
     * @param {string} accountNumber Get user associated with direct deposit account number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserForDirectDepositAccount(accountNumber: string, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).getUserForDirectDepositAccount(accountNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update direct deposit account.
     * @param {string} token 
     * @param {DepositAccountUpdateRequest} depositAccountUpdateRequest Update direct deposit account
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public update(token: string, depositAccountUpdateRequest: DepositAccountUpdateRequest, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).update(token, depositAccountUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update CDD answers for Direct Deposit Account
     * @param {string} token 
     * @param {string} cddtoken 
     * @param {CustomerDueDiligenceUpdateRequest} customerDueDiligenceUpdateRequest Update CDD answers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateCDDInfo(token: string, cddtoken: string, customerDueDiligenceUpdateRequest: CustomerDueDiligenceUpdateRequest, options?: RawAxiosRequestConfig) {
        return DirectDepositAccountsApiFp(this.configuration).updateCDDInfo(token, cddtoken, customerDueDiligenceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetUserDirectDepositAccountsStateEnum = {
    Active: 'ACTIVE',
    Suspended: 'SUSPENDED',
    Terminated: 'TERMINATED',
    Unsupported: 'UNSUPPORTED',
    Unactivated: 'UNACTIVATED',
    Limited: 'LIMITED'
} as const;
export type GetUserDirectDepositAccountsStateEnum = typeof GetUserDirectDepositAccountsStateEnum[keyof typeof GetUserDirectDepositAccountsStateEnum];


/**
 * DirectDepositsApi - axios parameter creator
 */
export const DirectDepositsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all direct deposits
         * @param {number} [count] Number of direct deposits to retrieve
         * @param {number} [startIndex] Start index
         * @param {boolean} [reversedAfterGracePeriod] Reversed after grace period
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {GetDirectdepositsDirectDepositStateEnum} [directDepositState] Direct deposit state
         * @param {string} [startSettlementDate] Start settlement date
         * @param {string} [endSettlementDate] End settlement date
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdeposits: async (count?: number, startIndex?: number, reversedAfterGracePeriod?: boolean, userToken?: string, businessToken?: string, directDepositState?: GetDirectdepositsDirectDepositStateEnum, startSettlementDate?: string, endSettlementDate?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/directdeposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (reversedAfterGracePeriod !== undefined) {
                localVarQueryParameter['reversed_after_grace_period'] = reversedAfterGracePeriod;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (directDepositState !== undefined) {
                localVarQueryParameter['direct_deposit_state'] = directDepositState;
            }

            if (startSettlementDate !== undefined) {
                localVarQueryParameter['start_settlement_date'] = startSettlementDate;
            }

            if (endSettlementDate !== undefined) {
                localVarQueryParameter['end_settlement_date'] = endSettlementDate;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns an account and routing number which can be used for direct deposit
         * @param {string} userOrBusinessToken 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDirectdepositsAccountsUserorbusinesstoken: async (userOrBusinessToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            assertParamExists('getDirectdepositsAccountsUserorbusinesstoken', 'userOrBusinessToken', userOrBusinessToken)
            const localVarPath = `/directdeposits/accounts/{user_or_business_token}`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a direct deposit entry
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDirectdepositsToken', 'token', token)
            const localVarPath = `/directdeposits/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of direct deposit transitions
         * @param {number} [count] Number of direct deposit transitions to retrieve
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [directDepositToken] Direct deposit token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [states] Comma-delimited list of direct deposit states to display e.g. PENDING | REVERSED | APPLIED | REJECTED 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitions: async (count?: number, userToken?: string, businessToken?: string, directDepositToken?: string, startIndex?: number, sortBy?: string, states?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/directdeposits/transitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (directDepositToken !== undefined) {
                localVarQueryParameter['direct_deposit_token'] = directDepositToken;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a direct deposit transition
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitionsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getDirectdepositsTransitionsToken', 'token', token)
            const localVarPath = `/directdeposits/transitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a direct deposit transition
         * @param {DirectDepositTransitionRequest} [directDepositTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectdepositsTransitions: async (directDepositTransitionRequest?: DirectDepositTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/directdeposits/transitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(directDepositTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific direct deposit account
         * @param {string} userOrBusinessToken User or business token
         * @param {DepositAccountUpdateRequest} depositAccountUpdateRequest Deposit account update request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        putDirectdepositsAccountsUserorbusinesstoken: async (userOrBusinessToken: string, depositAccountUpdateRequest: DepositAccountUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            assertParamExists('putDirectdepositsAccountsUserorbusinesstoken', 'userOrBusinessToken', userOrBusinessToken)
            // verify required parameter 'depositAccountUpdateRequest' is not null or undefined
            assertParamExists('putDirectdepositsAccountsUserorbusinesstoken', 'depositAccountUpdateRequest', depositAccountUpdateRequest)
            const localVarPath = `/directdeposits/accounts/{user_or_business_token}`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(depositAccountUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectDepositsApi - functional programming interface
 */
export const DirectDepositsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DirectDepositsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all direct deposits
         * @param {number} [count] Number of direct deposits to retrieve
         * @param {number} [startIndex] Start index
         * @param {boolean} [reversedAfterGracePeriod] Reversed after grace period
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {GetDirectdepositsDirectDepositStateEnum} [directDepositState] Direct deposit state
         * @param {string} [startSettlementDate] Start settlement date
         * @param {string} [endSettlementDate] End settlement date
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectdeposits(count?: number, startIndex?: number, reversedAfterGracePeriod?: boolean, userToken?: string, businessToken?: string, directDepositState?: GetDirectdepositsDirectDepositStateEnum, startSettlementDate?: string, endSettlementDate?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectdeposits(count, startIndex, reversedAfterGracePeriod, userToken, businessToken, directDepositState, startSettlementDate, endSettlementDate, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositsApi.getDirectdeposits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns an account and routing number which can be used for direct deposit
         * @param {string} userOrBusinessToken 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositsApi.getDirectdepositsAccountsUserorbusinesstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a direct deposit entry
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectdepositsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectdepositsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositsApi.getDirectdepositsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of direct deposit transitions
         * @param {number} [count] Number of direct deposit transitions to retrieve
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [directDepositToken] Direct deposit token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [states] Comma-delimited list of direct deposit states to display e.g. PENDING | REVERSED | APPLIED | REJECTED 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectdepositsTransitions(count?: number, userToken?: string, businessToken?: string, directDepositToken?: string, startIndex?: number, sortBy?: string, states?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositTransitionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectdepositsTransitions(count, userToken, businessToken, directDepositToken, startIndex, sortBy, states, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositsApi.getDirectdepositsTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a direct deposit transition
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDirectdepositsTransitionsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDirectdepositsTransitionsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositsApi.getDirectdepositsTransitionsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a direct deposit transition
         * @param {DirectDepositTransitionRequest} [directDepositTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDirectdepositsTransitions(directDepositTransitionRequest?: DirectDepositTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectDepositTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDirectdepositsTransitions(directDepositTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositsApi.postDirectdepositsTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific direct deposit account
         * @param {string} userOrBusinessToken User or business token
         * @param {DepositAccountUpdateRequest} depositAccountUpdateRequest Deposit account update request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, depositAccountUpdateRequest: DepositAccountUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, depositAccountUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DirectDepositsApi.putDirectdepositsAccountsUserorbusinesstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DirectDepositsApi - factory interface
 */
export const DirectDepositsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DirectDepositsApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all direct deposits
         * @param {number} [count] Number of direct deposits to retrieve
         * @param {number} [startIndex] Start index
         * @param {boolean} [reversedAfterGracePeriod] Reversed after grace period
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {GetDirectdepositsDirectDepositStateEnum} [directDepositState] Direct deposit state
         * @param {string} [startSettlementDate] Start settlement date
         * @param {string} [endSettlementDate] End settlement date
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdeposits(count?: number, startIndex?: number, reversedAfterGracePeriod?: boolean, userToken?: string, businessToken?: string, directDepositState?: GetDirectdepositsDirectDepositStateEnum, startSettlementDate?: string, endSettlementDate?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositListResponse> {
            return localVarFp.getDirectdeposits(count, startIndex, reversedAfterGracePeriod, userToken, businessToken, directDepositState, startSettlementDate, endSettlementDate, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns an account and routing number which can be used for direct deposit
         * @param {string} userOrBusinessToken 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, options?: RawAxiosRequestConfig): AxiosPromise<DepositAccountResponse> {
            return localVarFp.getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a direct deposit entry
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<DepositDepositResponse> {
            return localVarFp.getDirectdepositsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of direct deposit transitions
         * @param {number} [count] Number of direct deposit transitions to retrieve
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [directDepositToken] Direct deposit token
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {string} [states] Comma-delimited list of direct deposit states to display e.g. PENDING | REVERSED | APPLIED | REJECTED 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitions(count?: number, userToken?: string, businessToken?: string, directDepositToken?: string, startIndex?: number, sortBy?: string, states?: string, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositTransitionListResponse> {
            return localVarFp.getDirectdepositsTransitions(count, userToken, businessToken, directDepositToken, startIndex, sortBy, states, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a direct deposit transition
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDirectdepositsTransitionsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositTransitionResponse> {
            return localVarFp.getDirectdepositsTransitionsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a direct deposit transition
         * @param {DirectDepositTransitionRequest} [directDepositTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDirectdepositsTransitions(directDepositTransitionRequest?: DirectDepositTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectDepositTransitionResponse> {
            return localVarFp.postDirectdepositsTransitions(directDepositTransitionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific direct deposit account
         * @param {string} userOrBusinessToken User or business token
         * @param {DepositAccountUpdateRequest} depositAccountUpdateRequest Deposit account update request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, depositAccountUpdateRequest: DepositAccountUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DepositAccountResponse> {
            return localVarFp.putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, depositAccountUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DirectDepositsApi - object-oriented interface
 */
export class DirectDepositsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all direct deposits
     * @param {number} [count] Number of direct deposits to retrieve
     * @param {number} [startIndex] Start index
     * @param {boolean} [reversedAfterGracePeriod] Reversed after grace period
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {GetDirectdepositsDirectDepositStateEnum} [directDepositState] Direct deposit state
     * @param {string} [startSettlementDate] Start settlement date
     * @param {string} [endSettlementDate] End settlement date
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDirectdeposits(count?: number, startIndex?: number, reversedAfterGracePeriod?: boolean, userToken?: string, businessToken?: string, directDepositState?: GetDirectdepositsDirectDepositStateEnum, startSettlementDate?: string, endSettlementDate?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return DirectDepositsApiFp(this.configuration).getDirectdeposits(count, startIndex, reversedAfterGracePeriod, userToken, businessToken, directDepositState, startSettlementDate, endSettlementDate, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns an account and routing number which can be used for direct deposit
     * @param {string} userOrBusinessToken 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, options?: RawAxiosRequestConfig) {
        return DirectDepositsApiFp(this.configuration).getDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a direct deposit entry
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDirectdepositsToken(token: string, options?: RawAxiosRequestConfig) {
        return DirectDepositsApiFp(this.configuration).getDirectdepositsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of direct deposit transitions
     * @param {number} [count] Number of direct deposit transitions to retrieve
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {string} [directDepositToken] Direct deposit token
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {string} [states] Comma-delimited list of direct deposit states to display e.g. PENDING | REVERSED | APPLIED | REJECTED 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDirectdepositsTransitions(count?: number, userToken?: string, businessToken?: string, directDepositToken?: string, startIndex?: number, sortBy?: string, states?: string, options?: RawAxiosRequestConfig) {
        return DirectDepositsApiFp(this.configuration).getDirectdepositsTransitions(count, userToken, businessToken, directDepositToken, startIndex, sortBy, states, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a direct deposit transition
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDirectdepositsTransitionsToken(token: string, options?: RawAxiosRequestConfig) {
        return DirectDepositsApiFp(this.configuration).getDirectdepositsTransitionsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a direct deposit transition
     * @param {DirectDepositTransitionRequest} [directDepositTransitionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postDirectdepositsTransitions(directDepositTransitionRequest?: DirectDepositTransitionRequest, options?: RawAxiosRequestConfig) {
        return DirectDepositsApiFp(this.configuration).postDirectdepositsTransitions(directDepositTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific direct deposit account
     * @param {string} userOrBusinessToken User or business token
     * @param {DepositAccountUpdateRequest} depositAccountUpdateRequest Deposit account update request
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken: string, depositAccountUpdateRequest: DepositAccountUpdateRequest, options?: RawAxiosRequestConfig) {
        return DirectDepositsApiFp(this.configuration).putDirectdepositsAccountsUserorbusinesstoken(userOrBusinessToken, depositAccountUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetDirectdepositsDirectDepositStateEnum = {
    Pending: 'PENDING',
    Applied: 'APPLIED',
    Reversed: 'REVERSED',
    Rejected: 'REJECTED'
} as const;
export type GetDirectdepositsDirectDepositStateEnum = typeof GetDirectdepositsDirectDepositStateEnum[keyof typeof GetDirectdepositsDirectDepositStateEnum];


/**
 * FeeChargesApi - axios parameter creator
 */
export const FeeChargesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a fee charge
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeChargeToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getFeeChargeToken', 'token', token)
            const localVarPath = `/feecharges/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a fee charge
         * @param {FeeTransferRequest} [feeTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeeCharge: async (feeTransferRequest?: FeeTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feecharges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(feeTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a realTime fee charge
         * @param {RealtimeFeeTransferRequest} [realtimeFeeTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRealTimeFeeCharge: async (realtimeFeeTransferRequest?: RealtimeFeeTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feecharges/realtime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(realtimeFeeTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeeChargesApi - functional programming interface
 */
export const FeeChargesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = FeeChargesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a fee charge
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeeChargeToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeeChargeToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeChargesApi.getFeeChargeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a fee charge
         * @param {FeeTransferRequest} [feeTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeeCharge(feeTransferRequest?: FeeTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFeeCharge(feeTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeChargesApi.postFeeCharge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a realTime fee charge
         * @param {RealtimeFeeTransferRequest} [realtimeFeeTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRealTimeFeeCharge(realtimeFeeTransferRequest?: RealtimeFeeTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRealTimeFeeCharge(realtimeFeeTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeChargesApi.postRealTimeFeeCharge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeeChargesApi - factory interface
 */
export const FeeChargesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeeChargesApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a fee charge
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeChargeToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<FeeTransferResponse> {
            return localVarFp.getFeeChargeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a fee charge
         * @param {FeeTransferRequest} [feeTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeeCharge(feeTransferRequest?: FeeTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeeTransferResponse> {
            return localVarFp.postFeeCharge(feeTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a realTime fee charge
         * @param {RealtimeFeeTransferRequest} [realtimeFeeTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRealTimeFeeCharge(realtimeFeeTransferRequest?: RealtimeFeeTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeeTransferResponse> {
            return localVarFp.postRealTimeFeeCharge(realtimeFeeTransferRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeeChargesApi - object-oriented interface
 */
export class FeeChargesApi extends BaseAPI {
    /**
     * 
     * @summary Returns a fee charge
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeeChargeToken(token: string, options?: RawAxiosRequestConfig) {
        return FeeChargesApiFp(this.configuration).getFeeChargeToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a fee charge
     * @param {FeeTransferRequest} [feeTransferRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFeeCharge(feeTransferRequest?: FeeTransferRequest, options?: RawAxiosRequestConfig) {
        return FeeChargesApiFp(this.configuration).postFeeCharge(feeTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a realTime fee charge
     * @param {RealtimeFeeTransferRequest} [realtimeFeeTransferRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRealTimeFeeCharge(realtimeFeeTransferRequest?: RealtimeFeeTransferRequest, options?: RawAxiosRequestConfig) {
        return FeeChargesApiFp(this.configuration).postRealTimeFeeCharge(realtimeFeeTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeeRefundsApi - axios parameter creator
 */
export const FeeRefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a fee refund
         * @param {FeeRefundRequest} [feeRefundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeeRefunds: async (feeRefundRequest?: FeeRefundRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feerefunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(feeRefundRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeeRefundsApi - functional programming interface
 */
export const FeeRefundsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = FeeRefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a fee refund
         * @param {FeeRefundRequest} [feeRefundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFeeRefunds(feeRefundRequest?: FeeRefundRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeRefundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFeeRefunds(feeRefundRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeeRefundsApi.postFeeRefunds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeeRefundsApi - factory interface
 */
export const FeeRefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeeRefundsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a fee refund
         * @param {FeeRefundRequest} [feeRefundRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeeRefunds(feeRefundRequest?: FeeRefundRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeeRefundResponse> {
            return localVarFp.postFeeRefunds(feeRefundRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeeRefundsApi - object-oriented interface
 */
export class FeeRefundsApi extends BaseAPI {
    /**
     * 
     * @summary Creates a fee refund
     * @param {FeeRefundRequest} [feeRefundRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFeeRefunds(feeRefundRequest?: FeeRefundRequest, options?: RawAxiosRequestConfig) {
        return FeeRefundsApiFp(this.configuration).postFeeRefunds(feeRefundRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeesApi - axios parameter creator
 */
export const FeesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a fee for an existing credit account.
         * @summary Create fee for an account
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a fee.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountFeeReq} accountFeeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFee: async (accountToken: string, accountFeeReq: AccountFeeReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createFee', 'accountToken', accountToken)
            // verify required parameter 'accountFeeReq' is not null or undefined
            assertParamExists('createFee', 'accountFeeReq', accountFeeReq)
            const localVarPath = `/accounts/{account_token}/fees`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(accountFeeReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all fees
         * @param {number} [count] Number of fees to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFees: async (count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of fees for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List account fees
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve fees.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account fee resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeesByAccount: async (accountToken: string, count?: number, startIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getFeesByAccount', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/fees`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific fee
         * @param {string} token Fee token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeesToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getFeesToken', 'token', token)
            const localVarPath = `/fees/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a fee
         * @param {FeeRequest} [feeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFees: async (feeRequest?: FeeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(feeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific fee
         * @param {string} token Fee token
         * @param {FeeUpdateRequest} [feeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeesToken: async (token: string, feeUpdateRequest?: FeeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putFeesToken', 'token', token)
            const localVarPath = `/fees/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(feeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a fee for a credit account.
         * @summary Retrieve account fee
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the fee.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} feeToken Unique identifier of the fee to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/fees&#x60; to retrieve existing account fee tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFee: async (accountToken: string, feeToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveFee', 'accountToken', accountToken)
            // verify required parameter 'feeToken' is not null or undefined
            assertParamExists('retrieveFee', 'feeToken', feeToken)
            const localVarPath = `/accounts/{account_token}/fees/{fee_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"fee_token"}}`, encodeURIComponent(String(feeToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeesApi - functional programming interface
 */
export const FeesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = FeesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a fee for an existing credit account.
         * @summary Create fee for an account
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a fee.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountFeeReq} accountFeeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFee(accountToken: string, accountFeeReq: AccountFeeReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFee(accountToken, accountFeeReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeesApi.createFee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all fees
         * @param {number} [count] Number of fees to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFees(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFees(count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeesApi.getFees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of fees for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List account fees
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve fees.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account fee resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeesByAccount(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountFeePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeesByAccount(accountToken, count, startIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeesApi.getFeesByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific fee
         * @param {string} token Fee token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeesToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeesToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeesApi.getFeesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a fee
         * @param {FeeRequest} [feeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFees(feeRequest?: FeeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFees(feeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeesApi.postFees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific fee
         * @param {string} token Fee token
         * @param {FeeUpdateRequest} [feeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFeesToken(token: string, feeUpdateRequest?: FeeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFeesToken(token, feeUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeesApi.putFeesToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a fee for a credit account.
         * @summary Retrieve account fee
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the fee.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} feeToken Unique identifier of the fee to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/fees&#x60; to retrieve existing account fee tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFee(accountToken: string, feeToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFee(accountToken, feeToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeesApi.retrieveFee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeesApi - factory interface
 */
export const FeesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeesApiFp(configuration)
    return {
        /**
         * Create a fee for an existing credit account.
         * @summary Create fee for an account
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a fee.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {AccountFeeReq} accountFeeReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFee(accountToken: string, accountFeeReq: AccountFeeReq, options?: RawAxiosRequestConfig): AxiosPromise<AccountFeeResponse> {
            return localVarFp.createFee(accountToken, accountFeeReq, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all fees
         * @param {number} [count] Number of fees to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFees(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<FeeListResponse> {
            return localVarFp.getFees(count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of fees for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
         * @summary List account fees
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve fees.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of account fee resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeesByAccount(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<AccountFeePage> {
            return localVarFp.getFeesByAccount(accountToken, count, startIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific fee
         * @param {string} token Fee token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeesToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<FeeResponse> {
            return localVarFp.getFeesToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a fee
         * @param {FeeRequest} [feeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFees(feeRequest?: FeeRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeeResponse> {
            return localVarFp.postFees(feeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific fee
         * @param {string} token Fee token
         * @param {FeeUpdateRequest} [feeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFeesToken(token: string, feeUpdateRequest?: FeeUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<FeeResponse> {
            return localVarFp.putFeesToken(token, feeUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a fee for a credit account.
         * @summary Retrieve account fee
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the fee.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} feeToken Unique identifier of the fee to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/fees&#x60; to retrieve existing account fee tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFee(accountToken: string, feeToken: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountFeeResponse> {
            return localVarFp.retrieveFee(accountToken, feeToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeesApi - object-oriented interface
 */
export class FeesApi extends BaseAPI {
    /**
     * Create a fee for an existing credit account.
     * @summary Create fee for an account
     * @param {string} accountToken Unique identifier of the credit account for which you want to create a fee.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {AccountFeeReq} accountFeeReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFee(accountToken: string, accountFeeReq: AccountFeeReq, options?: RawAxiosRequestConfig) {
        return FeesApiFp(this.configuration).createFee(accountToken, accountFeeReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all fees
     * @param {number} [count] Number of fees to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFees(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return FeesApiFp(this.configuration).getFees(count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of fees for a credit account.  This endpoint supports <</core-api/sorting-and-pagination, pagination>>.
     * @summary List account fees
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve fees.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {number} [count] Number of account fee resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeesByAccount(accountToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig) {
        return FeesApiFp(this.configuration).getFeesByAccount(accountToken, count, startIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific fee
     * @param {string} token Fee token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeesToken(token: string, options?: RawAxiosRequestConfig) {
        return FeesApiFp(this.configuration).getFeesToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a fee
     * @param {FeeRequest} [feeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFees(feeRequest?: FeeRequest, options?: RawAxiosRequestConfig) {
        return FeesApiFp(this.configuration).postFees(feeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific fee
     * @param {string} token Fee token
     * @param {FeeUpdateRequest} [feeUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFeesToken(token: string, feeUpdateRequest?: FeeUpdateRequest, options?: RawAxiosRequestConfig) {
        return FeesApiFp(this.configuration).putFeesToken(token, feeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a fee for a credit account.
     * @summary Retrieve account fee
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the fee.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} feeToken Unique identifier of the fee to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/fees&#x60; to retrieve existing account fee tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveFee(accountToken: string, feeToken: string, options?: RawAxiosRequestConfig) {
        return FeesApiFp(this.configuration).retrieveFee(accountToken, feeToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FundingSourcesApi - axios parameter creator
 */
export const FundingSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves a linked funding source balance from a partner
         * @param {string} fundingSourceToken Funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchPartnerLinkedFundingSourceBalance: async (fundingSourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            assertParamExists('getAchPartnerLinkedFundingSourceBalance', 'fundingSourceToken', fundingSourceToken)
            const localVarPath = `/fundingsources/ach/partner/{funding_source_token}/balance`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of Program ACH funding sources
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma delimited list of fields to return (e.g. field_1,field_2,..)
         * @param {string} [sortBy] Sort order
         * @param {boolean} [active] Returns programs with this active state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllACHFundingSources: async (count?: number, startIndex?: number, fields?: string, sortBy?: string, active?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundingsources/program/ach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a user ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetoken: async (fundingSourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            assertParamExists('getFundingsourcesAchFundingsourcetoken', 'fundingSourceToken', fundingSourceToken)
            const localVarPath = `/fundingsources/ach/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the dollar amounts used to verify the ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetokenVerificationamounts: async (fundingSourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            assertParamExists('getFundingsourcesAchFundingsourcetokenVerificationamounts', 'fundingSourceToken', fundingSourceToken)
            const localVarPath = `/fundingsources/ach/{funding_source_token}/verificationamounts`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all addresses for a business
         * @param {string} businessToken Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesBusinessBusinesstoken: async (businessToken: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessToken' is not null or undefined
            assertParamExists('getFundingsourcesAddressesBusinessBusinesstoken', 'businessToken', businessToken)
            const localVarPath = `/fundingsources/addresses/business/{business_token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a user address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesFundingsourceaddresstoken: async (fundingSourceAddressToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceAddressToken' is not null or undefined
            assertParamExists('getFundingsourcesAddressesFundingsourceaddresstoken', 'fundingSourceAddressToken', fundingSourceAddressToken)
            const localVarPath = `/fundingsources/addresses/{funding_source_address_token}`
                .replace(`{${"funding_source_address_token"}}`, encodeURIComponent(String(fundingSourceAddressToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all addresses for a user
         * @param {string} userToken User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesUserUsertoken: async (userToken: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('getFundingsourcesAddressesUserUsertoken', 'userToken', userToken)
            const localVarPath = `/fundingsources/addresses/user/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all funding sources for a business
         * @param {string} businessToken Business token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesBusinessBusinesstoken: async (businessToken: string, type?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessToken' is not null or undefined
            assertParamExists('getFundingsourcesBusinessBusinesstoken', 'businessToken', businessToken)
            const localVarPath = `/fundingsources/business/{business_token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific payment card
         * @param {string} fundingSourceToken Funding token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesPaymentcardFundingsourcetoken: async (fundingSourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            assertParamExists('getFundingsourcesPaymentcardFundingsourcetoken', 'fundingSourceToken', fundingSourceToken)
            const localVarPath = `/fundingsources/paymentcard/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific program funding source
         * @param {string} token Program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getFundingsourcesProgramToken', 'token', token)
            const localVarPath = `/fundingsources/program/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramgatewayToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getFundingsourcesProgramgatewayToken', 'token', token)
            const localVarPath = `/fundingsources/programgateway/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all funding sources for a user
         * @param {string} userToken User token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesUserUsertoken: async (userToken: string, type?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('getFundingsourcesUserUsertoken', 'userToken', userToken)
            const localVarPath = `/fundingsources/user/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source
         * @param {AchModel} [achModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAch: async (achModel?: AchModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundingsources/ach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(achModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source through a partner
         * @param {AchPartnerRequestModel} [achPartnerRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAchPartner: async (achPartnerRequestModel?: AchPartnerRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundingsources/ach/partner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(achPartnerRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an account holder address for a funding source
         * @param {CardHolderAddressModel} [cardHolderAddressModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAddresses: async (cardHolderAddressModel?: CardHolderAddressModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundingsources/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardHolderAddressModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers a payment card funding source
         * @param {TokenRequest} [tokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesPaymentcard: async (tokenRequest?: TokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundingsources/paymentcard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a program funding source
         * @param {ProgramFundingSourceRequest} [programFundingSourceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgram: async (programFundingSourceRequest?: ProgramFundingSourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundingsources/program`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(programFundingSourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Registers an ACH funding source for a program
         * @param {BaseAchRequestModel} [baseAchRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramAch: async (baseAchRequestModel?: BaseAchRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundingsources/program/ach`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(baseAchRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a gateway program funding source
         * @param {GatewayProgramFundingSourceRequest} [gatewayProgramFundingSourceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramgateway: async (gatewayProgramFundingSourceRequest?: GatewayProgramFundingSourceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fundingsources/programgateway`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(gatewayProgramFundingSourceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verifies a bank account as a funding source
         * @param {string} fundingSourceToken 
         * @param {AchVerificationModel} [achVerificationModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAchFundingsourcetoken: async (fundingSourceToken: string, achVerificationModel?: AchVerificationModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            assertParamExists('putFundingsourcesAchFundingsourcetoken', 'fundingSourceToken', fundingSourceToken)
            const localVarPath = `/fundingsources/ach/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(achVerificationModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the account holder address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {CardHolderAddressUpdateModel} [cardHolderAddressUpdateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAddressesFundingsourceaddresstoken: async (fundingSourceAddressToken: string, cardHolderAddressUpdateModel?: CardHolderAddressUpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceAddressToken' is not null or undefined
            assertParamExists('putFundingsourcesAddressesFundingsourceaddresstoken', 'fundingSourceAddressToken', fundingSourceAddressToken)
            const localVarPath = `/fundingsources/addresses/{funding_source_address_token}`
                .replace(`{${"funding_source_address_token"}}`, encodeURIComponent(String(fundingSourceAddressToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardHolderAddressUpdateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific payment card 
         * @param {string} fundingSourceToken Funding account token
         * @param {TokenUpdateRequest} tokenUpdateRequest Payment card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetoken: async (fundingSourceToken: string, tokenUpdateRequest: TokenUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            assertParamExists('putFundingsourcesFundingsourcetoken', 'fundingSourceToken', fundingSourceToken)
            // verify required parameter 'tokenUpdateRequest' is not null or undefined
            assertParamExists('putFundingsourcesFundingsourcetoken', 'tokenUpdateRequest', tokenUpdateRequest)
            const localVarPath = `/fundingsources/paymentcard/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(tokenUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Configures a default funding source
         * @param {string} fundingSourceToken Funding account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetokenDefault: async (fundingSourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            assertParamExists('putFundingsourcesFundingsourcetokenDefault', 'fundingSourceToken', fundingSourceToken)
            const localVarPath = `/fundingsources/{funding_source_token}/default`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific program funding source
         * @param {string} token Program funding source token
         * @param {ProgramFundingSourceUpdateRequest} [programFundingSourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramToken: async (token: string, programFundingSourceUpdateRequest?: ProgramFundingSourceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putFundingsourcesProgramToken', 'token', token)
            const localVarPath = `/fundingsources/program/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(programFundingSourceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source Custom headers
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramCustomHeaderUpdateRequest} [gatewayProgramCustomHeaderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayCustomHeaderToken: async (token: string, gatewayProgramCustomHeaderUpdateRequest?: GatewayProgramCustomHeaderUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putFundingsourcesProgramgatewayCustomHeaderToken', 'token', token)
            const localVarPath = `/fundingsources/programgateway/customheaders/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(gatewayProgramCustomHeaderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramFundingSourceUpdateRequest} [gatewayProgramFundingSourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayToken: async (token: string, gatewayProgramFundingSourceUpdateRequest?: GatewayProgramFundingSourceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putFundingsourcesProgramgatewayToken', 'token', token)
            const localVarPath = `/fundingsources/programgateway/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(gatewayProgramFundingSourceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundingSourcesApi - functional programming interface
 */
export const FundingSourcesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = FundingSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieves a linked funding source balance from a partner
         * @param {string} fundingSourceToken Funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAchPartnerLinkedFundingSourceBalance(fundingSourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LinkedAccountBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAchPartnerLinkedFundingSourceBalance(fundingSourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getAchPartnerLinkedFundingSourceBalance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of Program ACH funding sources
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma delimited list of fields to return (e.g. field_1,field_2,..)
         * @param {string} [sortBy] Sort order
         * @param {boolean} [active] Returns programs with this active state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllACHFundingSources(count?: number, startIndex?: number, fields?: string, sortBy?: string, active?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ACHListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllACHFundingSources(count, startIndex, fields, sortBy, active, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getAllACHFundingSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a user ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesAchFundingsourcetoken(fundingSourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesAchFundingsourcetoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns the dollar amounts used to verify the ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchVerificationModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesAchFundingsourcetokenVerificationamounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all addresses for a business
         * @param {string} businessToken Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesAddressesBusinessBusinesstoken(businessToken: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderAddressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesAddressesBusinessBusinesstoken(businessToken, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesAddressesBusinessBusinesstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a user address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesAddressesFundingsourceaddresstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all addresses for a user
         * @param {string} userToken User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesAddressesUserUsertoken(userToken: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderAddressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesAddressesUserUsertoken(userToken, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesAddressesUserUsertoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all funding sources for a business
         * @param {string} businessToken Business token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesBusinessBusinesstoken(businessToken: string, type?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundingAccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesBusinessBusinesstoken(businessToken, type, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesBusinessBusinesstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific payment card
         * @param {string} fundingSourceToken Funding token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCardResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesPaymentcardFundingsourcetoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific program funding source
         * @param {string} token Program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesProgramToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramFundingSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesProgramToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesProgramToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesProgramgatewayToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayProgramFundingSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesProgramgatewayToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesProgramgatewayToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all funding sources for a user
         * @param {string} userToken User token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingsourcesUserUsertoken(userToken: string, type?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FundingAccountListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingsourcesUserUsertoken(userToken, type, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.getFundingsourcesUserUsertoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Registers an ACH funding source
         * @param {AchModel} [achModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFundingsourcesAch(achModel?: AchModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFundingsourcesAch(achModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.postFundingsourcesAch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Registers an ACH funding source through a partner
         * @param {AchPartnerRequestModel} [achPartnerRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFundingsourcesAchPartner(achPartnerRequestModel?: AchPartnerRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFundingsourcesAchPartner(achPartnerRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.postFundingsourcesAchPartner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an account holder address for a funding source
         * @param {CardHolderAddressModel} [cardHolderAddressModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFundingsourcesAddresses(cardHolderAddressModel?: CardHolderAddressModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFundingsourcesAddresses(cardHolderAddressModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.postFundingsourcesAddresses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Registers a payment card funding source
         * @param {TokenRequest} [tokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFundingsourcesPaymentcard(tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCardResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFundingsourcesPaymentcard(tokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.postFundingsourcesPaymentcard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a program funding source
         * @param {ProgramFundingSourceRequest} [programFundingSourceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFundingsourcesProgram(programFundingSourceRequest?: ProgramFundingSourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramFundingSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFundingsourcesProgram(programFundingSourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.postFundingsourcesProgram']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Registers an ACH funding source for a program
         * @param {BaseAchRequestModel} [baseAchRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFundingsourcesProgramAch(baseAchRequestModel?: BaseAchRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseAchResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFundingsourcesProgramAch(baseAchRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.postFundingsourcesProgramAch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a gateway program funding source
         * @param {GatewayProgramFundingSourceRequest} [gatewayProgramFundingSourceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFundingsourcesProgramgateway(gatewayProgramFundingSourceRequest?: GatewayProgramFundingSourceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayProgramFundingSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFundingsourcesProgramgateway(gatewayProgramFundingSourceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.postFundingsourcesProgramgateway']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verifies a bank account as a funding source
         * @param {string} fundingSourceToken 
         * @param {AchVerificationModel} [achVerificationModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, achVerificationModel?: AchVerificationModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AchResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFundingsourcesAchFundingsourcetoken(fundingSourceToken, achVerificationModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.putFundingsourcesAchFundingsourcetoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates the account holder address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {CardHolderAddressUpdateModel} [cardHolderAddressUpdateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, cardHolderAddressUpdateModel?: CardHolderAddressUpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, cardHolderAddressUpdateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.putFundingsourcesAddressesFundingsourceaddresstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific payment card 
         * @param {string} fundingSourceToken Funding account token
         * @param {TokenUpdateRequest} tokenUpdateRequest Payment card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFundingsourcesFundingsourcetoken(fundingSourceToken: string, tokenUpdateRequest: TokenUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCardResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFundingsourcesFundingsourcetoken(fundingSourceToken, tokenUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.putFundingsourcesFundingsourcetoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Configures a default funding source
         * @param {string} fundingSourceToken Funding account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFundingsourcesFundingsourcetokenDefault(fundingSourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentCardResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFundingsourcesFundingsourcetokenDefault(fundingSourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.putFundingsourcesFundingsourcetokenDefault']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific program funding source
         * @param {string} token Program funding source token
         * @param {ProgramFundingSourceUpdateRequest} [programFundingSourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFundingsourcesProgramToken(token: string, programFundingSourceUpdateRequest?: ProgramFundingSourceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramFundingSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFundingsourcesProgramToken(token, programFundingSourceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.putFundingsourcesProgramToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source Custom headers
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramCustomHeaderUpdateRequest} [gatewayProgramCustomHeaderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFundingsourcesProgramgatewayCustomHeaderToken(token: string, gatewayProgramCustomHeaderUpdateRequest?: GatewayProgramCustomHeaderUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayProgramFundingSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFundingsourcesProgramgatewayCustomHeaderToken(token, gatewayProgramCustomHeaderUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.putFundingsourcesProgramgatewayCustomHeaderToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramFundingSourceUpdateRequest} [gatewayProgramFundingSourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFundingsourcesProgramgatewayToken(token: string, gatewayProgramFundingSourceUpdateRequest?: GatewayProgramFundingSourceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayProgramFundingSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFundingsourcesProgramgatewayToken(token, gatewayProgramFundingSourceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FundingSourcesApi.putFundingsourcesProgramgatewayToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FundingSourcesApi - factory interface
 */
export const FundingSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FundingSourcesApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieves a linked funding source balance from a partner
         * @param {string} fundingSourceToken Funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAchPartnerLinkedFundingSourceBalance(fundingSourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<LinkedAccountBalanceResponse> {
            return localVarFp.getAchPartnerLinkedFundingSourceBalance(fundingSourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of Program ACH funding sources
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [fields] Comma delimited list of fields to return (e.g. field_1,field_2,..)
         * @param {string} [sortBy] Sort order
         * @param {boolean} [active] Returns programs with this active state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllACHFundingSources(count?: number, startIndex?: number, fields?: string, sortBy?: string, active?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ACHListResponse> {
            return localVarFp.getAllACHFundingSources(count, startIndex, fields, sortBy, active, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a user ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<AchResponseModel> {
            return localVarFp.getFundingsourcesAchFundingsourcetoken(fundingSourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the dollar amounts used to verify the ACH account
         * @param {string} fundingSourceToken Funding account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<AchVerificationModel> {
            return localVarFp.getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all addresses for a business
         * @param {string} businessToken Business token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesBusinessBusinesstoken(businessToken: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardholderAddressListResponse> {
            return localVarFp.getFundingsourcesAddressesBusinessBusinesstoken(businessToken, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a user address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, options?: RawAxiosRequestConfig): AxiosPromise<CardholderAddressResponse> {
            return localVarFp.getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all addresses for a user
         * @param {string} userToken User token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesAddressesUserUsertoken(userToken: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardholderAddressListResponse> {
            return localVarFp.getFundingsourcesAddressesUserUsertoken(userToken, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all funding sources for a business
         * @param {string} businessToken Business token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesBusinessBusinesstoken(businessToken: string, type?: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<FundingAccountListResponse> {
            return localVarFp.getFundingsourcesBusinessBusinesstoken(businessToken, type, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific payment card
         * @param {string} fundingSourceToken Funding token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCardResponseModel> {
            return localVarFp.getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific program funding source
         * @param {string} token Program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramFundingSourceResponse> {
            return localVarFp.getFundingsourcesProgramToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesProgramgatewayToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<GatewayProgramFundingSourceResponse> {
            return localVarFp.getFundingsourcesProgramgatewayToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all funding sources for a user
         * @param {string} userToken User token
         * @param {string} [type] Type, such as a payment card or ACH
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingsourcesUserUsertoken(userToken: string, type?: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<FundingAccountListResponse> {
            return localVarFp.getFundingsourcesUserUsertoken(userToken, type, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Registers an ACH funding source
         * @param {AchModel} [achModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAch(achModel?: AchModel, options?: RawAxiosRequestConfig): AxiosPromise<AchResponseModel> {
            return localVarFp.postFundingsourcesAch(achModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Registers an ACH funding source through a partner
         * @param {AchPartnerRequestModel} [achPartnerRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAchPartner(achPartnerRequestModel?: AchPartnerRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<AchResponseModel> {
            return localVarFp.postFundingsourcesAchPartner(achPartnerRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an account holder address for a funding source
         * @param {CardHolderAddressModel} [cardHolderAddressModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesAddresses(cardHolderAddressModel?: CardHolderAddressModel, options?: RawAxiosRequestConfig): AxiosPromise<CardholderAddressResponse> {
            return localVarFp.postFundingsourcesAddresses(cardHolderAddressModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Registers a payment card funding source
         * @param {TokenRequest} [tokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesPaymentcard(tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCardResponseModel> {
            return localVarFp.postFundingsourcesPaymentcard(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a program funding source
         * @param {ProgramFundingSourceRequest} [programFundingSourceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgram(programFundingSourceRequest?: ProgramFundingSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProgramFundingSourceResponse> {
            return localVarFp.postFundingsourcesProgram(programFundingSourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Registers an ACH funding source for a program
         * @param {BaseAchRequestModel} [baseAchRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramAch(baseAchRequestModel?: BaseAchRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<BaseAchResponseModel> {
            return localVarFp.postFundingsourcesProgramAch(baseAchRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a gateway program funding source
         * @param {GatewayProgramFundingSourceRequest} [gatewayProgramFundingSourceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFundingsourcesProgramgateway(gatewayProgramFundingSourceRequest?: GatewayProgramFundingSourceRequest, options?: RawAxiosRequestConfig): AxiosPromise<GatewayProgramFundingSourceResponse> {
            return localVarFp.postFundingsourcesProgramgateway(gatewayProgramFundingSourceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verifies a bank account as a funding source
         * @param {string} fundingSourceToken 
         * @param {AchVerificationModel} [achVerificationModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, achVerificationModel?: AchVerificationModel, options?: RawAxiosRequestConfig): AxiosPromise<AchResponseModel> {
            return localVarFp.putFundingsourcesAchFundingsourcetoken(fundingSourceToken, achVerificationModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates the account holder address for a funding source
         * @param {string} fundingSourceAddressToken Funding source address token
         * @param {CardHolderAddressUpdateModel} [cardHolderAddressUpdateModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, cardHolderAddressUpdateModel?: CardHolderAddressUpdateModel, options?: RawAxiosRequestConfig): AxiosPromise<CardholderAddressResponse> {
            return localVarFp.putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, cardHolderAddressUpdateModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific payment card 
         * @param {string} fundingSourceToken Funding account token
         * @param {TokenUpdateRequest} tokenUpdateRequest Payment card
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetoken(fundingSourceToken: string, tokenUpdateRequest: TokenUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCardResponseModel> {
            return localVarFp.putFundingsourcesFundingsourcetoken(fundingSourceToken, tokenUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Configures a default funding source
         * @param {string} fundingSourceToken Funding account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesFundingsourcetokenDefault(fundingSourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentCardResponseModel> {
            return localVarFp.putFundingsourcesFundingsourcetokenDefault(fundingSourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific program funding source
         * @param {string} token Program funding source token
         * @param {ProgramFundingSourceUpdateRequest} [programFundingSourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramToken(token: string, programFundingSourceUpdateRequest?: ProgramFundingSourceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProgramFundingSourceResponse> {
            return localVarFp.putFundingsourcesProgramToken(token, programFundingSourceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source Custom headers
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramCustomHeaderUpdateRequest} [gatewayProgramCustomHeaderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayCustomHeaderToken(token: string, gatewayProgramCustomHeaderUpdateRequest?: GatewayProgramCustomHeaderUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GatewayProgramFundingSourceResponse> {
            return localVarFp.putFundingsourcesProgramgatewayCustomHeaderToken(token, gatewayProgramCustomHeaderUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific gateway program funding source
         * @param {string} token Gateway program funding source token
         * @param {GatewayProgramFundingSourceUpdateRequest} [gatewayProgramFundingSourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFundingsourcesProgramgatewayToken(token: string, gatewayProgramFundingSourceUpdateRequest?: GatewayProgramFundingSourceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GatewayProgramFundingSourceResponse> {
            return localVarFp.putFundingsourcesProgramgatewayToken(token, gatewayProgramFundingSourceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FundingSourcesApi - object-oriented interface
 */
export class FundingSourcesApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves a linked funding source balance from a partner
     * @param {string} fundingSourceToken Funding source token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAchPartnerLinkedFundingSourceBalance(fundingSourceToken: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getAchPartnerLinkedFundingSourceBalance(fundingSourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of Program ACH funding sources
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [fields] Comma delimited list of fields to return (e.g. field_1,field_2,..)
     * @param {string} [sortBy] Sort order
     * @param {boolean} [active] Returns programs with this active state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllACHFundingSources(count?: number, startIndex?: number, fields?: string, sortBy?: string, active?: boolean, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getAllACHFundingSources(count, startIndex, fields, sortBy, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a user ACH account
     * @param {string} fundingSourceToken Funding account token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAchFundingsourcetoken(fundingSourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the dollar amounts used to verify the ACH account
     * @param {string} fundingSourceToken Funding account token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAchFundingsourcetokenVerificationamounts(fundingSourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all addresses for a business
     * @param {string} businessToken Business token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesAddressesBusinessBusinesstoken(businessToken: string, fields?: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAddressesBusinessBusinesstoken(businessToken, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a user address for a funding source
     * @param {string} fundingSourceAddressToken Funding source address token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all addresses for a user
     * @param {string} userToken User token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesAddressesUserUsertoken(userToken: string, fields?: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesAddressesUserUsertoken(userToken, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all funding sources for a business
     * @param {string} businessToken Business token
     * @param {string} [type] Type, such as a payment card or ACH
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesBusinessBusinesstoken(businessToken: string, type?: string, fields?: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesBusinessBusinesstoken(businessToken, type, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific payment card
     * @param {string} fundingSourceToken Funding token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesPaymentcardFundingsourcetoken(fundingSourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific program funding source
     * @param {string} token Program funding source token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesProgramToken(token: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesProgramToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a gateway program funding source
     * @param {string} token Gateway program funding source token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesProgramgatewayToken(token: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesProgramgatewayToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all funding sources for a user
     * @param {string} userToken User token
     * @param {string} [type] Type, such as a payment card or ACH
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFundingsourcesUserUsertoken(userToken: string, type?: string, fields?: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).getFundingsourcesUserUsertoken(userToken, type, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Registers an ACH funding source
     * @param {AchModel} [achModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFundingsourcesAch(achModel?: AchModel, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesAch(achModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Registers an ACH funding source through a partner
     * @param {AchPartnerRequestModel} [achPartnerRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFundingsourcesAchPartner(achPartnerRequestModel?: AchPartnerRequestModel, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesAchPartner(achPartnerRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an account holder address for a funding source
     * @param {CardHolderAddressModel} [cardHolderAddressModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFundingsourcesAddresses(cardHolderAddressModel?: CardHolderAddressModel, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesAddresses(cardHolderAddressModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Registers a payment card funding source
     * @param {TokenRequest} [tokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFundingsourcesPaymentcard(tokenRequest?: TokenRequest, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesPaymentcard(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a program funding source
     * @param {ProgramFundingSourceRequest} [programFundingSourceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFundingsourcesProgram(programFundingSourceRequest?: ProgramFundingSourceRequest, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesProgram(programFundingSourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Registers an ACH funding source for a program
     * @param {BaseAchRequestModel} [baseAchRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFundingsourcesProgramAch(baseAchRequestModel?: BaseAchRequestModel, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesProgramAch(baseAchRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a gateway program funding source
     * @param {GatewayProgramFundingSourceRequest} [gatewayProgramFundingSourceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postFundingsourcesProgramgateway(gatewayProgramFundingSourceRequest?: GatewayProgramFundingSourceRequest, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).postFundingsourcesProgramgateway(gatewayProgramFundingSourceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verifies a bank account as a funding source
     * @param {string} fundingSourceToken 
     * @param {AchVerificationModel} [achVerificationModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFundingsourcesAchFundingsourcetoken(fundingSourceToken: string, achVerificationModel?: AchVerificationModel, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesAchFundingsourcetoken(fundingSourceToken, achVerificationModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates the account holder address for a funding source
     * @param {string} fundingSourceAddressToken Funding source address token
     * @param {CardHolderAddressUpdateModel} [cardHolderAddressUpdateModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken: string, cardHolderAddressUpdateModel?: CardHolderAddressUpdateModel, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesAddressesFundingsourceaddresstoken(fundingSourceAddressToken, cardHolderAddressUpdateModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific payment card 
     * @param {string} fundingSourceToken Funding account token
     * @param {TokenUpdateRequest} tokenUpdateRequest Payment card
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFundingsourcesFundingsourcetoken(fundingSourceToken: string, tokenUpdateRequest: TokenUpdateRequest, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesFundingsourcetoken(fundingSourceToken, tokenUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Configures a default funding source
     * @param {string} fundingSourceToken Funding account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFundingsourcesFundingsourcetokenDefault(fundingSourceToken: string, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesFundingsourcetokenDefault(fundingSourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific program funding source
     * @param {string} token Program funding source token
     * @param {ProgramFundingSourceUpdateRequest} [programFundingSourceUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFundingsourcesProgramToken(token: string, programFundingSourceUpdateRequest?: ProgramFundingSourceUpdateRequest, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesProgramToken(token, programFundingSourceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific gateway program funding source Custom headers
     * @param {string} token Gateway program funding source token
     * @param {GatewayProgramCustomHeaderUpdateRequest} [gatewayProgramCustomHeaderUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFundingsourcesProgramgatewayCustomHeaderToken(token: string, gatewayProgramCustomHeaderUpdateRequest?: GatewayProgramCustomHeaderUpdateRequest, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesProgramgatewayCustomHeaderToken(token, gatewayProgramCustomHeaderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific gateway program funding source
     * @param {string} token Gateway program funding source token
     * @param {GatewayProgramFundingSourceUpdateRequest} [gatewayProgramFundingSourceUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putFundingsourcesProgramgatewayToken(token: string, gatewayProgramFundingSourceUpdateRequest?: GatewayProgramFundingSourceUpdateRequest, options?: RawAxiosRequestConfig) {
        return FundingSourcesApiFp(this.configuration).putFundingsourcesProgramgatewayToken(token, gatewayProgramFundingSourceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GpaOrdersApi - axios parameter creator
 */
export const GpaOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a GPA order
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getGpaordersToken', 'token', token)
            const localVarPath = `/gpaorders/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all GPA returns
         * @param {number} [count] Number of GPA unloads to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [originalOrderToken] Original order token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloads: async (count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, originalOrderToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gpaorders/unloads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (originalOrderToken !== undefined) {
                localVarQueryParameter['original_order_token'] = originalOrderToken;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific GPA return
         * @param {string} unloadToken Unload token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloadsUnloadtoken: async (unloadToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'unloadToken' is not null or undefined
            assertParamExists('getGpaordersUnloadsUnloadtoken', 'unloadToken', unloadToken)
            const localVarPath = `/gpaorders/unloads/{unload_token}`
                .replace(`{${"unload_token"}}`, encodeURIComponent(String(unloadToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Funds a user\'s GPA account
         * @param {GpaRequest} [gpaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaorders: async (gpaRequest?: GpaRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gpaorders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(gpaRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a GPA order
         * @param {UnloadRequestModel} [unloadRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaordersUnloads: async (unloadRequestModel?: UnloadRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gpaorders/unloads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(unloadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GpaOrdersApi - functional programming interface
 */
export const GpaOrdersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = GpaOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a GPA order
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGpaordersToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GpaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGpaordersToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GpaOrdersApi.getGpaordersToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all GPA returns
         * @param {number} [count] Number of GPA unloads to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [originalOrderToken] Original order token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGpaordersUnloads(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, originalOrderToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPAUnloadListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGpaordersUnloads(count, startIndex, fields, sortBy, userToken, businessToken, originalOrderToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GpaOrdersApi.getGpaordersUnloads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific GPA return
         * @param {string} unloadToken Unload token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGpaordersUnloadsUnloadtoken(unloadToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GpaReturns>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGpaordersUnloadsUnloadtoken(unloadToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GpaOrdersApi.getGpaordersUnloadsUnloadtoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Funds a user\'s GPA account
         * @param {GpaRequest} [gpaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGpaorders(gpaRequest?: GpaRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GpaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGpaorders(gpaRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GpaOrdersApi.postGpaorders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a GPA order
         * @param {UnloadRequestModel} [unloadRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postGpaordersUnloads(unloadRequestModel?: UnloadRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GpaReturns>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postGpaordersUnloads(unloadRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GpaOrdersApi.postGpaordersUnloads']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GpaOrdersApi - factory interface
 */
export const GpaOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GpaOrdersApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a GPA order
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<GpaResponse> {
            return localVarFp.getGpaordersToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all GPA returns
         * @param {number} [count] Number of GPA unloads to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {string} [userToken] User token
         * @param {string} [businessToken] Business token
         * @param {string} [originalOrderToken] Original order token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloads(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, originalOrderToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<GPAUnloadListResponse> {
            return localVarFp.getGpaordersUnloads(count, startIndex, fields, sortBy, userToken, businessToken, originalOrderToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific GPA return
         * @param {string} unloadToken Unload token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGpaordersUnloadsUnloadtoken(unloadToken: string, options?: RawAxiosRequestConfig): AxiosPromise<GpaReturns> {
            return localVarFp.getGpaordersUnloadsUnloadtoken(unloadToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Funds a user\'s GPA account
         * @param {GpaRequest} [gpaRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaorders(gpaRequest?: GpaRequest, options?: RawAxiosRequestConfig): AxiosPromise<GpaResponse> {
            return localVarFp.postGpaorders(gpaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a GPA order
         * @param {UnloadRequestModel} [unloadRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGpaordersUnloads(unloadRequestModel?: UnloadRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<GpaReturns> {
            return localVarFp.postGpaordersUnloads(unloadRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GpaOrdersApi - object-oriented interface
 */
export class GpaOrdersApi extends BaseAPI {
    /**
     * 
     * @summary Returns a GPA order
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGpaordersToken(token: string, options?: RawAxiosRequestConfig) {
        return GpaOrdersApiFp(this.configuration).getGpaordersToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all GPA returns
     * @param {number} [count] Number of GPA unloads to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {string} [userToken] User token
     * @param {string} [businessToken] Business token
     * @param {string} [originalOrderToken] Original order token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGpaordersUnloads(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, originalOrderToken?: string, options?: RawAxiosRequestConfig) {
        return GpaOrdersApiFp(this.configuration).getGpaordersUnloads(count, startIndex, fields, sortBy, userToken, businessToken, originalOrderToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific GPA return
     * @param {string} unloadToken Unload token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGpaordersUnloadsUnloadtoken(unloadToken: string, options?: RawAxiosRequestConfig) {
        return GpaOrdersApiFp(this.configuration).getGpaordersUnloadsUnloadtoken(unloadToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Funds a user\'s GPA account
     * @param {GpaRequest} [gpaRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postGpaorders(gpaRequest?: GpaRequest, options?: RawAxiosRequestConfig) {
        return GpaOrdersApiFp(this.configuration).postGpaorders(gpaRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a GPA order
     * @param {UnloadRequestModel} [unloadRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postGpaordersUnloads(unloadRequestModel?: UnloadRequestModel, options?: RawAxiosRequestConfig) {
        return GpaOrdersApiFp(this.configuration).postGpaordersUnloads(unloadRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JournalEntriesApi - axios parameter creator
 */
export const JournalEntriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a journal entry for a credit account.
         * @summary Retrieve account journal entry
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} journalEntryToken Unique identifier of the journal entry you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountJournalEntry: async (accountToken: string, journalEntryToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getAccountJournalEntry', 'accountToken', accountToken)
            // verify required parameter 'journalEntryToken' is not null or undefined
            assertParamExists('getAccountJournalEntry', 'journalEntryToken', journalEntryToken)
            const localVarPath = `/accounts/{account_token}/journalentries/{journal_entry_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"journal_entry_token"}}`, encodeURIComponent(String(journalEntryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of journal entries on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.
         * @summary List account journal entries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of journal entry resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Starting date of the date range from which to return journal entries.
         * @param {string} [endDate] Ending date of the date range from which to return journal entries.
         * @param {string} [startImpactTime] Starting &#x60;impact_time&#x60; of the date range from which to return journal entries.
         * @param {string} [endImpactTime] Ending &#x60;impact_time&#x60; of the date range from which to return journal entries.
         * @param {string} [startCreatedTime] Starting &#x60;created_date&#x60; of the date range from which to return journal entries.
         * @param {string} [endCreatedTime] Ending &#x60;created_date&#x60; of the date range from which to return journal entries.
         * @param {Array<ListAccountJournalEntriesStatusesEnum>} [statuses] Array of statuses by which to filter journal entries.
         * @param {string} [detailToken] Detail token of the journal entries to return.
         * @param {Array<ListAccountJournalEntriesGroupsEnum>} [groups] Array of groups by which to filter journal entries.  To return all journal entry groups, do not include this query parameter.
         * @param {Array<ListAccountJournalEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListAccountJournalEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {Array<string>} [cardTokens] Array of card tokens by which to filter journal entries. Returns journal entries associated with the specified card tokens.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/cards/&#x60; to retrieve existing card tokens.
         * @param {Array<string>} [userTokens] Array of user tokens by which to filter journal entries. Returns journal entries associated with the specified user tokens.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve existing user tokens.
         * @param {Array<ListAccountJournalEntriesTypesEnum>} [types] Array of &lt;&lt;/core-api/event-types#_credit_journal_entry_events, event types&gt;&gt; by which to filter journal entries.  To return all event types, do not include this query parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountJournalEntries: async (accountToken: string, count?: number, startIndex?: number, startDate?: string, endDate?: string, startImpactTime?: string, endImpactTime?: string, startCreatedTime?: string, endCreatedTime?: string, statuses?: Array<ListAccountJournalEntriesStatusesEnum>, detailToken?: string, groups?: Array<ListAccountJournalEntriesGroupsEnum>, expand?: Array<ListAccountJournalEntriesExpandEnum>, sortBy?: ListAccountJournalEntriesSortByEnum, cardTokens?: Array<string>, userTokens?: Array<string>, types?: Array<ListAccountJournalEntriesTypesEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('listAccountJournalEntries', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/journalentries`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (startImpactTime !== undefined) {
                localVarQueryParameter['start_impact_time'] = startImpactTime;
            }

            if (endImpactTime !== undefined) {
                localVarQueryParameter['end_impact_time'] = endImpactTime;
            }

            if (startCreatedTime !== undefined) {
                localVarQueryParameter['start_created_time'] = startCreatedTime;
            }

            if (endCreatedTime !== undefined) {
                localVarQueryParameter['end_created_time'] = endCreatedTime;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (detailToken !== undefined) {
                localVarQueryParameter['detail_token'] = detailToken;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (cardTokens) {
                localVarQueryParameter['card_tokens'] = cardTokens;
            }

            if (userTokens) {
                localVarQueryParameter['user_tokens'] = userTokens;
            }

            if (types) {
                localVarQueryParameter['types'] = types;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent: async (eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('resendWebhookEvent', 'eventType', eventType)
            // verify required parameter 'resourceToken' is not null or undefined
            assertParamExists('resendWebhookEvent', 'resourceToken', resourceToken)
            const localVarPath = `/webhooks/{event_type}/{resource_token}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"resource_token"}}`, encodeURIComponent(String(resourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JournalEntriesApi - functional programming interface
 */
export const JournalEntriesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = JournalEntriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a journal entry for a credit account.
         * @summary Retrieve account journal entry
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} journalEntryToken Unique identifier of the journal entry you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountJournalEntry(accountToken: string, journalEntryToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountJournalEntry(accountToken, journalEntryToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JournalEntriesApi.getAccountJournalEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of journal entries on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.
         * @summary List account journal entries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of journal entry resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Starting date of the date range from which to return journal entries.
         * @param {string} [endDate] Ending date of the date range from which to return journal entries.
         * @param {string} [startImpactTime] Starting &#x60;impact_time&#x60; of the date range from which to return journal entries.
         * @param {string} [endImpactTime] Ending &#x60;impact_time&#x60; of the date range from which to return journal entries.
         * @param {string} [startCreatedTime] Starting &#x60;created_date&#x60; of the date range from which to return journal entries.
         * @param {string} [endCreatedTime] Ending &#x60;created_date&#x60; of the date range from which to return journal entries.
         * @param {Array<ListAccountJournalEntriesStatusesEnum>} [statuses] Array of statuses by which to filter journal entries.
         * @param {string} [detailToken] Detail token of the journal entries to return.
         * @param {Array<ListAccountJournalEntriesGroupsEnum>} [groups] Array of groups by which to filter journal entries.  To return all journal entry groups, do not include this query parameter.
         * @param {Array<ListAccountJournalEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListAccountJournalEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {Array<string>} [cardTokens] Array of card tokens by which to filter journal entries. Returns journal entries associated with the specified card tokens.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/cards/&#x60; to retrieve existing card tokens.
         * @param {Array<string>} [userTokens] Array of user tokens by which to filter journal entries. Returns journal entries associated with the specified user tokens.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve existing user tokens.
         * @param {Array<ListAccountJournalEntriesTypesEnum>} [types] Array of &lt;&lt;/core-api/event-types#_credit_journal_entry_events, event types&gt;&gt; by which to filter journal entries.  To return all event types, do not include this query parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccountJournalEntries(accountToken: string, count?: number, startIndex?: number, startDate?: string, endDate?: string, startImpactTime?: string, endImpactTime?: string, startCreatedTime?: string, endCreatedTime?: string, statuses?: Array<ListAccountJournalEntriesStatusesEnum>, detailToken?: string, groups?: Array<ListAccountJournalEntriesGroupsEnum>, expand?: Array<ListAccountJournalEntriesExpandEnum>, sortBy?: ListAccountJournalEntriesSortByEnum, cardTokens?: Array<string>, userTokens?: Array<string>, types?: Array<ListAccountJournalEntriesTypesEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountJournalEntries(accountToken, count, startIndex, startDate, endDate, startImpactTime, endImpactTime, startCreatedTime, endCreatedTime, statuses, detailToken, groups, expand, sortBy, cardTokens, userTokens, types, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JournalEntriesApi.listAccountJournalEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResendContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhookEvent(eventType, resourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JournalEntriesApi.resendWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JournalEntriesApi - factory interface
 */
export const JournalEntriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JournalEntriesApiFp(configuration)
    return {
        /**
         * Retrieve a journal entry for a credit account.
         * @summary Retrieve account journal entry
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} journalEntryToken Unique identifier of the journal entry you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountJournalEntry(accountToken: string, journalEntryToken: string, options?: RawAxiosRequestConfig): AxiosPromise<JournalEntry> {
            return localVarFp.getAccountJournalEntry(accountToken, journalEntryToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of journal entries on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.
         * @summary List account journal entries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of journal entry resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Starting date of the date range from which to return journal entries.
         * @param {string} [endDate] Ending date of the date range from which to return journal entries.
         * @param {string} [startImpactTime] Starting &#x60;impact_time&#x60; of the date range from which to return journal entries.
         * @param {string} [endImpactTime] Ending &#x60;impact_time&#x60; of the date range from which to return journal entries.
         * @param {string} [startCreatedTime] Starting &#x60;created_date&#x60; of the date range from which to return journal entries.
         * @param {string} [endCreatedTime] Ending &#x60;created_date&#x60; of the date range from which to return journal entries.
         * @param {Array<ListAccountJournalEntriesStatusesEnum>} [statuses] Array of statuses by which to filter journal entries.
         * @param {string} [detailToken] Detail token of the journal entries to return.
         * @param {Array<ListAccountJournalEntriesGroupsEnum>} [groups] Array of groups by which to filter journal entries.  To return all journal entry groups, do not include this query parameter.
         * @param {Array<ListAccountJournalEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListAccountJournalEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {Array<string>} [cardTokens] Array of card tokens by which to filter journal entries. Returns journal entries associated with the specified card tokens.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/cards/&#x60; to retrieve existing card tokens.
         * @param {Array<string>} [userTokens] Array of user tokens by which to filter journal entries. Returns journal entries associated with the specified user tokens.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve existing user tokens.
         * @param {Array<ListAccountJournalEntriesTypesEnum>} [types] Array of &lt;&lt;/core-api/event-types#_credit_journal_entry_events, event types&gt;&gt; by which to filter journal entries.  To return all event types, do not include this query parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccountJournalEntries(accountToken: string, count?: number, startIndex?: number, startDate?: string, endDate?: string, startImpactTime?: string, endImpactTime?: string, startCreatedTime?: string, endCreatedTime?: string, statuses?: Array<ListAccountJournalEntriesStatusesEnum>, detailToken?: string, groups?: Array<ListAccountJournalEntriesGroupsEnum>, expand?: Array<ListAccountJournalEntriesExpandEnum>, sortBy?: ListAccountJournalEntriesSortByEnum, cardTokens?: Array<string>, userTokens?: Array<string>, types?: Array<ListAccountJournalEntriesTypesEnum>, options?: RawAxiosRequestConfig): AxiosPromise<JournalEntriesPage> {
            return localVarFp.listAccountJournalEntries(accountToken, count, startIndex, startDate, endDate, startImpactTime, endImpactTime, startCreatedTime, endCreatedTime, statuses, detailToken, groups, expand, sortBy, cardTokens, userTokens, types, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResendContainerResponse> {
            return localVarFp.resendWebhookEvent(eventType, resourceToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JournalEntriesApi - object-oriented interface
 */
export class JournalEntriesApi extends BaseAPI {
    /**
     * Retrieve a journal entry for a credit account.
     * @summary Retrieve account journal entry
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} journalEntryToken Unique identifier of the journal entry you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountJournalEntry(accountToken: string, journalEntryToken: string, options?: RawAxiosRequestConfig) {
        return JournalEntriesApiFp(this.configuration).getAccountJournalEntry(accountToken, journalEntryToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of journal entries on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.
     * @summary List account journal entries
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {number} [count] Number of journal entry resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [startDate] Starting date of the date range from which to return journal entries.
     * @param {string} [endDate] Ending date of the date range from which to return journal entries.
     * @param {string} [startImpactTime] Starting &#x60;impact_time&#x60; of the date range from which to return journal entries.
     * @param {string} [endImpactTime] Ending &#x60;impact_time&#x60; of the date range from which to return journal entries.
     * @param {string} [startCreatedTime] Starting &#x60;created_date&#x60; of the date range from which to return journal entries.
     * @param {string} [endCreatedTime] Ending &#x60;created_date&#x60; of the date range from which to return journal entries.
     * @param {Array<ListAccountJournalEntriesStatusesEnum>} [statuses] Array of statuses by which to filter journal entries.
     * @param {string} [detailToken] Detail token of the journal entries to return.
     * @param {Array<ListAccountJournalEntriesGroupsEnum>} [groups] Array of groups by which to filter journal entries.  To return all journal entry groups, do not include this query parameter.
     * @param {Array<ListAccountJournalEntriesExpandEnum>} [expand] Embeds the specified object into the response.
     * @param {ListAccountJournalEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
     * @param {Array<string>} [cardTokens] Array of card tokens by which to filter journal entries. Returns journal entries associated with the specified card tokens.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/cards/&#x60; to retrieve existing card tokens.
     * @param {Array<string>} [userTokens] Array of user tokens by which to filter journal entries. Returns journal entries associated with the specified user tokens.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve existing user tokens.
     * @param {Array<ListAccountJournalEntriesTypesEnum>} [types] Array of &lt;&lt;/core-api/event-types#_credit_journal_entry_events, event types&gt;&gt; by which to filter journal entries.  To return all event types, do not include this query parameter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listAccountJournalEntries(accountToken: string, count?: number, startIndex?: number, startDate?: string, endDate?: string, startImpactTime?: string, endImpactTime?: string, startCreatedTime?: string, endCreatedTime?: string, statuses?: Array<ListAccountJournalEntriesStatusesEnum>, detailToken?: string, groups?: Array<ListAccountJournalEntriesGroupsEnum>, expand?: Array<ListAccountJournalEntriesExpandEnum>, sortBy?: ListAccountJournalEntriesSortByEnum, cardTokens?: Array<string>, userTokens?: Array<string>, types?: Array<ListAccountJournalEntriesTypesEnum>, options?: RawAxiosRequestConfig) {
        return JournalEntriesApiFp(this.configuration).listAccountJournalEntries(accountToken, count, startIndex, startDate, endDate, startImpactTime, endImpactTime, startCreatedTime, endCreatedTime, statuses, detailToken, groups, expand, sortBy, cardTokens, userTokens, types, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
     * @summary Resend credit event notification
     * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig) {
        return JournalEntriesApiFp(this.configuration).resendWebhookEvent(eventType, resourceToken, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListAccountJournalEntriesStatusesEnum = {
    Posted: 'POSTED',
    Pending: 'PENDING'
} as const;
export type ListAccountJournalEntriesStatusesEnum = typeof ListAccountJournalEntriesStatusesEnum[keyof typeof ListAccountJournalEntriesStatusesEnum];
export const ListAccountJournalEntriesGroupsEnum = {
    Purchase: 'PURCHASE',
    OriginalCredit: 'ORIGINAL_CREDIT',
    Fee: 'FEE',
    BalanceRefund: 'BALANCE_REFUND',
    Payment: 'PAYMENT',
    Interest: 'INTEREST',
    Dispute: 'DISPUTE',
    Refund: 'REFUND',
    Adjustment: 'ADJUSTMENT',
    Reward: 'REWARD'
} as const;
export type ListAccountJournalEntriesGroupsEnum = typeof ListAccountJournalEntriesGroupsEnum[keyof typeof ListAccountJournalEntriesGroupsEnum];
export const ListAccountJournalEntriesExpandEnum = {
    DetailObject: 'detailObject',
    OriginalCurrency: 'originalCurrency'
} as const;
export type ListAccountJournalEntriesExpandEnum = typeof ListAccountJournalEntriesExpandEnum[keyof typeof ListAccountJournalEntriesExpandEnum];
export const ListAccountJournalEntriesSortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime',
    ImpactTime: 'impactTime',
    ImpactTime2: '-impactTime'
} as const;
export type ListAccountJournalEntriesSortByEnum = typeof ListAccountJournalEntriesSortByEnum[keyof typeof ListAccountJournalEntriesSortByEnum];
export const ListAccountJournalEntriesTypesEnum = {
    Authorization: 'authorization',
    AuthorizationAdvice: 'authorization.advice',
    AuthorizationIncremental: 'authorization.incremental',
    AuthorizationReversal: 'authorization.reversal',
    AuthorizationReversalIssuerexpiration: 'authorization.reversal.issuerexpiration',
    AuthorizationClearing: 'authorization.clearing',
    Refund: 'refund',
    RefundAuthorization: 'refund.authorization',
    RefundAuthorizationAdvice: 'refund.authorization.advice',
    RefundAuthorizationReversal: 'refund.authorization.reversal',
    RefundAuthorizationClearing: 'refund.authorization.clearing',
    RefundAuthorizationReversalIssuerexpiration: 'refund.authorization.reversal.issuerexpiration',
    OriginalcreditAuthorization: 'originalcredit.authorization',
    OriginalcreditAuthorizationClearing: 'originalcredit.authorization.clearing',
    OriginalcreditAuthorizationReversal: 'originalcredit.authorization.reversal',
    OriginalcreditAuthpluscapture: 'originalcredit.authpluscapture',
    OriginalcreditAuthpluscaptureReversal: 'originalcredit.authpluscapture.reversal',
    OriginalcreditAuthorizationReversalIssuerexpiration: 'originalcredit.authorization.reversal.issuerexpiration',
    AccountBalancerefund: 'account.balancerefund',
    AccountRewardCashback: 'account.reward.cashback',
    AccountRewardAutoCashback: 'account.reward.auto.cashback',
    AccountRewardAutoCashbackReversal: 'account.reward.auto.cashback.reversal',
    AccountPayment: 'account.payment',
    AccountPaymentCompleted: 'account.payment.completed',
    AccountPaymentReturned: 'account.payment.returned',
    AccountPaymentCanceled: 'account.payment.canceled',
    AccountPaymentRefunded: 'account.payment.refunded',
    AccountPaymentCompletedHoldReleased: 'account.payment.completed.hold.released',
    AccountPaymentCompletedHold: 'account.payment.completed.hold',
    AccountInterest: 'account.interest',
    AccountFeePaymentLate: 'account.fee.payment.late',
    AccountFeePaymentReturned: 'account.fee.payment.returned',
    AccountFeeInterestMinimum: 'account.fee.interest.minimum',
    AccountDispute: 'account.dispute',
    AccountDisputeReversal: 'account.dispute.reversal',
    AccountDisputeWon: 'account.dispute.won',
    AccountDisputeLost: 'account.dispute.lost',
    AccountDisputeLostGraceperiod: 'account.dispute.lost.graceperiod',
    AccountAdjustment: 'account.adjustment',
    AccountAdjustmentPurchase: 'account.adjustment.purchase',
    AccountAdjustmentFee: 'account.adjustment.fee',
    AccountAdjustmentInterest: 'account.adjustment.interest',
    AccountAdjustmentReward: 'account.adjustment.reward',
    Pindebit: 'pindebit',
    PindebitAuthorizationClearing: 'pindebit.authorization.clearing',
    PindebitRefund: 'pindebit.refund'
} as const;
export type ListAccountJournalEntriesTypesEnum = typeof ListAccountJournalEntriesTypesEnum[keyof typeof ListAccountJournalEntriesTypesEnum];



/**
 * KycApi - axios parameter creator
 */
export const KycApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all KYC results for a business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycBusinessBusinesstoken: async (businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessToken' is not null or undefined
            assertParamExists('getKycBusinessBusinesstoken', 'businessToken', businessToken)
            const localVarPath = `/kyc/business/{business_token}`
                .replace(`{${"business_token"}}`, encodeURIComponent(String(businessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific KYC result
         * @param {string} token KYC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getKycToken', 'token', token)
            const localVarPath = `/kyc/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all KYC results for a user
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycUserUsertoken: async (userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('getKycUserUsertoken', 'userToken', userToken)
            const localVarPath = `/kyc/user/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Performs a KYC
         * @param {KycRequest} [kycRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postKyc: async (kycRequest?: KycRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/kyc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(kycRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KycApi - functional programming interface
 */
export const KycApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = KycApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all KYC results for a business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KYCListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycApi.getKycBusinessBusinesstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific KYC result
         * @param {string} token KYC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KycResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycApi.getKycToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all KYC results for a user
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKycUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KYCListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKycUserUsertoken(userToken, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycApi.getKycUserUsertoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Performs a KYC
         * @param {KycRequest} [kycRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postKyc(kycRequest?: KycRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KycResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postKyc(kycRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KycApi.postKyc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KycApi - factory interface
 */
export const KycApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KycApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all KYC results for a business
         * @param {string} businessToken Business token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<KYCListResponse> {
            return localVarFp.getKycBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific KYC result
         * @param {string} token KYC token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<KycResponse> {
            return localVarFp.getKycToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all KYC results for a user
         * @param {string} userToken User token
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKycUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<KYCListResponse> {
            return localVarFp.getKycUserUsertoken(userToken, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Performs a KYC
         * @param {KycRequest} [kycRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postKyc(kycRequest?: KycRequest, options?: RawAxiosRequestConfig): AxiosPromise<KycResponse> {
            return localVarFp.postKyc(kycRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KycApi - object-oriented interface
 */
export class KycApi extends BaseAPI {
    /**
     * 
     * @summary Lists all KYC results for a business
     * @param {string} businessToken Business token
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getKycBusinessBusinesstoken(businessToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return KycApiFp(this.configuration).getKycBusinessBusinesstoken(businessToken, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific KYC result
     * @param {string} token KYC token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getKycToken(token: string, options?: RawAxiosRequestConfig) {
        return KycApiFp(this.configuration).getKycToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all KYC results for a user
     * @param {string} userToken User token
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getKycUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return KycApiFp(this.configuration).getKycUserUsertoken(userToken, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Performs a KYC
     * @param {KycRequest} [kycRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postKyc(kycRequest?: KycRequest, options?: RawAxiosRequestConfig) {
        return KycApiFp(this.configuration).postKyc(kycRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LedgerEntriesApi - axios parameter creator
 */
export const LedgerEntriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a ledger entry for a credit account.
         * @summary Retrieve account ledger entry
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} ledgerEntryToken Unique identifier of the ledger entry you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountLedgerEntry: async (accountToken: string, ledgerEntryToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getAccountLedgerEntry', 'accountToken', accountToken)
            // verify required parameter 'ledgerEntryToken' is not null or undefined
            assertParamExists('getAccountLedgerEntry', 'ledgerEntryToken', ledgerEntryToken)
            const localVarPath = `/accounts/{account_token}/ledgerentries/{ledger_entry_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"ledger_entry_token"}}`, encodeURIComponent(String(ledgerEntryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of ledger entries on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.
         * @summary List account ledger entries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of ledger entry resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Starting date of the date range from which to return ledger entries.
         * @param {string} [endDate] Ending date of the date range from which to return ledger entries.
         * @param {Array<string>} [statuses] Array of statuses by which to filter ledger entries.
         * @param {string} [description] Description of the ledger entries to return.
         * @param {string} [detailToken] Detail token of the ledger entries to return.
         * @param {Array<string>} [groups] Array of groups by which to filter ledger entries.  To return all ledger entry groups, do not include this query parameter.
         * @param {number} [amount] Number of ledger entries to return.
         * @param {Array<ListAccountLedgerEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListAccountLedgerEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listAccountLedgerEntries: async (accountToken: string, count?: number, startIndex?: number, startDate?: string, endDate?: string, statuses?: Array<string>, description?: string, detailToken?: string, groups?: Array<string>, amount?: number, expand?: Array<ListAccountLedgerEntriesExpandEnum>, sortBy?: ListAccountLedgerEntriesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('listAccountLedgerEntries', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/ledgerentries`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (detailToken !== undefined) {
                localVarQueryParameter['detail_token'] = detailToken;
            }

            if (groups) {
                localVarQueryParameter['groups'] = groups;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent: async (eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('resendWebhookEvent', 'eventType', eventType)
            // verify required parameter 'resourceToken' is not null or undefined
            assertParamExists('resendWebhookEvent', 'resourceToken', resourceToken)
            const localVarPath = `/webhooks/{event_type}/{resource_token}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"resource_token"}}`, encodeURIComponent(String(resourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgerEntriesApi - functional programming interface
 */
export const LedgerEntriesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = LedgerEntriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a ledger entry for a credit account.
         * @summary Retrieve account ledger entry
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} ledgerEntryToken Unique identifier of the ledger entry you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountLedgerEntry(accountToken: string, ledgerEntryToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LedgerEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountLedgerEntry(accountToken, ledgerEntryToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerEntriesApi.getAccountLedgerEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of ledger entries on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.
         * @summary List account ledger entries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of ledger entry resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Starting date of the date range from which to return ledger entries.
         * @param {string} [endDate] Ending date of the date range from which to return ledger entries.
         * @param {Array<string>} [statuses] Array of statuses by which to filter ledger entries.
         * @param {string} [description] Description of the ledger entries to return.
         * @param {string} [detailToken] Detail token of the ledger entries to return.
         * @param {Array<string>} [groups] Array of groups by which to filter ledger entries.  To return all ledger entry groups, do not include this query parameter.
         * @param {number} [amount] Number of ledger entries to return.
         * @param {Array<ListAccountLedgerEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListAccountLedgerEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listAccountLedgerEntries(accountToken: string, count?: number, startIndex?: number, startDate?: string, endDate?: string, statuses?: Array<string>, description?: string, detailToken?: string, groups?: Array<string>, amount?: number, expand?: Array<ListAccountLedgerEntriesExpandEnum>, sortBy?: ListAccountLedgerEntriesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LedgerEntriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountLedgerEntries(accountToken, count, startIndex, startDate, endDate, statuses, description, detailToken, groups, amount, expand, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerEntriesApi.listAccountLedgerEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResendContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhookEvent(eventType, resourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerEntriesApi.resendWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LedgerEntriesApi - factory interface
 */
export const LedgerEntriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LedgerEntriesApiFp(configuration)
    return {
        /**
         * Retrieve a ledger entry for a credit account.
         * @summary Retrieve account ledger entry
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} ledgerEntryToken Unique identifier of the ledger entry you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountLedgerEntry(accountToken: string, ledgerEntryToken: string, options?: RawAxiosRequestConfig): AxiosPromise<LedgerEntry> {
            return localVarFp.getAccountLedgerEntry(accountToken, ledgerEntryToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of ledger entries on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.
         * @summary List account ledger entries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {number} [count] Number of ledger entry resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Starting date of the date range from which to return ledger entries.
         * @param {string} [endDate] Ending date of the date range from which to return ledger entries.
         * @param {Array<string>} [statuses] Array of statuses by which to filter ledger entries.
         * @param {string} [description] Description of the ledger entries to return.
         * @param {string} [detailToken] Detail token of the ledger entries to return.
         * @param {Array<string>} [groups] Array of groups by which to filter ledger entries.  To return all ledger entry groups, do not include this query parameter.
         * @param {number} [amount] Number of ledger entries to return.
         * @param {Array<ListAccountLedgerEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListAccountLedgerEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listAccountLedgerEntries(accountToken: string, count?: number, startIndex?: number, startDate?: string, endDate?: string, statuses?: Array<string>, description?: string, detailToken?: string, groups?: Array<string>, amount?: number, expand?: Array<ListAccountLedgerEntriesExpandEnum>, sortBy?: ListAccountLedgerEntriesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<LedgerEntriesPage> {
            return localVarFp.listAccountLedgerEntries(accountToken, count, startIndex, startDate, endDate, statuses, description, detailToken, groups, amount, expand, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResendContainerResponse> {
            return localVarFp.resendWebhookEvent(eventType, resourceToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LedgerEntriesApi - object-oriented interface
 */
export class LedgerEntriesApi extends BaseAPI {
    /**
     * Retrieve a ledger entry for a credit account.
     * @summary Retrieve account ledger entry
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} ledgerEntryToken Unique identifier of the ledger entry you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountLedgerEntry(accountToken: string, ledgerEntryToken: string, options?: RawAxiosRequestConfig) {
        return LedgerEntriesApiFp(this.configuration).getAccountLedgerEntry(accountToken, ledgerEntryToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of ledger entries on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>> and <</core-api/object-expansion, object expansion>>.
     * @summary List account ledger entries
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {number} [count] Number of ledger entry resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [startDate] Starting date of the date range from which to return ledger entries.
     * @param {string} [endDate] Ending date of the date range from which to return ledger entries.
     * @param {Array<string>} [statuses] Array of statuses by which to filter ledger entries.
     * @param {string} [description] Description of the ledger entries to return.
     * @param {string} [detailToken] Detail token of the ledger entries to return.
     * @param {Array<string>} [groups] Array of groups by which to filter ledger entries.  To return all ledger entry groups, do not include this query parameter.
     * @param {number} [amount] Number of ledger entries to return.
     * @param {Array<ListAccountLedgerEntriesExpandEnum>} [expand] Embeds the specified object into the response.
     * @param {ListAccountLedgerEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public listAccountLedgerEntries(accountToken: string, count?: number, startIndex?: number, startDate?: string, endDate?: string, statuses?: Array<string>, description?: string, detailToken?: string, groups?: Array<string>, amount?: number, expand?: Array<ListAccountLedgerEntriesExpandEnum>, sortBy?: ListAccountLedgerEntriesSortByEnum, options?: RawAxiosRequestConfig) {
        return LedgerEntriesApiFp(this.configuration).listAccountLedgerEntries(accountToken, count, startIndex, startDate, endDate, statuses, description, detailToken, groups, amount, expand, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
     * @summary Resend credit event notification
     * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig) {
        return LedgerEntriesApiFp(this.configuration).resendWebhookEvent(eventType, resourceToken, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListAccountLedgerEntriesExpandEnum = {
    DetailObject: 'detailObject',
    OriginalCurrency: 'originalCurrency'
} as const;
export type ListAccountLedgerEntriesExpandEnum = typeof ListAccountLedgerEntriesExpandEnum[keyof typeof ListAccountLedgerEntriesExpandEnum];
export const ListAccountLedgerEntriesSortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime'
} as const;
export type ListAccountLedgerEntriesSortByEnum = typeof ListAccountLedgerEntriesSortByEnum[keyof typeof ListAccountLedgerEntriesSortByEnum];



/**
 * MccGroupsApi - axios parameter creator
 */
export const MccGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all MCC groups
         * @param {string} [mcc] MCC
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroups: async (mcc?: string, count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mccgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (mcc !== undefined) {
                localVarQueryParameter['mcc'] = mcc;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific MCC group
         * @param {string} token MCC group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroupsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getMccgroupsToken', 'token', token)
            const localVarPath = `/mccgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates an MCC group
         * @param {MccGroupModel} mccGroupModel MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMccgroups: async (mccGroupModel: MccGroupModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mccGroupModel' is not null or undefined
            assertParamExists('postMccgroups', 'mccGroupModel', mccGroupModel)
            const localVarPath = `/mccgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(mccGroupModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an MCC group
         * @param {string} token 
         * @param {MccGroupUpdateModel} mccGroupUpdateModel MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMccgroupsToken: async (token: string, mccGroupUpdateModel: MccGroupUpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putMccgroupsToken', 'token', token)
            // verify required parameter 'mccGroupUpdateModel' is not null or undefined
            assertParamExists('putMccgroupsToken', 'mccGroupUpdateModel', mccGroupUpdateModel)
            const localVarPath = `/mccgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(mccGroupUpdateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MccGroupsApi - functional programming interface
 */
export const MccGroupsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MccGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all MCC groups
         * @param {string} [mcc] MCC
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMccgroups(mcc?: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MCCGroupListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMccgroups(mcc, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MccGroupsApi.getMccgroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific MCC group
         * @param {string} token MCC group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMccgroupsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MccGroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMccgroupsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MccGroupsApi.getMccgroupsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates an MCC group
         * @param {MccGroupModel} mccGroupModel MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMccgroups(mccGroupModel: MccGroupModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MccGroupModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMccgroups(mccGroupModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MccGroupsApi.postMccgroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an MCC group
         * @param {string} token 
         * @param {MccGroupUpdateModel} mccGroupUpdateModel MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMccgroupsToken(token: string, mccGroupUpdateModel: MccGroupUpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MccGroupUpdateModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMccgroupsToken(token, mccGroupUpdateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MccGroupsApi.putMccgroupsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MccGroupsApi - factory interface
 */
export const MccGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MccGroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all MCC groups
         * @param {string} [mcc] MCC
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroups(mcc?: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<MCCGroupListResponse> {
            return localVarFp.getMccgroups(mcc, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific MCC group
         * @param {string} token MCC group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMccgroupsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<MccGroupModel> {
            return localVarFp.getMccgroupsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates an MCC group
         * @param {MccGroupModel} mccGroupModel MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMccgroups(mccGroupModel: MccGroupModel, options?: RawAxiosRequestConfig): AxiosPromise<MccGroupModel> {
            return localVarFp.postMccgroups(mccGroupModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an MCC group
         * @param {string} token 
         * @param {MccGroupUpdateModel} mccGroupUpdateModel MCC group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMccgroupsToken(token: string, mccGroupUpdateModel: MccGroupUpdateModel, options?: RawAxiosRequestConfig): AxiosPromise<MccGroupUpdateModel> {
            return localVarFp.putMccgroupsToken(token, mccGroupUpdateModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MccGroupsApi - object-oriented interface
 */
export class MccGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Lists all MCC groups
     * @param {string} [mcc] MCC
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMccgroups(mcc?: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return MccGroupsApiFp(this.configuration).getMccgroups(mcc, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific MCC group
     * @param {string} token MCC group token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMccgroupsToken(token: string, options?: RawAxiosRequestConfig) {
        return MccGroupsApiFp(this.configuration).getMccgroupsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates an MCC group
     * @param {MccGroupModel} mccGroupModel MCC group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postMccgroups(mccGroupModel: MccGroupModel, options?: RawAxiosRequestConfig) {
        return MccGroupsApiFp(this.configuration).postMccgroups(mccGroupModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an MCC group
     * @param {string} token 
     * @param {MccGroupUpdateModel} mccGroupUpdateModel MCC group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putMccgroupsToken(token: string, mccGroupUpdateModel: MccGroupUpdateModel, options?: RawAxiosRequestConfig) {
        return MccGroupsApiFp(this.configuration).putMccgroupsToken(token, mccGroupUpdateModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MerchantgroupsApi - axios parameter creator
 */
export const MerchantgroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a Merchant Group
         * @param {string} token Merchant Group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroup: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getMerchantGroup', 'token', token)
            const localVarPath = `/merchantgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all Merchant Groups
         * @param {string} [mid] mid
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroups: async (mid?: string, count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merchantgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (mid !== undefined) {
                localVarQueryParameter['mid'] = mid;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a merchant group
         * @param {MerchantGroupRequest} [merchantGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerchantGroup: async (merchantGroupRequest?: MerchantGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merchantgroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(merchantGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an Merchant Group
         * @param {string} token 
         * @param {MerchantGroupUpdateRequest} merchantGroupUpdateRequest Merchant Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMerchantGroupsToken: async (token: string, merchantGroupUpdateRequest: MerchantGroupUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putMerchantGroupsToken', 'token', token)
            // verify required parameter 'merchantGroupUpdateRequest' is not null or undefined
            assertParamExists('putMerchantGroupsToken', 'merchantGroupUpdateRequest', merchantGroupUpdateRequest)
            const localVarPath = `/merchantgroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(merchantGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantgroupsApi - functional programming interface
 */
export const MerchantgroupsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MerchantgroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a Merchant Group
         * @param {string} token Merchant Group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerchantGroup(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerchantGroup(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantgroupsApi.getMerchantGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all Merchant Groups
         * @param {string} [mid] mid
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerchantGroups(mid?: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantGroupListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerchantGroups(mid, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantgroupsApi.getMerchantGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a merchant group
         * @param {MerchantGroupRequest} [merchantGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMerchantGroup(merchantGroupRequest?: MerchantGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMerchantGroup(merchantGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantgroupsApi.postMerchantGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an Merchant Group
         * @param {string} token 
         * @param {MerchantGroupUpdateRequest} merchantGroupUpdateRequest Merchant Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMerchantGroupsToken(token: string, merchantGroupUpdateRequest: MerchantGroupUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMerchantGroupsToken(token, merchantGroupUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantgroupsApi.putMerchantGroupsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MerchantgroupsApi - factory interface
 */
export const MerchantgroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MerchantgroupsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a Merchant Group
         * @param {string} token Merchant Group token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroup(token: string, options?: RawAxiosRequestConfig): AxiosPromise<MerchantGroupResponse> {
            return localVarFp.getMerchantGroup(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all Merchant Groups
         * @param {string} [mid] mid
         * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
         * @param {number} [startIndex] Indicates from what row to start returning data.
         * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantGroups(mid?: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<MerchantGroupListResponse> {
            return localVarFp.getMerchantGroups(mid, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a merchant group
         * @param {MerchantGroupRequest} [merchantGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMerchantGroup(merchantGroupRequest?: MerchantGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<MerchantGroupResponse> {
            return localVarFp.postMerchantGroup(merchantGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an Merchant Group
         * @param {string} token 
         * @param {MerchantGroupUpdateRequest} merchantGroupUpdateRequest Merchant Group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMerchantGroupsToken(token: string, merchantGroupUpdateRequest: MerchantGroupUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<MerchantGroupResponse> {
            return localVarFp.putMerchantGroupsToken(token, merchantGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantgroupsApi - object-oriented interface
 */
export class MerchantgroupsApi extends BaseAPI {
    /**
     * 
     * @summary Returns a Merchant Group
     * @param {string} token Merchant Group token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMerchantGroup(token: string, options?: RawAxiosRequestConfig) {
        return MerchantgroupsApiFp(this.configuration).getMerchantGroup(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all Merchant Groups
     * @param {string} [mid] mid
     * @param {number} [count] Number of items to retrieve. Count can be between 1 - 10 items.
     * @param {number} [startIndex] Indicates from what row to start returning data.
     * @param {string} [sortBy] Field by which to sort the returned items. Use any field in the model, or system fields lastModifiedTime or createdTime.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMerchantGroups(mid?: string, count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return MerchantgroupsApiFp(this.configuration).getMerchantGroups(mid, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a merchant group
     * @param {MerchantGroupRequest} [merchantGroupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postMerchantGroup(merchantGroupRequest?: MerchantGroupRequest, options?: RawAxiosRequestConfig) {
        return MerchantgroupsApiFp(this.configuration).postMerchantGroup(merchantGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an Merchant Group
     * @param {string} token 
     * @param {MerchantGroupUpdateRequest} merchantGroupUpdateRequest Merchant Group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putMerchantGroupsToken(token: string, merchantGroupUpdateRequest: MerchantGroupUpdateRequest, options?: RawAxiosRequestConfig) {
        return MerchantgroupsApiFp(this.configuration).putMerchantGroupsToken(token, merchantGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MigrationsApi - axios parameter creator
 */
export const MigrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the current balance, available credit for a credit account.
         * @summary Get the current balance and available credit for a credit account
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve fees.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalances: async (accountToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getAccountBalances', 'accountToken', accountToken)
            const localVarPath = `/migrations/accounts/{account_token}/getaccountbalances`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Called to retrieve the finalize status of a migrated account 
         * @summary Get finalize status
         * @param {string} accountToken Unique identifier of the credit account for which you want to get the finalize status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizeAccountMigrationStatus: async (accountToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getFinalizeAccountMigrationStatus', 'accountToken', accountToken)
            const localVarPath = `/migrations/accounts/{account_token}/finalize`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync a statement asset to a migrated statement summary.
         * @summary Sync statement asset
         * @param {string} accountToken Unique identifier of the credit account for which you want to sync a statement asset.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the migrated statement summary for which you want to sync an asset.
         * @param {SyncStatementAssetReq} syncStatementAssetReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncStatementAsset: async (accountToken: string, statementSummaryToken: string, syncStatementAssetReq: SyncStatementAssetReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('syncStatementAsset', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('syncStatementAsset', 'statementSummaryToken', statementSummaryToken)
            // verify required parameter 'syncStatementAssetReq' is not null or undefined
            assertParamExists('syncStatementAsset', 'syncStatementAssetReq', syncStatementAssetReq)
            const localVarPath = `/migrations/accounts/{account_token}/statements/{statement_summary_token}/files`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(syncStatementAssetReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MigrationsApi - functional programming interface
 */
export const MigrationsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = MigrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the current balance, available credit for a credit account.
         * @summary Get the current balance and available credit for a credit account
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve fees.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountBalances(accountToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculatedBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountBalances(accountToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.getAccountBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Called to retrieve the finalize status of a migrated account 
         * @summary Get finalize status
         * @param {string} accountToken Unique identifier of the credit account for which you want to get the finalize status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinalizeAccountMigrationStatus(accountToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FinalizeMigrationStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinalizeAccountMigrationStatus(accountToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.getFinalizeAccountMigrationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sync a statement asset to a migrated statement summary.
         * @summary Sync statement asset
         * @param {string} accountToken Unique identifier of the credit account for which you want to sync a statement asset.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the migrated statement summary for which you want to sync an asset.
         * @param {SyncStatementAssetReq} syncStatementAssetReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncStatementAsset(accountToken: string, statementSummaryToken: string, syncStatementAssetReq: SyncStatementAssetReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MigrationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncStatementAsset(accountToken, statementSummaryToken, syncStatementAssetReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MigrationsApi.syncStatementAsset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MigrationsApi - factory interface
 */
export const MigrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MigrationsApiFp(configuration)
    return {
        /**
         * Retrieve the current balance, available credit for a credit account.
         * @summary Get the current balance and available credit for a credit account
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve fees.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBalances(accountToken: string, options?: RawAxiosRequestConfig): AxiosPromise<CalculatedBalanceResponse> {
            return localVarFp.getAccountBalances(accountToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Called to retrieve the finalize status of a migrated account 
         * @summary Get finalize status
         * @param {string} accountToken Unique identifier of the credit account for which you want to get the finalize status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizeAccountMigrationStatus(accountToken: string, options?: RawAxiosRequestConfig): AxiosPromise<FinalizeMigrationStatusResponse> {
            return localVarFp.getFinalizeAccountMigrationStatus(accountToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync a statement asset to a migrated statement summary.
         * @summary Sync statement asset
         * @param {string} accountToken Unique identifier of the credit account for which you want to sync a statement asset.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the migrated statement summary for which you want to sync an asset.
         * @param {SyncStatementAssetReq} syncStatementAssetReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncStatementAsset(accountToken: string, statementSummaryToken: string, syncStatementAssetReq: SyncStatementAssetReq, options?: RawAxiosRequestConfig): AxiosPromise<MigrationResponse> {
            return localVarFp.syncStatementAsset(accountToken, statementSummaryToken, syncStatementAssetReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MigrationsApi - object-oriented interface
 */
export class MigrationsApi extends BaseAPI {
    /**
     * Retrieve the current balance, available credit for a credit account.
     * @summary Get the current balance and available credit for a credit account
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve fees.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAccountBalances(accountToken: string, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getAccountBalances(accountToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Called to retrieve the finalize status of a migrated account 
     * @summary Get finalize status
     * @param {string} accountToken Unique identifier of the credit account for which you want to get the finalize status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFinalizeAccountMigrationStatus(accountToken: string, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).getFinalizeAccountMigrationStatus(accountToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync a statement asset to a migrated statement summary.
     * @summary Sync statement asset
     * @param {string} accountToken Unique identifier of the credit account for which you want to sync a statement asset.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the migrated statement summary for which you want to sync an asset.
     * @param {SyncStatementAssetReq} syncStatementAssetReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public syncStatementAsset(accountToken: string, statementSummaryToken: string, syncStatementAssetReq: SyncStatementAssetReq, options?: RawAxiosRequestConfig) {
        return MigrationsApiFp(this.configuration).syncStatementAsset(accountToken, statementSummaryToken, syncStatementAssetReq, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PINsApi - axios parameter creator
 */
export const PINsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a control token necessary when creating or updating a card\'s personal identification number (PIN).  Creating, updating, or revealing a card\'s PIN is a two-step process. You must first create the control token that is required to create the PIN, and then you create, update, or reveal the PIN itself.  The lifespan of the control token in a production environment is either five minutes or one hour from creation, depending on the token type. If multiple tokens are requested for a single card, only the most recent one is valid. Once redeemed, a token cannot be reused.
         * @summary Create PIN control token
         * @param {ControlTokenRequest} [controlTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPinsControltoken: async (controlTokenRequest?: ControlTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pins/controltoken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(controlTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates or updates a personal identification number (PIN) for an existing card. Although cardholders might choose a four-, five-, or six-digit PIN if they set their PIN at an automated teller machine, they can only set a four-digit PIN using Marqeta\'s Set PIN widget or the create or update PIN endpoint (`PUT /pins`). Cardholders can update their PIN through the API regardless of its length, but the new PIN value they choose must contain four digits.  If you want to manage a card\'s PIN, first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to update the PIN. You must create a card before you can manage a PIN.  Unless PIN reveal functionality has been enabled for your program, you cannot retrieve a PIN that has previously been created. If the PIN has been forgotten, you must either update the card\'s PIN or create a new card and PIN.  If you have enabled PIN reveal functionality for your program, you can send a `POST` request to the `/pins/reveal` endpoint to retrieve an existing PIN. See <</core-api/pins#revealPins, Reveal PIN>> on this page for details.  [WARNING] Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.
         * @summary Create or update PIN
         * @param {PinRequest} [pinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPins: async (pinRequest?: PinRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(pinRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reveals the personal identification number (PIN) of an existing, active card. Be aware that while a cardholder can only set a four-digit PIN using the Marqeta Set PIN widget or `PUT /pins` API, you may see a four-, five-, or six-digit PIN in cases where your cardholders have set a new PIN at an automated teller machine.  [WARNING] Only use this endpoint to access a PIN in order to reveal it to its cardholder. Do not use this endpoint for the purpose of storing a PIN at any location.  Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.  If you want to update a card\'s PIN instead, send a `PUT` request to the `/pins` endpoint. See <</core-api/pins#putPins, Create or Update PIN>> on this page for details.  Revealing a card\'s PIN is a two-step process. You must first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to reveal the PIN.
         * @summary Reveal PIN
         * @param {PinRevealRequest} [pinRevealRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revealPins: async (pinRevealRequest?: PinRevealRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pins/reveal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(pinRevealRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PINsApi - functional programming interface
 */
export const PINsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PINsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a control token necessary when creating or updating a card\'s personal identification number (PIN).  Creating, updating, or revealing a card\'s PIN is a two-step process. You must first create the control token that is required to create the PIN, and then you create, update, or reveal the PIN itself.  The lifespan of the control token in a production environment is either five minutes or one hour from creation, depending on the token type. If multiple tokens are requested for a single card, only the most recent one is valid. Once redeemed, a token cannot be reused.
         * @summary Create PIN control token
         * @param {ControlTokenRequest} [controlTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPinsControltoken(controlTokenRequest?: ControlTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPinsControltoken(controlTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PINsApi.postPinsControltoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates or updates a personal identification number (PIN) for an existing card. Although cardholders might choose a four-, five-, or six-digit PIN if they set their PIN at an automated teller machine, they can only set a four-digit PIN using Marqeta\'s Set PIN widget or the create or update PIN endpoint (`PUT /pins`). Cardholders can update their PIN through the API regardless of its length, but the new PIN value they choose must contain four digits.  If you want to manage a card\'s PIN, first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to update the PIN. You must create a card before you can manage a PIN.  Unless PIN reveal functionality has been enabled for your program, you cannot retrieve a PIN that has previously been created. If the PIN has been forgotten, you must either update the card\'s PIN or create a new card and PIN.  If you have enabled PIN reveal functionality for your program, you can send a `POST` request to the `/pins/reveal` endpoint to retrieve an existing PIN. See <</core-api/pins#revealPins, Reveal PIN>> on this page for details.  [WARNING] Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.
         * @summary Create or update PIN
         * @param {PinRequest} [pinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putPins(pinRequest?: PinRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putPins(pinRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PINsApi.putPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reveals the personal identification number (PIN) of an existing, active card. Be aware that while a cardholder can only set a four-digit PIN using the Marqeta Set PIN widget or `PUT /pins` API, you may see a four-, five-, or six-digit PIN in cases where your cardholders have set a new PIN at an automated teller machine.  [WARNING] Only use this endpoint to access a PIN in order to reveal it to its cardholder. Do not use this endpoint for the purpose of storing a PIN at any location.  Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.  If you want to update a card\'s PIN instead, send a `PUT` request to the `/pins` endpoint. See <</core-api/pins#putPins, Create or Update PIN>> on this page for details.  Revealing a card\'s PIN is a two-step process. You must first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to reveal the PIN.
         * @summary Reveal PIN
         * @param {PinRevealRequest} [pinRevealRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revealPins(pinRevealRequest?: PinRevealRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revealPins(pinRevealRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PINsApi.revealPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PINsApi - factory interface
 */
export const PINsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PINsApiFp(configuration)
    return {
        /**
         * Creates a control token necessary when creating or updating a card\'s personal identification number (PIN).  Creating, updating, or revealing a card\'s PIN is a two-step process. You must first create the control token that is required to create the PIN, and then you create, update, or reveal the PIN itself.  The lifespan of the control token in a production environment is either five minutes or one hour from creation, depending on the token type. If multiple tokens are requested for a single card, only the most recent one is valid. Once redeemed, a token cannot be reused.
         * @summary Create PIN control token
         * @param {ControlTokenRequest} [controlTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPinsControltoken(controlTokenRequest?: ControlTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ControlTokenResponse> {
            return localVarFp.postPinsControltoken(controlTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a personal identification number (PIN) for an existing card. Although cardholders might choose a four-, five-, or six-digit PIN if they set their PIN at an automated teller machine, they can only set a four-digit PIN using Marqeta\'s Set PIN widget or the create or update PIN endpoint (`PUT /pins`). Cardholders can update their PIN through the API regardless of its length, but the new PIN value they choose must contain four digits.  If you want to manage a card\'s PIN, first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to update the PIN. You must create a card before you can manage a PIN.  Unless PIN reveal functionality has been enabled for your program, you cannot retrieve a PIN that has previously been created. If the PIN has been forgotten, you must either update the card\'s PIN or create a new card and PIN.  If you have enabled PIN reveal functionality for your program, you can send a `POST` request to the `/pins/reveal` endpoint to retrieve an existing PIN. See <</core-api/pins#revealPins, Reveal PIN>> on this page for details.  [WARNING] Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.
         * @summary Create or update PIN
         * @param {PinRequest} [pinRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putPins(pinRequest?: PinRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putPins(pinRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reveals the personal identification number (PIN) of an existing, active card. Be aware that while a cardholder can only set a four-digit PIN using the Marqeta Set PIN widget or `PUT /pins` API, you may see a four-, five-, or six-digit PIN in cases where your cardholders have set a new PIN at an automated teller machine.  [WARNING] Only use this endpoint to access a PIN in order to reveal it to its cardholder. Do not use this endpoint for the purpose of storing a PIN at any location.  Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.  If you want to update a card\'s PIN instead, send a `PUT` request to the `/pins` endpoint. See <</core-api/pins#putPins, Create or Update PIN>> on this page for details.  Revealing a card\'s PIN is a two-step process. You must first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to reveal the PIN.
         * @summary Reveal PIN
         * @param {PinRevealRequest} [pinRevealRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revealPins(pinRevealRequest?: PinRevealRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revealPins(pinRevealRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PINsApi - object-oriented interface
 */
export class PINsApi extends BaseAPI {
    /**
     * Creates a control token necessary when creating or updating a card\'s personal identification number (PIN).  Creating, updating, or revealing a card\'s PIN is a two-step process. You must first create the control token that is required to create the PIN, and then you create, update, or reveal the PIN itself.  The lifespan of the control token in a production environment is either five minutes or one hour from creation, depending on the token type. If multiple tokens are requested for a single card, only the most recent one is valid. Once redeemed, a token cannot be reused.
     * @summary Create PIN control token
     * @param {ControlTokenRequest} [controlTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPinsControltoken(controlTokenRequest?: ControlTokenRequest, options?: RawAxiosRequestConfig) {
        return PINsApiFp(this.configuration).postPinsControltoken(controlTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates or updates a personal identification number (PIN) for an existing card. Although cardholders might choose a four-, five-, or six-digit PIN if they set their PIN at an automated teller machine, they can only set a four-digit PIN using Marqeta\'s Set PIN widget or the create or update PIN endpoint (`PUT /pins`). Cardholders can update their PIN through the API regardless of its length, but the new PIN value they choose must contain four digits.  If you want to manage a card\'s PIN, first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to update the PIN. You must create a card before you can manage a PIN.  Unless PIN reveal functionality has been enabled for your program, you cannot retrieve a PIN that has previously been created. If the PIN has been forgotten, you must either update the card\'s PIN or create a new card and PIN.  If you have enabled PIN reveal functionality for your program, you can send a `POST` request to the `/pins/reveal` endpoint to retrieve an existing PIN. See <</core-api/pins#revealPins, Reveal PIN>> on this page for details.  [WARNING] Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.
     * @summary Create or update PIN
     * @param {PinRequest} [pinRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putPins(pinRequest?: PinRequest, options?: RawAxiosRequestConfig) {
        return PINsApiFp(this.configuration).putPins(pinRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reveals the personal identification number (PIN) of an existing, active card. Be aware that while a cardholder can only set a four-digit PIN using the Marqeta Set PIN widget or `PUT /pins` API, you may see a four-, five-, or six-digit PIN in cases where your cardholders have set a new PIN at an automated teller machine.  [WARNING] Only use this endpoint to access a PIN in order to reveal it to its cardholder. Do not use this endpoint for the purpose of storing a PIN at any location.  Sending a request to this endpoint requires PCI DSS compliance. You must comply with PCI DSS data security requirements if you want to store, transmit, or process sensitive card data such as the cardholder\'s primary account number (PAN), personal identification number (PIN), and card expiration date.  If you want to update a card\'s PIN instead, send a `PUT` request to the `/pins` endpoint. See <</core-api/pins#putPins, Create or Update PIN>> on this page for details.  Revealing a card\'s PIN is a two-step process. You must first create a new control token for the card by sending a `POST` request to `/pins/controltoken`, and then use that token to reveal the PIN.
     * @summary Reveal PIN
     * @param {PinRevealRequest} [pinRevealRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revealPins(pinRevealRequest?: PinRevealRequest, options?: RawAxiosRequestConfig) {
        return PINsApiFp(this.configuration).revealPins(pinRevealRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentSchedulesApi - axios parameter creator
 */
export const PaymentSchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new payment schedule, either one-time or recurring.
         * @summary Create payment schedule
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {PaymentScheduleCreateReq} paymentScheduleCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule: async (accountToken: string, paymentScheduleCreateReq: PaymentScheduleCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createPaymentSchedule', 'accountToken', accountToken)
            // verify required parameter 'paymentScheduleCreateReq' is not null or undefined
            assertParamExists('createPaymentSchedule', 'paymentScheduleCreateReq', paymentScheduleCreateReq)
            const localVarPath = `/accounts/{account_token}/paymentschedules`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(paymentScheduleCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transition a payment schedule to a new status.
         * @summary Create payment schedule transition
         * @param {string} accountToken Unique identifier of the credit account on which to transition a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule whose status is to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {PaymentScheduleTransitionCreateReq} paymentScheduleTransitionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentScheduleTransition: async (accountToken: string, paymentScheduleToken: string, paymentScheduleTransitionCreateReq: PaymentScheduleTransitionCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createPaymentScheduleTransition', 'accountToken', accountToken)
            // verify required parameter 'paymentScheduleToken' is not null or undefined
            assertParamExists('createPaymentScheduleTransition', 'paymentScheduleToken', paymentScheduleToken)
            // verify required parameter 'paymentScheduleTransitionCreateReq' is not null or undefined
            assertParamExists('createPaymentScheduleTransition', 'paymentScheduleTransitionCreateReq', paymentScheduleTransitionCreateReq)
            const localVarPath = `/accounts/{account_token}/paymentschedules/{payment_schedule_token}/transitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"payment_schedule_token"}}`, encodeURIComponent(String(paymentScheduleToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(paymentScheduleTransitionCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single payment schedule on a specific credit account.
         * @summary Retrieve payment schedule
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule that you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentSchedule: async (accountToken: string, paymentScheduleToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrievePaymentSchedule', 'accountToken', accountToken)
            // verify required parameter 'paymentScheduleToken' is not null or undefined
            assertParamExists('retrievePaymentSchedule', 'paymentScheduleToken', paymentScheduleToken)
            const localVarPath = `/accounts/{account_token}/paymentschedules/{payment_schedule_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"payment_schedule_token"}}`, encodeURIComponent(String(paymentScheduleToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single payment schedule transition on a specific credit account.
         * @summary Retrieve payment schedule transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a payment schedule transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {string} token Unique identifier of the payment schedule transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules/{payment_schedule_token}/transitions&#x60; to retrieve existing payment schedule transition tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentScheduleTransition: async (accountToken: string, paymentScheduleToken: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrievePaymentScheduleTransition', 'accountToken', accountToken)
            // verify required parameter 'paymentScheduleToken' is not null or undefined
            assertParamExists('retrievePaymentScheduleTransition', 'paymentScheduleToken', paymentScheduleToken)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrievePaymentScheduleTransition', 'token', token)
            const localVarPath = `/accounts/{account_token}/paymentschedules/{payment_schedule_token}/transitions/{token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"payment_schedule_token"}}`, encodeURIComponent(String(paymentScheduleToken)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of payment schedule transitions on a specific credit account.
         * @summary Retrieve payment schedule transitions
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve payment schedule transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule for which you want to retrieve transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {number} [count] Number of payment schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrievePaymentScheduleTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentScheduleTransitions: async (accountToken: string, paymentScheduleToken: string, count?: number, startIndex?: number, sortBy?: RetrievePaymentScheduleTransitionsSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrievePaymentScheduleTransitions', 'accountToken', accountToken)
            // verify required parameter 'paymentScheduleToken' is not null or undefined
            assertParamExists('retrievePaymentScheduleTransitions', 'paymentScheduleToken', paymentScheduleToken)
            const localVarPath = `/accounts/{account_token}/paymentschedules/{payment_schedule_token}/transitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"payment_schedule_token"}}`, encodeURIComponent(String(paymentScheduleToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of payment schedules on a specific credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List payment schedules
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve payment schedules.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {Array<PaymentScheduleStatus>} [statuses] Status of the payment schedules to retrieve.
         * @param {Array<PaymentScheduleFrequency>} [frequency] Frequency of the payment schedules to retrieve.
         * @param {number} [count] Number of payment schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrievePaymentSchedulesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentSchedules: async (accountToken: string, statuses?: Array<PaymentScheduleStatus>, frequency?: Array<PaymentScheduleFrequency>, count?: number, startIndex?: number, sortBy?: RetrievePaymentSchedulesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrievePaymentSchedules', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/paymentschedules`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (frequency) {
                localVarQueryParameter['frequency'] = frequency;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSchedulesApi - functional programming interface
 */
export const PaymentSchedulesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentSchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new payment schedule, either one-time or recurring.
         * @summary Create payment schedule
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {PaymentScheduleCreateReq} paymentScheduleCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentSchedule(accountToken: string, paymentScheduleCreateReq: PaymentScheduleCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentSchedule(accountToken, paymentScheduleCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSchedulesApi.createPaymentSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transition a payment schedule to a new status.
         * @summary Create payment schedule transition
         * @param {string} accountToken Unique identifier of the credit account on which to transition a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule whose status is to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {PaymentScheduleTransitionCreateReq} paymentScheduleTransitionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentScheduleTransition(accountToken: string, paymentScheduleToken: string, paymentScheduleTransitionCreateReq: PaymentScheduleTransitionCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentScheduleTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentScheduleTransition(accountToken, paymentScheduleToken, paymentScheduleTransitionCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSchedulesApi.createPaymentScheduleTransition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single payment schedule on a specific credit account.
         * @summary Retrieve payment schedule
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule that you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePaymentSchedule(accountToken: string, paymentScheduleToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePaymentSchedule(accountToken, paymentScheduleToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSchedulesApi.retrievePaymentSchedule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a single payment schedule transition on a specific credit account.
         * @summary Retrieve payment schedule transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a payment schedule transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {string} token Unique identifier of the payment schedule transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules/{payment_schedule_token}/transitions&#x60; to retrieve existing payment schedule transition tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePaymentScheduleTransition(accountToken: string, paymentScheduleToken: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentScheduleTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePaymentScheduleTransition(accountToken, paymentScheduleToken, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSchedulesApi.retrievePaymentScheduleTransition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of payment schedule transitions on a specific credit account.
         * @summary Retrieve payment schedule transitions
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve payment schedule transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule for which you want to retrieve transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {number} [count] Number of payment schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrievePaymentScheduleTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePaymentScheduleTransitions(accountToken: string, paymentScheduleToken: string, count?: number, startIndex?: number, sortBy?: RetrievePaymentScheduleTransitionsSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentScheduleTransitionPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePaymentScheduleTransitions(accountToken, paymentScheduleToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSchedulesApi.retrievePaymentScheduleTransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of payment schedules on a specific credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List payment schedules
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve payment schedules.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {Array<PaymentScheduleStatus>} [statuses] Status of the payment schedules to retrieve.
         * @param {Array<PaymentScheduleFrequency>} [frequency] Frequency of the payment schedules to retrieve.
         * @param {number} [count] Number of payment schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrievePaymentSchedulesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePaymentSchedules(accountToken: string, statuses?: Array<PaymentScheduleStatus>, frequency?: Array<PaymentScheduleFrequency>, count?: number, startIndex?: number, sortBy?: RetrievePaymentSchedulesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSchedulePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePaymentSchedules(accountToken, statuses, frequency, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSchedulesApi.retrievePaymentSchedules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentSchedulesApi - factory interface
 */
export const PaymentSchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentSchedulesApiFp(configuration)
    return {
        /**
         * Create a new payment schedule, either one-time or recurring.
         * @summary Create payment schedule
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {PaymentScheduleCreateReq} paymentScheduleCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSchedule(accountToken: string, paymentScheduleCreateReq: PaymentScheduleCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<PaymentScheduleResponse> {
            return localVarFp.createPaymentSchedule(accountToken, paymentScheduleCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Transition a payment schedule to a new status.
         * @summary Create payment schedule transition
         * @param {string} accountToken Unique identifier of the credit account on which to transition a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule whose status is to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {PaymentScheduleTransitionCreateReq} paymentScheduleTransitionCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentScheduleTransition(accountToken: string, paymentScheduleToken: string, paymentScheduleTransitionCreateReq: PaymentScheduleTransitionCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<PaymentScheduleTransitionResponse> {
            return localVarFp.createPaymentScheduleTransition(accountToken, paymentScheduleToken, paymentScheduleTransitionCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single payment schedule on a specific credit account.
         * @summary Retrieve payment schedule
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule that you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentSchedule(accountToken: string, paymentScheduleToken: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentScheduleResponse> {
            return localVarFp.retrievePaymentSchedule(accountToken, paymentScheduleToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single payment schedule transition on a specific credit account.
         * @summary Retrieve payment schedule transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a payment schedule transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {string} token Unique identifier of the payment schedule transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules/{payment_schedule_token}/transitions&#x60; to retrieve existing payment schedule transition tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentScheduleTransition(accountToken: string, paymentScheduleToken: string, token: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentScheduleTransitionResponse> {
            return localVarFp.retrievePaymentScheduleTransition(accountToken, paymentScheduleToken, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of payment schedule transitions on a specific credit account.
         * @summary Retrieve payment schedule transitions
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve payment schedule transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentScheduleToken Unique identifier of the payment schedule for which you want to retrieve transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
         * @param {number} [count] Number of payment schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrievePaymentScheduleTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentScheduleTransitions(accountToken: string, paymentScheduleToken: string, count?: number, startIndex?: number, sortBy?: RetrievePaymentScheduleTransitionsSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaymentScheduleTransitionPage> {
            return localVarFp.retrievePaymentScheduleTransitions(accountToken, paymentScheduleToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of payment schedules on a specific credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List payment schedules
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve payment schedules.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {Array<PaymentScheduleStatus>} [statuses] Status of the payment schedules to retrieve.
         * @param {Array<PaymentScheduleFrequency>} [frequency] Frequency of the payment schedules to retrieve.
         * @param {number} [count] Number of payment schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {RetrievePaymentSchedulesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentSchedules(accountToken: string, statuses?: Array<PaymentScheduleStatus>, frequency?: Array<PaymentScheduleFrequency>, count?: number, startIndex?: number, sortBy?: RetrievePaymentSchedulesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaymentSchedulePage> {
            return localVarFp.retrievePaymentSchedules(accountToken, statuses, frequency, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentSchedulesApi - object-oriented interface
 */
export class PaymentSchedulesApi extends BaseAPI {
    /**
     * Create a new payment schedule, either one-time or recurring.
     * @summary Create payment schedule
     * @param {string} accountToken Unique identifier of the credit account for which you want to create a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {PaymentScheduleCreateReq} paymentScheduleCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPaymentSchedule(accountToken: string, paymentScheduleCreateReq: PaymentScheduleCreateReq, options?: RawAxiosRequestConfig) {
        return PaymentSchedulesApiFp(this.configuration).createPaymentSchedule(accountToken, paymentScheduleCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transition a payment schedule to a new status.
     * @summary Create payment schedule transition
     * @param {string} accountToken Unique identifier of the credit account on which to transition a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} paymentScheduleToken Unique identifier of the payment schedule whose status is to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
     * @param {PaymentScheduleTransitionCreateReq} paymentScheduleTransitionCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPaymentScheduleTransition(accountToken: string, paymentScheduleToken: string, paymentScheduleTransitionCreateReq: PaymentScheduleTransitionCreateReq, options?: RawAxiosRequestConfig) {
        return PaymentSchedulesApiFp(this.configuration).createPaymentScheduleTransition(accountToken, paymentScheduleToken, paymentScheduleTransitionCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single payment schedule on a specific credit account.
     * @summary Retrieve payment schedule
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a payment schedule.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} paymentScheduleToken Unique identifier of the payment schedule that you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrievePaymentSchedule(accountToken: string, paymentScheduleToken: string, options?: RawAxiosRequestConfig) {
        return PaymentSchedulesApiFp(this.configuration).retrievePaymentSchedule(accountToken, paymentScheduleToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single payment schedule transition on a specific credit account.
     * @summary Retrieve payment schedule transition
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a payment schedule transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} paymentScheduleToken Unique identifier of the payment schedule you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
     * @param {string} token Unique identifier of the payment schedule transition you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules/{payment_schedule_token}/transitions&#x60; to retrieve existing payment schedule transition tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrievePaymentScheduleTransition(accountToken: string, paymentScheduleToken: string, token: string, options?: RawAxiosRequestConfig) {
        return PaymentSchedulesApiFp(this.configuration).retrievePaymentScheduleTransition(accountToken, paymentScheduleToken, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of payment schedule transitions on a specific credit account.
     * @summary Retrieve payment schedule transitions
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve payment schedule transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} paymentScheduleToken Unique identifier of the payment schedule for which you want to retrieve transitions.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/paymentschedules&#x60; to retrieve existing payment schedule tokens.
     * @param {number} [count] Number of payment schedule resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {RetrievePaymentScheduleTransitionsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrievePaymentScheduleTransitions(accountToken: string, paymentScheduleToken: string, count?: number, startIndex?: number, sortBy?: RetrievePaymentScheduleTransitionsSortByEnum, options?: RawAxiosRequestConfig) {
        return PaymentSchedulesApiFp(this.configuration).retrievePaymentScheduleTransitions(accountToken, paymentScheduleToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of payment schedules on a specific credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List payment schedules
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve payment schedules.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {Array<PaymentScheduleStatus>} [statuses] Status of the payment schedules to retrieve.
     * @param {Array<PaymentScheduleFrequency>} [frequency] Frequency of the payment schedules to retrieve.
     * @param {number} [count] Number of payment schedule resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {RetrievePaymentSchedulesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrievePaymentSchedules(accountToken: string, statuses?: Array<PaymentScheduleStatus>, frequency?: Array<PaymentScheduleFrequency>, count?: number, startIndex?: number, sortBy?: RetrievePaymentSchedulesSortByEnum, options?: RawAxiosRequestConfig) {
        return PaymentSchedulesApiFp(this.configuration).retrievePaymentSchedules(accountToken, statuses, frequency, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}

export const RetrievePaymentScheduleTransitionsSortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime'
} as const;
export type RetrievePaymentScheduleTransitionsSortByEnum = typeof RetrievePaymentScheduleTransitionsSortByEnum[keyof typeof RetrievePaymentScheduleTransitionsSortByEnum];
export const RetrievePaymentSchedulesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type RetrievePaymentSchedulesSortByEnum = typeof RetrievePaymentSchedulesSortByEnum[keyof typeof RetrievePaymentSchedulesSortByEnum];


/**
 * PaymentSourcesApi - axios parameter creator
 */
export const PaymentSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a payment source from which to make payments.
         * @summary Create payment source
         * @param {PaymentSourceCreateReq} paymentSourceCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSource: async (paymentSourceCreateReq: PaymentSourceCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentSourceCreateReq' is not null or undefined
            assertParamExists('createPaymentSource', 'paymentSourceCreateReq', paymentSourceCreateReq)
            const localVarPath = `/paymentsources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(paymentSourceCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of payment sources.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List payment sources
         * @param {string} [accountToken] Unique identifier of the credit account associated with the payment source.
         * @param {string} [userToken] Unique identifier of the user associated with the payment source.
         * @param {string} [businessToken] Unique identifier of the business associated with the payment source.
         * @param {number} [count] Number of payment source resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListPaymentSourcesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<PaymentSourceStatusEnum>} [statuses] Array of statuses to use for filtering payment sources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentSources: async (accountToken?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, sortBy?: ListPaymentSourcesSortByEnum, statuses?: Array<PaymentSourceStatusEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/paymentsources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (accountToken !== undefined) {
                localVarQueryParameter['account_token'] = accountToken;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a payment source.
         * @summary Retrieve payment source
         * @param {string} token Unique identifier of the payment source to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/paymentsources&#x60; to retrieve existing payment source tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentSource: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrievePaymentSource', 'token', token)
            const localVarPath = `/paymentsources/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update details of a payment source.
         * @summary Update payment source
         * @param {string} token Unique identifier of the payment source to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/paymentsources&#x60; to retrieve existing payment source tokens.
         * @param {PaymentSourceUpdateReq} paymentSourceUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSource: async (token: string, paymentSourceUpdateReq: PaymentSourceUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updatePaymentSource', 'token', token)
            // verify required parameter 'paymentSourceUpdateReq' is not null or undefined
            assertParamExists('updatePaymentSource', 'paymentSourceUpdateReq', paymentSourceUpdateReq)
            const localVarPath = `/paymentsources/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(paymentSourceUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentSourcesApi - functional programming interface
 */
export const PaymentSourcesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentSourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a payment source from which to make payments.
         * @summary Create payment source
         * @param {PaymentSourceCreateReq} paymentSourceCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPaymentSource(paymentSourceCreateReq: PaymentSourceCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPaymentSource(paymentSourceCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSourcesApi.createPaymentSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of payment sources.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List payment sources
         * @param {string} [accountToken] Unique identifier of the credit account associated with the payment source.
         * @param {string} [userToken] Unique identifier of the user associated with the payment source.
         * @param {string} [businessToken] Unique identifier of the business associated with the payment source.
         * @param {number} [count] Number of payment source resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListPaymentSourcesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<PaymentSourceStatusEnum>} [statuses] Array of statuses to use for filtering payment sources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPaymentSources(accountToken?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, sortBy?: ListPaymentSourcesSortByEnum, statuses?: Array<PaymentSourceStatusEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSourcePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPaymentSources(accountToken, userToken, businessToken, count, startIndex, sortBy, statuses, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSourcesApi.listPaymentSources']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a payment source.
         * @summary Retrieve payment source
         * @param {string} token Unique identifier of the payment source to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/paymentsources&#x60; to retrieve existing payment source tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePaymentSource(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePaymentSource(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSourcesApi.retrievePaymentSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update details of a payment source.
         * @summary Update payment source
         * @param {string} token Unique identifier of the payment source to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/paymentsources&#x60; to retrieve existing payment source tokens.
         * @param {PaymentSourceUpdateReq} paymentSourceUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentSource(token: string, paymentSourceUpdateReq: PaymentSourceUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentSource(token, paymentSourceUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentSourcesApi.updatePaymentSource']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentSourcesApi - factory interface
 */
export const PaymentSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentSourcesApiFp(configuration)
    return {
        /**
         * Create a payment source from which to make payments.
         * @summary Create payment source
         * @param {PaymentSourceCreateReq} paymentSourceCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentSource(paymentSourceCreateReq: PaymentSourceCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<PaymentSourceResponse> {
            return localVarFp.createPaymentSource(paymentSourceCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of payment sources.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List payment sources
         * @param {string} [accountToken] Unique identifier of the credit account associated with the payment source.
         * @param {string} [userToken] Unique identifier of the user associated with the payment source.
         * @param {string} [businessToken] Unique identifier of the business associated with the payment source.
         * @param {number} [count] Number of payment source resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListPaymentSourcesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<PaymentSourceStatusEnum>} [statuses] Array of statuses to use for filtering payment sources.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaymentSources(accountToken?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, sortBy?: ListPaymentSourcesSortByEnum, statuses?: Array<PaymentSourceStatusEnum>, options?: RawAxiosRequestConfig): AxiosPromise<PaymentSourcePage> {
            return localVarFp.listPaymentSources(accountToken, userToken, businessToken, count, startIndex, sortBy, statuses, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a payment source.
         * @summary Retrieve payment source
         * @param {string} token Unique identifier of the payment source to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/paymentsources&#x60; to retrieve existing payment source tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePaymentSource(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentSourceResponse> {
            return localVarFp.retrievePaymentSource(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Update details of a payment source.
         * @summary Update payment source
         * @param {string} token Unique identifier of the payment source to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/paymentsources&#x60; to retrieve existing payment source tokens.
         * @param {PaymentSourceUpdateReq} paymentSourceUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentSource(token: string, paymentSourceUpdateReq: PaymentSourceUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<PaymentSourceResponse> {
            return localVarFp.updatePaymentSource(token, paymentSourceUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentSourcesApi - object-oriented interface
 */
export class PaymentSourcesApi extends BaseAPI {
    /**
     * Create a payment source from which to make payments.
     * @summary Create payment source
     * @param {PaymentSourceCreateReq} paymentSourceCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPaymentSource(paymentSourceCreateReq: PaymentSourceCreateReq, options?: RawAxiosRequestConfig) {
        return PaymentSourcesApiFp(this.configuration).createPaymentSource(paymentSourceCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of payment sources.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List payment sources
     * @param {string} [accountToken] Unique identifier of the credit account associated with the payment source.
     * @param {string} [userToken] Unique identifier of the user associated with the payment source.
     * @param {string} [businessToken] Unique identifier of the business associated with the payment source.
     * @param {number} [count] Number of payment source resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListPaymentSourcesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {Array<PaymentSourceStatusEnum>} [statuses] Array of statuses to use for filtering payment sources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPaymentSources(accountToken?: string, userToken?: string, businessToken?: string, count?: number, startIndex?: number, sortBy?: ListPaymentSourcesSortByEnum, statuses?: Array<PaymentSourceStatusEnum>, options?: RawAxiosRequestConfig) {
        return PaymentSourcesApiFp(this.configuration).listPaymentSources(accountToken, userToken, businessToken, count, startIndex, sortBy, statuses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a payment source.
     * @summary Retrieve payment source
     * @param {string} token Unique identifier of the payment source to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/paymentsources&#x60; to retrieve existing payment source tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrievePaymentSource(token: string, options?: RawAxiosRequestConfig) {
        return PaymentSourcesApiFp(this.configuration).retrievePaymentSource(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update details of a payment source.
     * @summary Update payment source
     * @param {string} token Unique identifier of the payment source to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/paymentsources&#x60; to retrieve existing payment source tokens.
     * @param {PaymentSourceUpdateReq} paymentSourceUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updatePaymentSource(token: string, paymentSourceUpdateReq: PaymentSourceUpdateReq, options?: RawAxiosRequestConfig) {
        return PaymentSourcesApiFp(this.configuration).updatePaymentSource(token, paymentSourceUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListPaymentSourcesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListPaymentSourcesSortByEnum = typeof ListPaymentSourcesSortByEnum[keyof typeof ListPaymentSourcesSortByEnum];


/**
 * PaymentsApi - axios parameter creator
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new payment to apply toward a credit account\'s balance.
         * @summary Create account payment
         * @param {string} accountToken Unique identifier of the credit account for which to create a payment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {PaymentCreateReq} paymentCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: async (accountToken: string, paymentCreateReq: PaymentCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('createPayment', 'accountToken', accountToken)
            // verify required parameter 'paymentCreateReq' is not null or undefined
            assertParamExists('createPayment', 'paymentCreateReq', paymentCreateReq)
            const localVarPath = `/accounts/{account_token}/payments`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(paymentCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of payments on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account payments
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve payments.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Beginning of the date range of the payments to return.
         * @param {string} [endDate] End of the date range of the payments to return.
         * @param {number} [count] Number of account payments resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListPaymentsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<PaymentStatus>} [statuses] Array of statuses by which to filter payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: async (accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: ListPaymentsSortByEnum, statuses?: Array<PaymentStatus>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('listPayments', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/payments`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0, 10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0, 10) :
                    endDate;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Manually release a payment hold on a credit account.
         * @summary Release payment hold
         * @param {string} accountToken Unique identifier of the credit account on which a payment hold is being released.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment currently on hold.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments&#x60; to retrieve existing payment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePaymentHold: async (accountToken: string, paymentToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('releasePaymentHold', 'accountToken', accountToken)
            // verify required parameter 'paymentToken' is not null or undefined
            assertParamExists('releasePaymentHold', 'paymentToken', paymentToken)
            const localVarPath = `/accounts/{account_token}/payments/{payment_token}/releasehold`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"payment_token"}}`, encodeURIComponent(String(paymentToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent: async (eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('resendWebhookEvent', 'eventType', eventType)
            // verify required parameter 'resourceToken' is not null or undefined
            assertParamExists('resendWebhookEvent', 'resourceToken', resourceToken)
            const localVarPath = `/webhooks/{event_type}/{resource_token}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"resource_token"}}`, encodeURIComponent(String(resourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a payment for a credit account.
         * @summary Retrieve account payment
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a payment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/payments&#x60; to retrieve existing payment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment: async (accountToken: string, paymentToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrievePayment', 'accountToken', accountToken)
            // verify required parameter 'paymentToken' is not null or undefined
            assertParamExists('retrievePayment', 'paymentToken', paymentToken)
            const localVarPath = `/accounts/{account_token}/payments/{payment_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"payment_token"}}`, encodeURIComponent(String(paymentToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Transition a credit account payment\'s status to a new status.
         * @summary Transition account payment status
         * @param {string} accountToken Unique identifier of the credit account for which you want to transition a payment status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment whose status you want to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments&#x60; endpoint to retrieve existing payment tokens for a given account.
         * @param {PaymentTransitionReq} paymentTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionPayment: async (accountToken: string, paymentToken: string, paymentTransitionReq: PaymentTransitionReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('transitionPayment', 'accountToken', accountToken)
            // verify required parameter 'paymentToken' is not null or undefined
            assertParamExists('transitionPayment', 'paymentToken', paymentToken)
            // verify required parameter 'paymentTransitionReq' is not null or undefined
            assertParamExists('transitionPayment', 'paymentTransitionReq', paymentTransitionReq)
            const localVarPath = `/accounts/{account_token}/payments/{payment_token}/transitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"payment_token"}}`, encodeURIComponent(String(paymentToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(paymentTransitionReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 */
export const PaymentsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new payment to apply toward a credit account\'s balance.
         * @summary Create account payment
         * @param {string} accountToken Unique identifier of the credit account for which to create a payment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {PaymentCreateReq} paymentCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPayment(accountToken: string, paymentCreateReq: PaymentCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayment(accountToken, paymentCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.createPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of payments on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account payments
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve payments.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Beginning of the date range of the payments to return.
         * @param {string} [endDate] End of the date range of the payments to return.
         * @param {number} [count] Number of account payments resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListPaymentsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<PaymentStatus>} [statuses] Array of statuses by which to filter payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPayments(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: ListPaymentsSortByEnum, statuses?: Array<PaymentStatus>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayments(accountToken, startDate, endDate, count, startIndex, sortBy, statuses, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.listPayments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Manually release a payment hold on a credit account.
         * @summary Release payment hold
         * @param {string} accountToken Unique identifier of the credit account on which a payment hold is being released.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment currently on hold.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments&#x60; to retrieve existing payment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async releasePaymentHold(accountToken: string, paymentToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.releasePaymentHold(accountToken, paymentToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.releasePaymentHold']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResendContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhookEvent(eventType, resourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.resendWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a payment for a credit account.
         * @summary Retrieve account payment
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a payment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/payments&#x60; to retrieve existing payment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePayment(accountToken: string, paymentToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePayment(accountToken, paymentToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.retrievePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Transition a credit account payment\'s status to a new status.
         * @summary Transition account payment status
         * @param {string} accountToken Unique identifier of the credit account for which you want to transition a payment status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment whose status you want to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments&#x60; endpoint to retrieve existing payment tokens for a given account.
         * @param {PaymentTransitionReq} paymentTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transitionPayment(accountToken: string, paymentToken: string, paymentTransitionReq: PaymentTransitionReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transitionPayment(accountToken, paymentToken, paymentTransitionReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.transitionPayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Create a new payment to apply toward a credit account\'s balance.
         * @summary Create account payment
         * @param {string} accountToken Unique identifier of the credit account for which to create a payment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {PaymentCreateReq} paymentCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(accountToken: string, paymentCreateReq: PaymentCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<PaymentDetailResponse> {
            return localVarFp.createPayment(accountToken, paymentCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of payments on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List account payments
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve payments.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Beginning of the date range of the payments to return.
         * @param {string} [endDate] End of the date range of the payments to return.
         * @param {number} [count] Number of account payments resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListPaymentsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {Array<PaymentStatus>} [statuses] Array of statuses by which to filter payments.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: ListPaymentsSortByEnum, statuses?: Array<PaymentStatus>, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPage> {
            return localVarFp.listPayments(accountToken, startDate, endDate, count, startIndex, sortBy, statuses, options).then((request) => request(axios, basePath));
        },
        /**
         * Manually release a payment hold on a credit account.
         * @summary Release payment hold
         * @param {string} accountToken Unique identifier of the credit account on which a payment hold is being released.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment currently on hold.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments&#x60; to retrieve existing payment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        releasePaymentHold(accountToken: string, paymentToken: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentDetailResponse> {
            return localVarFp.releasePaymentHold(accountToken, paymentToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResendContainerResponse> {
            return localVarFp.resendWebhookEvent(eventType, resourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a payment for a credit account.
         * @summary Retrieve account payment
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve a payment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/payments&#x60; to retrieve existing payment tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePayment(accountToken: string, paymentToken: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentDetailResponse> {
            return localVarFp.retrievePayment(accountToken, paymentToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Transition a credit account payment\'s status to a new status.
         * @summary Transition account payment status
         * @param {string} accountToken Unique identifier of the credit account for which you want to transition a payment status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} paymentToken Unique identifier of the payment whose status you want to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments&#x60; endpoint to retrieve existing payment tokens for a given account.
         * @param {PaymentTransitionReq} paymentTransitionReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transitionPayment(accountToken: string, paymentToken: string, paymentTransitionReq: PaymentTransitionReq, options?: RawAxiosRequestConfig): AxiosPromise<PaymentTransitionResponse> {
            return localVarFp.transitionPayment(accountToken, paymentToken, paymentTransitionReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Create a new payment to apply toward a credit account\'s balance.
     * @summary Create account payment
     * @param {string} accountToken Unique identifier of the credit account for which to create a payment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {PaymentCreateReq} paymentCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createPayment(accountToken: string, paymentCreateReq: PaymentCreateReq, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).createPayment(accountToken, paymentCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of payments on a credit account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List account payments
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve payments.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} [startDate] Beginning of the date range of the payments to return.
     * @param {string} [endDate] End of the date range of the payments to return.
     * @param {number} [count] Number of account payments resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListPaymentsSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {Array<PaymentStatus>} [statuses] Array of statuses by which to filter payments.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listPayments(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: ListPaymentsSortByEnum, statuses?: Array<PaymentStatus>, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).listPayments(accountToken, startDate, endDate, count, startIndex, sortBy, statuses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Manually release a payment hold on a credit account.
     * @summary Release payment hold
     * @param {string} accountToken Unique identifier of the credit account on which a payment hold is being released.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} paymentToken Unique identifier of the payment currently on hold.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments&#x60; to retrieve existing payment tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public releasePaymentHold(accountToken: string, paymentToken: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).releasePaymentHold(accountToken, paymentToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
     * @summary Resend credit event notification
     * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).resendWebhookEvent(eventType, resourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a payment for a credit account.
     * @summary Retrieve account payment
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve a payment.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} paymentToken Unique identifier of the payment to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/payments&#x60; to retrieve existing payment tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrievePayment(accountToken: string, paymentToken: string, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).retrievePayment(accountToken, paymentToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Transition a credit account payment\'s status to a new status.
     * @summary Transition account payment status
     * @param {string} accountToken Unique identifier of the credit account for which you want to transition a payment status.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} paymentToken Unique identifier of the payment whose status you want to transition.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments&#x60; endpoint to retrieve existing payment tokens for a given account.
     * @param {PaymentTransitionReq} paymentTransitionReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public transitionPayment(accountToken: string, paymentToken: string, paymentTransitionReq: PaymentTransitionReq, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).transitionPayment(accountToken, paymentToken, paymentTransitionReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListPaymentsSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListPaymentsSortByEnum = typeof ListPaymentsSortByEnum[keyof typeof ListPaymentsSortByEnum];



/**
 * PeerTransfersApi - axios parameter creator
 */
export const PeerTransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns details of a previous transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getPeertransfersToken', 'token', token)
            const localVarPath = `/peertransfers/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstoken: async (userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            assertParamExists('getPeertransfersUserUserorbusinesstoken', 'userOrBusinessToken', userOrBusinessToken)
            const localVarPath = `/peertransfers/user/{user_or_business_token}`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns received peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenRecipient: async (userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            assertParamExists('getPeertransfersUserUserorbusinesstokenRecipient', 'userOrBusinessToken', userOrBusinessToken)
            const localVarPath = `/peertransfers/user/{user_or_business_token}/recipient`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns sent peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenSender: async (userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userOrBusinessToken' is not null or undefined
            assertParamExists('getPeertransfersUserUserorbusinesstokenSender', 'userOrBusinessToken', userOrBusinessToken)
            const localVarPath = `/peertransfers/user/{user_or_business_token}/sender`
                .replace(`{${"user_or_business_token"}}`, encodeURIComponent(String(userOrBusinessToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Performs a peer transfer from one user to another
         * @param {PeerTransferRequest} [peerTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPeertransfers: async (peerTransferRequest?: PeerTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/peertransfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(peerTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeerTransfersApi - functional programming interface
 */
export const PeerTransfersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PeerTransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns details of a previous transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeertransfersToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeerTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeertransfersToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeerTransfersApi.getPeertransfersToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeertransfersUserUserorbusinesstoken(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeerTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeertransfersUserUserorbusinesstoken(userOrBusinessToken, count, startIndex, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeerTransfersApi.getPeertransfersUserUserorbusinesstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns received peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeerTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken, count, startIndex, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeerTransfersApi.getPeertransfersUserUserorbusinesstokenRecipient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns sent peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeerTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken, count, startIndex, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeerTransfersApi.getPeertransfersUserUserorbusinesstokenSender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Performs a peer transfer from one user to another
         * @param {PeerTransferRequest} [peerTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPeertransfers(peerTransferRequest?: PeerTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PeerTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPeertransfers(peerTransferRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PeerTransfersApi.postPeertransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PeerTransfersApi - factory interface
 */
export const PeerTransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeerTransfersApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns details of a previous transfer
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PeerTransferResponse> {
            return localVarFp.getPeertransfersToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstoken(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<PeerTransferResponse> {
            return localVarFp.getPeertransfersUserUserorbusinesstoken(userOrBusinessToken, count, startIndex, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns received peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<PeerTransferResponse> {
            return localVarFp.getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken, count, startIndex, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns sent peer transfers for a user
         * @param {string} userOrBusinessToken User or business token
         * @param {number} [count] Number of transfers to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<PeerTransferResponse> {
            return localVarFp.getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken, count, startIndex, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Performs a peer transfer from one user to another
         * @param {PeerTransferRequest} [peerTransferRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPeertransfers(peerTransferRequest?: PeerTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<PeerTransferResponse> {
            return localVarFp.postPeertransfers(peerTransferRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeerTransfersApi - object-oriented interface
 */
export class PeerTransfersApi extends BaseAPI {
    /**
     * 
     * @summary Returns details of a previous transfer
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPeertransfersToken(token: string, options?: RawAxiosRequestConfig) {
        return PeerTransfersApiFp(this.configuration).getPeertransfersToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all peer transfers for a user
     * @param {string} userOrBusinessToken User or business token
     * @param {number} [count] Number of transfers to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPeertransfersUserUserorbusinesstoken(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig) {
        return PeerTransfersApiFp(this.configuration).getPeertransfersUserUserorbusinesstoken(userOrBusinessToken, count, startIndex, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns received peer transfers for a user
     * @param {string} userOrBusinessToken User or business token
     * @param {number} [count] Number of transfers to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig) {
        return PeerTransfersApiFp(this.configuration).getPeertransfersUserUserorbusinesstokenRecipient(userOrBusinessToken, count, startIndex, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns sent peer transfers for a user
     * @param {string} userOrBusinessToken User or business token
     * @param {number} [count] Number of transfers to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken: string, count?: number, startIndex?: number, fields?: string, options?: RawAxiosRequestConfig) {
        return PeerTransfersApiFp(this.configuration).getPeertransfersUserUserorbusinesstokenSender(userOrBusinessToken, count, startIndex, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Performs a peer transfer from one user to another
     * @param {PeerTransferRequest} [peerTransferRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPeertransfers(peerTransferRequest?: PeerTransferRequest, options?: RawAxiosRequestConfig) {
        return PeerTransfersApiFp(this.configuration).postPeertransfers(peerTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PingApi - axios parameter creator
 */
export const PingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Tests if the Marqeta server is available and responsive.
         * @summary Returns a heartbeat to the consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPing: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Echo test for sending payload to server
         * @param {EchoPingRequest} [echoPingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPing: async (echoPingRequest?: EchoPingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(echoPingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PingApi - functional programming interface
 */
export const PingApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PingApiAxiosParamCreator(configuration)
    return {
        /**
         * Tests if the Marqeta server is available and responsive.
         * @summary Returns a heartbeat to the consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPing(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPing(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PingApi.getPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Echo test for sending payload to server
         * @param {EchoPingRequest} [echoPingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPing(echoPingRequest?: EchoPingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EchoPingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPing(echoPingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PingApi.postPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PingApi - factory interface
 */
export const PingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PingApiFp(configuration)
    return {
        /**
         * Tests if the Marqeta server is available and responsive.
         * @summary Returns a heartbeat to the consumer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPing(options?: RawAxiosRequestConfig): AxiosPromise<PingResponse> {
            return localVarFp.getPing(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Echo test for sending payload to server
         * @param {EchoPingRequest} [echoPingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPing(echoPingRequest?: EchoPingRequest, options?: RawAxiosRequestConfig): AxiosPromise<EchoPingResponse> {
            return localVarFp.postPing(echoPingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PingApi - object-oriented interface
 */
export class PingApi extends BaseAPI {
    /**
     * Tests if the Marqeta server is available and responsive.
     * @summary Returns a heartbeat to the consumer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPing(options?: RawAxiosRequestConfig) {
        return PingApiFp(this.configuration).getPing(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Echo test for sending payload to server
     * @param {EchoPingRequest} [echoPingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPing(echoPingRequest?: EchoPingRequest, options?: RawAxiosRequestConfig) {
        return PingApiFp(this.configuration).postPing(echoPingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PoliciesApi - axios parameter creator
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new annual percentage rate (APR) policy based on an existing APR policy.
         * @summary Clone APR policy
         * @param {string} token Unique identifier of the APR policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneAprPolicy: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('cloneAprPolicy', 'token', token)
            const localVarPath = `/policies/aprs/{token}/clone`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document policy based on an existing document policy. A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Clone document policy
         * @param {string} token Unique identifier of the document policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDocumentPolicy: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('cloneDocumentPolicy', 'token', token)
            const localVarPath = `/policies/documents/{token}/clone`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new fee policy based on an existing fee policy.
         * @summary Clone fee policy
         * @param {string} token Unique identifier of the fee policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneFeePolicy: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('cloneFeePolicy', 'token', token)
            const localVarPath = `/policies/fees/{token}/clone`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new credit product policy based on an existing credit product policy.
         * @summary Clone credit product policy
         * @param {string} token Unique identifier of the credit product policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneProductPolicy: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('cloneProductPolicy', 'token', token)
            const localVarPath = `/policies/products/{token}/clone`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new reward policy based on existing reward policy.
         * @summary Clone reward policy
         * @param {string} token Unique identifier of the reward policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneRewardPolicy: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('cloneRewardPolicy', 'token', token)
            const localVarPath = `/policies/rewards/{token}/clone`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new annual percentage rate (APR) policy.
         * @summary Create APR policy
         * @param {PolicyAprCreateReq} policyAprCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAprPolicy: async (policyAprCreateReq: PolicyAprCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyAprCreateReq' is not null or undefined
            assertParamExists('createAprPolicy', 'policyAprCreateReq', policyAprCreateReq)
            const localVarPath = `/policies/aprs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyAprCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Create document policy
         * @param {PolicyDocumentCreateReq} policyDocumentCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentPolicy: async (policyDocumentCreateReq: PolicyDocumentCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyDocumentCreateReq' is not null or undefined
            assertParamExists('createDocumentPolicy', 'policyDocumentCreateReq', policyDocumentCreateReq)
            const localVarPath = `/policies/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyDocumentCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new fee policy.
         * @summary Create fee policy
         * @param {PolicyFeeCreateReq} policyFeeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeePolicy: async (policyFeeCreateReq: PolicyFeeCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyFeeCreateReq' is not null or undefined
            assertParamExists('createFeePolicy', 'policyFeeCreateReq', policyFeeCreateReq)
            const localVarPath = `/policies/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyFeeCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new credit product policy.
         * @summary Create credit product policy
         * @param {PolicyProductCreateReq} policyProductCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductPolicy: async (policyProductCreateReq: PolicyProductCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyProductCreateReq' is not null or undefined
            assertParamExists('createProductPolicy', 'policyProductCreateReq', policyProductCreateReq)
            const localVarPath = `/policies/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyProductCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new reward policy.
         * @summary Create reward policy
         * @param {PolicyRewardReq} policyRewardReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewardPolicy: async (policyRewardReq: PolicyRewardReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyRewardReq' is not null or undefined
            assertParamExists('createRewardPolicy', 'policyRewardReq', policyRewardReq)
            const localVarPath = `/policies/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyRewardReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of existing APR policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List APR policies
         * @param {number} [count] Number of APR policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetAprPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAprPolicies: async (count?: number, startIndex?: number, sortBy?: GetAprPoliciesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/aprs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific annual percentage rate (APR) policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve APR policy
         * @param {string} token Unique identifier of the APR policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAprPolicyByToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAprPolicyByToken', 'token', token)
            const localVarPath = `/policies/aprs/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of the historic annual percentage rate (APR) schedules on a specific APR policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List APR schedules
         * @param {string} token Unique identifier of the APR policy on which to retrieve APR schedules.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing product policy tokens.
         * @param {number} [count] Number of APR schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetAprPolicySchedulesWithTokenSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAprPolicySchedulesWithToken: async (token: string, count?: number, startIndex?: number, sortBy?: GetAprPolicySchedulesWithTokenSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getAprPolicySchedulesWithToken', 'token', token)
            const localVarPath = `/policies/aprs/{token}/schedule`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of existing fee policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List fee policies
         * @param {number} [count] Number of fee policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetFeePoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeePolicies: async (count?: number, startIndex?: number, sortBy?: GetFeePoliciesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/fees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific fee policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve fee policy
         * @param {string} token Unique identifier of the fee policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeePolicyByToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getFeePolicyByToken', 'token', token)
            const localVarPath = `/policies/fees/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of existing document policies. A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List document policies
         * @param {number} [count] Number of document policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListDocumentPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentPolicies: async (count?: number, startIndex?: number, sortBy?: ListDocumentPoliciesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of existing credit product policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List credit product policies
         * @param {number} [count] Number of product policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProductPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductPolicies: async (count?: number, startIndex?: number, sortBy?: ListProductPoliciesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of reward policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List reward policies
         * @param {number} [count] Number of reward policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRewardPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewardPolicies: async (count?: number, startIndex?: number, sortBy?: ListRewardPoliciesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Retrieve document policy
         * @param {string} token Unique identifier of the document policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDocumentPolicy: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrieveDocumentPolicy', 'token', token)
            const localVarPath = `/policies/documents/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific credit product policy.
         * @summary Retrieve credit product policy
         * @param {string} token Unique identifier of the credit product policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProductPolicy: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrieveProductPolicy', 'token', token)
            const localVarPath = `/policies/products/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a reward policy.
         * @summary Retrieve reward policy
         * @param {string} token Unique identifier of the reward policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRewardPolicy: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrieveRewardPolicy', 'token', token)
            const localVarPath = `/policies/rewards/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific APR policy.
         * @summary Update APR policy
         * @param {string} token Unique identifier of the APR policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {PolicyAprUpdateReq} policyAprUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAprPolicyWithToken: async (token: string, policyAprUpdateReq: PolicyAprUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateAprPolicyWithToken', 'token', token)
            // verify required parameter 'policyAprUpdateReq' is not null or undefined
            assertParamExists('updateAprPolicyWithToken', 'policyAprUpdateReq', policyAprUpdateReq)
            const localVarPath = `/policies/aprs/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyAprUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Update document policy
         * @param {string} token Unique identifier of the document policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {PolicyDocumentUpdateReq} policyDocumentUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentPolicy: async (token: string, policyDocumentUpdateReq: PolicyDocumentUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateDocumentPolicy', 'token', token)
            // verify required parameter 'policyDocumentUpdateReq' is not null or undefined
            assertParamExists('updateDocumentPolicy', 'policyDocumentUpdateReq', policyDocumentUpdateReq)
            const localVarPath = `/policies/documents/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyDocumentUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific fee policy.
         * @summary Update fee policy
         * @param {string} token Unique identifier of the fee policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {PolicyFeeUpdateReq} policyFeeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeePolicyWithToken: async (token: string, policyFeeUpdateReq: PolicyFeeUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateFeePolicyWithToken', 'token', token)
            // verify required parameter 'policyFeeUpdateReq' is not null or undefined
            assertParamExists('updateFeePolicyWithToken', 'policyFeeUpdateReq', policyFeeUpdateReq)
            const localVarPath = `/policies/fees/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyFeeUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a specific credit product policy.
         * @summary Update credit product policy
         * @param {string} token Unique identifier of the credit product policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {PolicyProductUpdateReq} policyProductUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductPolicy: async (token: string, policyProductUpdateReq: PolicyProductUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateProductPolicy', 'token', token)
            // verify required parameter 'policyProductUpdateReq' is not null or undefined
            assertParamExists('updateProductPolicy', 'policyProductUpdateReq', policyProductUpdateReq)
            const localVarPath = `/policies/products/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyProductUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a reward policy.
         * @summary Update reward policy
         * @param {string} token Unique identifier of the reward policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {PolicyRewardReq} policyRewardReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRewardPolicy: async (token: string, policyRewardReq: PolicyRewardReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateRewardPolicy', 'token', token)
            // verify required parameter 'policyRewardReq' is not null or undefined
            assertParamExists('updateRewardPolicy', 'policyRewardReq', policyRewardReq)
            const localVarPath = `/policies/rewards/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(policyRewardReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 */
export const PoliciesApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new annual percentage rate (APR) policy based on an existing APR policy.
         * @summary Clone APR policy
         * @param {string} token Unique identifier of the APR policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneAprPolicy(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyAprResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneAprPolicy(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.cloneAprPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document policy based on an existing document policy. A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Clone document policy
         * @param {string} token Unique identifier of the document policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneDocumentPolicy(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneDocumentPolicy(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.cloneDocumentPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new fee policy based on an existing fee policy.
         * @summary Clone fee policy
         * @param {string} token Unique identifier of the fee policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneFeePolicy(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneFeePolicy(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.cloneFeePolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new credit product policy based on an existing credit product policy.
         * @summary Clone credit product policy
         * @param {string} token Unique identifier of the credit product policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneProductPolicy(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneProductPolicy(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.cloneProductPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new reward policy based on existing reward policy.
         * @summary Clone reward policy
         * @param {string} token Unique identifier of the reward policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneRewardPolicy(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneRewardPolicy(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.cloneRewardPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new annual percentage rate (APR) policy.
         * @summary Create APR policy
         * @param {PolicyAprCreateReq} policyAprCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAprPolicy(policyAprCreateReq: PolicyAprCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyAprResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAprPolicy(policyAprCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createAprPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Create document policy
         * @param {PolicyDocumentCreateReq} policyDocumentCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentPolicy(policyDocumentCreateReq: PolicyDocumentCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentPolicy(policyDocumentCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createDocumentPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new fee policy.
         * @summary Create fee policy
         * @param {PolicyFeeCreateReq} policyFeeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFeePolicy(policyFeeCreateReq: PolicyFeeCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFeePolicy(policyFeeCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createFeePolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new credit product policy.
         * @summary Create credit product policy
         * @param {PolicyProductCreateReq} policyProductCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductPolicy(policyProductCreateReq: PolicyProductCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProductPolicy(policyProductCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createProductPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new reward policy.
         * @summary Create reward policy
         * @param {PolicyRewardReq} policyRewardReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRewardPolicy(policyRewardReq: PolicyRewardReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRewardPolicy(policyRewardReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createRewardPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of existing APR policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List APR policies
         * @param {number} [count] Number of APR policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetAprPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAprPolicies(count?: number, startIndex?: number, sortBy?: GetAprPoliciesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyAprsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAprPolicies(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getAprPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific annual percentage rate (APR) policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve APR policy
         * @param {string} token Unique identifier of the APR policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAprPolicyByToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyAprResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAprPolicyByToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getAprPolicyByToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of the historic annual percentage rate (APR) schedules on a specific APR policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List APR schedules
         * @param {string} token Unique identifier of the APR policy on which to retrieve APR schedules.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing product policy tokens.
         * @param {number} [count] Number of APR schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetAprPolicySchedulesWithTokenSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAprPolicySchedulesWithToken(token: string, count?: number, startIndex?: number, sortBy?: GetAprPolicySchedulesWithTokenSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyAprsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAprPolicySchedulesWithToken(token, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getAprPolicySchedulesWithToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of existing fee policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List fee policies
         * @param {number} [count] Number of fee policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetFeePoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeePolicies(count?: number, startIndex?: number, sortBy?: GetFeePoliciesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyFeesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeePolicies(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getFeePolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific fee policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve fee policy
         * @param {string} token Unique identifier of the fee policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFeePolicyByToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFeePolicyByToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.getFeePolicyByToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of existing document policies. A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List document policies
         * @param {number} [count] Number of document policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListDocumentPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocumentPolicies(count?: number, startIndex?: number, sortBy?: ListDocumentPoliciesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesDocumentPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocumentPolicies(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.listDocumentPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of existing credit product policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List credit product policies
         * @param {number} [count] Number of product policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProductPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProductPolicies(count?: number, startIndex?: number, sortBy?: ListProductPoliciesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesProductPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProductPolicies(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.listProductPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of reward policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List reward policies
         * @param {number} [count] Number of reward policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRewardPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRewardPolicies(count?: number, startIndex?: number, sortBy?: ListRewardPoliciesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRewardPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRewardPolicies(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.listRewardPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Retrieve document policy
         * @param {string} token Unique identifier of the document policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDocumentPolicy(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveDocumentPolicy(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.retrieveDocumentPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific credit product policy.
         * @summary Retrieve credit product policy
         * @param {string} token Unique identifier of the credit product policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProductPolicy(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProductPolicy(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.retrieveProductPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a reward policy.
         * @summary Retrieve reward policy
         * @param {string} token Unique identifier of the reward policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRewardPolicy(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRewardPolicy(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.retrieveRewardPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific APR policy.
         * @summary Update APR policy
         * @param {string} token Unique identifier of the APR policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {PolicyAprUpdateReq} policyAprUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAprPolicyWithToken(token: string, policyAprUpdateReq: PolicyAprUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyAprResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAprPolicyWithToken(token, policyAprUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updateAprPolicyWithToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Update document policy
         * @param {string} token Unique identifier of the document policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {PolicyDocumentUpdateReq} policyDocumentUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentPolicy(token: string, policyDocumentUpdateReq: PolicyDocumentUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyDocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentPolicy(token, policyDocumentUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updateDocumentPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific fee policy.
         * @summary Update fee policy
         * @param {string} token Unique identifier of the fee policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {PolicyFeeUpdateReq} policyFeeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFeePolicyWithToken(token: string, policyFeeUpdateReq: PolicyFeeUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyFeeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFeePolicyWithToken(token, policyFeeUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updateFeePolicyWithToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a specific credit product policy.
         * @summary Update credit product policy
         * @param {string} token Unique identifier of the credit product policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {PolicyProductUpdateReq} policyProductUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductPolicy(token: string, policyProductUpdateReq: PolicyProductUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductPolicy(token, policyProductUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updateProductPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a reward policy.
         * @summary Update reward policy
         * @param {string} token Unique identifier of the reward policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {PolicyRewardReq} policyRewardReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRewardPolicy(token: string, policyRewardReq: PolicyRewardReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PolicyRewardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRewardPolicy(token, policyRewardReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updateRewardPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoliciesApi - factory interface
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Create a new annual percentage rate (APR) policy based on an existing APR policy.
         * @summary Clone APR policy
         * @param {string} token Unique identifier of the APR policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneAprPolicy(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyAprResponse> {
            return localVarFp.cloneAprPolicy(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document policy based on an existing document policy. A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Clone document policy
         * @param {string} token Unique identifier of the document policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneDocumentPolicy(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyDocumentResponse> {
            return localVarFp.cloneDocumentPolicy(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new fee policy based on an existing fee policy.
         * @summary Clone fee policy
         * @param {string} token Unique identifier of the fee policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneFeePolicy(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyFeeResponse> {
            return localVarFp.cloneFeePolicy(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new credit product policy based on an existing credit product policy.
         * @summary Clone credit product policy
         * @param {string} token Unique identifier of the credit product policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneProductPolicy(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyProductResponse> {
            return localVarFp.cloneProductPolicy(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new reward policy based on existing reward policy.
         * @summary Clone reward policy
         * @param {string} token Unique identifier of the reward policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneRewardPolicy(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyRewardResponse> {
            return localVarFp.cloneRewardPolicy(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new annual percentage rate (APR) policy.
         * @summary Create APR policy
         * @param {PolicyAprCreateReq} policyAprCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAprPolicy(policyAprCreateReq: PolicyAprCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyAprResponse> {
            return localVarFp.createAprPolicy(policyAprCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Create document policy
         * @param {PolicyDocumentCreateReq} policyDocumentCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentPolicy(policyDocumentCreateReq: PolicyDocumentCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyDocumentResponse> {
            return localVarFp.createDocumentPolicy(policyDocumentCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new fee policy.
         * @summary Create fee policy
         * @param {PolicyFeeCreateReq} policyFeeCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFeePolicy(policyFeeCreateReq: PolicyFeeCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyFeeResponse> {
            return localVarFp.createFeePolicy(policyFeeCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new credit product policy.
         * @summary Create credit product policy
         * @param {PolicyProductCreateReq} policyProductCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductPolicy(policyProductCreateReq: PolicyProductCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyProductResponse> {
            return localVarFp.createProductPolicy(policyProductCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new reward policy.
         * @summary Create reward policy
         * @param {PolicyRewardReq} policyRewardReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRewardPolicy(policyRewardReq: PolicyRewardReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyRewardResponse> {
            return localVarFp.createRewardPolicy(policyRewardReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of existing APR policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List APR policies
         * @param {number} [count] Number of APR policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetAprPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAprPolicies(count?: number, startIndex?: number, sortBy?: GetAprPoliciesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PolicyAprsPage> {
            return localVarFp.getAprPolicies(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific annual percentage rate (APR) policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve APR policy
         * @param {string} token Unique identifier of the APR policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAprPolicyByToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyAprResponse> {
            return localVarFp.getAprPolicyByToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of the historic annual percentage rate (APR) schedules on a specific APR policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List APR schedules
         * @param {string} token Unique identifier of the APR policy on which to retrieve APR schedules.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing product policy tokens.
         * @param {number} [count] Number of APR schedule resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetAprPolicySchedulesWithTokenSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAprPolicySchedulesWithToken(token: string, count?: number, startIndex?: number, sortBy?: GetAprPolicySchedulesWithTokenSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PolicyAprsPage> {
            return localVarFp.getAprPolicySchedulesWithToken(token, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of existing fee policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List fee policies
         * @param {number} [count] Number of fee policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetFeePoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeePolicies(count?: number, startIndex?: number, sortBy?: GetFeePoliciesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PolicyFeesPage> {
            return localVarFp.getFeePolicies(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific fee policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary Retrieve fee policy
         * @param {string} token Unique identifier of the fee policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeePolicyByToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyFeeResponse> {
            return localVarFp.getFeePolicyByToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of existing document policies. A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List document policies
         * @param {number} [count] Number of document policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListDocumentPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentPolicies(count?: number, startIndex?: number, sortBy?: ListDocumentPoliciesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PoliciesDocumentPage> {
            return localVarFp.listDocumentPolicies(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of existing credit product policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List credit product policies
         * @param {number} [count] Number of product policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProductPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProductPolicies(count?: number, startIndex?: number, sortBy?: ListProductPoliciesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PoliciesProductPage> {
            return localVarFp.listProductPolicies(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of reward policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List reward policies
         * @param {number} [count] Number of reward policy resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListRewardPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRewardPolicies(count?: number, startIndex?: number, sortBy?: ListRewardPoliciesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PolicyRewardPage> {
            return localVarFp.listRewardPolicies(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Retrieve document policy
         * @param {string} token Unique identifier of the document policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDocumentPolicy(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyDocumentResponse> {
            return localVarFp.retrieveDocumentPolicy(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific credit product policy.
         * @summary Retrieve credit product policy
         * @param {string} token Unique identifier of the credit product policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProductPolicy(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyProductResponse> {
            return localVarFp.retrieveProductPolicy(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a reward policy.
         * @summary Retrieve reward policy
         * @param {string} token Unique identifier of the reward policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRewardPolicy(token: string, options?: RawAxiosRequestConfig): AxiosPromise<PolicyRewardResponse> {
            return localVarFp.retrieveRewardPolicy(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific APR policy.
         * @summary Update APR policy
         * @param {string} token Unique identifier of the APR policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
         * @param {PolicyAprUpdateReq} policyAprUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAprPolicyWithToken(token: string, policyAprUpdateReq: PolicyAprUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyAprResponse> {
            return localVarFp.updateAprPolicyWithToken(token, policyAprUpdateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
         * @summary Update document policy
         * @param {string} token Unique identifier of the document policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
         * @param {PolicyDocumentUpdateReq} policyDocumentUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentPolicy(token: string, policyDocumentUpdateReq: PolicyDocumentUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyDocumentResponse> {
            return localVarFp.updateDocumentPolicy(token, policyDocumentUpdateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific fee policy.
         * @summary Update fee policy
         * @param {string} token Unique identifier of the fee policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
         * @param {PolicyFeeUpdateReq} policyFeeUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeePolicyWithToken(token: string, policyFeeUpdateReq: PolicyFeeUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyFeeResponse> {
            return localVarFp.updateFeePolicyWithToken(token, policyFeeUpdateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a specific credit product policy.
         * @summary Update credit product policy
         * @param {string} token Unique identifier of the credit product policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
         * @param {PolicyProductUpdateReq} policyProductUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductPolicy(token: string, policyProductUpdateReq: PolicyProductUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyProductResponse> {
            return localVarFp.updateProductPolicy(token, policyProductUpdateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a reward policy.
         * @summary Update reward policy
         * @param {string} token Unique identifier of the reward policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
         * @param {PolicyRewardReq} policyRewardReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRewardPolicy(token: string, policyRewardReq: PolicyRewardReq, options?: RawAxiosRequestConfig): AxiosPromise<PolicyRewardResponse> {
            return localVarFp.updateRewardPolicy(token, policyRewardReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Create a new annual percentage rate (APR) policy based on an existing APR policy.
     * @summary Clone APR policy
     * @param {string} token Unique identifier of the APR policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cloneAprPolicy(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).cloneAprPolicy(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document policy based on an existing document policy. A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
     * @summary Clone document policy
     * @param {string} token Unique identifier of the document policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cloneDocumentPolicy(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).cloneDocumentPolicy(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new fee policy based on an existing fee policy.
     * @summary Clone fee policy
     * @param {string} token Unique identifier of the fee policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cloneFeePolicy(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).cloneFeePolicy(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new credit product policy based on an existing credit product policy.
     * @summary Clone credit product policy
     * @param {string} token Unique identifier of the credit product policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cloneProductPolicy(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).cloneProductPolicy(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new reward policy based on existing reward policy.
     * @summary Clone reward policy
     * @param {string} token Unique identifier of the reward policy to clone.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cloneRewardPolicy(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).cloneRewardPolicy(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new annual percentage rate (APR) policy.
     * @summary Create APR policy
     * @param {PolicyAprCreateReq} policyAprCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAprPolicy(policyAprCreateReq: PolicyAprCreateReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createAprPolicy(policyAprCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
     * @summary Create document policy
     * @param {PolicyDocumentCreateReq} policyDocumentCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDocumentPolicy(policyDocumentCreateReq: PolicyDocumentCreateReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createDocumentPolicy(policyDocumentCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new fee policy.
     * @summary Create fee policy
     * @param {PolicyFeeCreateReq} policyFeeCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createFeePolicy(policyFeeCreateReq: PolicyFeeCreateReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createFeePolicy(policyFeeCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new credit product policy.
     * @summary Create credit product policy
     * @param {PolicyProductCreateReq} policyProductCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProductPolicy(policyProductCreateReq: PolicyProductCreateReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createProductPolicy(policyProductCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new reward policy.
     * @summary Create reward policy
     * @param {PolicyRewardReq} policyRewardReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRewardPolicy(policyRewardReq: PolicyRewardReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createRewardPolicy(policyRewardReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of existing APR policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List APR policies
     * @param {number} [count] Number of APR policy resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetAprPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;effectiveDate&#x60;, and not by the field names appearing in response bodies such as &#x60;effective_date&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAprPolicies(count?: number, startIndex?: number, sortBy?: GetAprPoliciesSortByEnum, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getAprPolicies(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific annual percentage rate (APR) policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary Retrieve APR policy
     * @param {string} token Unique identifier of the APR policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAprPolicyByToken(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getAprPolicyByToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of the historic annual percentage rate (APR) schedules on a specific APR policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List APR schedules
     * @param {string} token Unique identifier of the APR policy on which to retrieve APR schedules.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing product policy tokens.
     * @param {number} [count] Number of APR schedule resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetAprPolicySchedulesWithTokenSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAprPolicySchedulesWithToken(token: string, count?: number, startIndex?: number, sortBy?: GetAprPolicySchedulesWithTokenSortByEnum, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getAprPolicySchedulesWithToken(token, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of existing fee policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List fee policies
     * @param {number} [count] Number of fee policy resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetFeePoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeePolicies(count?: number, startIndex?: number, sortBy?: GetFeePoliciesSortByEnum, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getFeePolicies(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific fee policy.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary Retrieve fee policy
     * @param {string} token Unique identifier of the fee policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFeePolicyByToken(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).getFeePolicyByToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of existing document policies. A document policy consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List document policies
     * @param {number} [count] Number of document policy resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListDocumentPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDocumentPolicies(count?: number, startIndex?: number, sortBy?: ListDocumentPoliciesSortByEnum, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).listDocumentPolicies(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of existing credit product policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List credit product policies
     * @param {number} [count] Number of product policy resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListProductPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProductPolicies(count?: number, startIndex?: number, sortBy?: ListProductPoliciesSortByEnum, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).listProductPolicies(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of reward policies.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List reward policies
     * @param {number} [count] Number of reward policy resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListRewardPoliciesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listRewardPolicies(count?: number, startIndex?: number, sortBy?: ListRewardPoliciesSortByEnum, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).listRewardPolicies(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
     * @summary Retrieve document policy
     * @param {string} token Unique identifier of the document policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveDocumentPolicy(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).retrieveDocumentPolicy(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific credit product policy.
     * @summary Retrieve credit product policy
     * @param {string} token Unique identifier of the credit product policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveProductPolicy(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).retrieveProductPolicy(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a reward policy.
     * @summary Retrieve reward policy
     * @param {string} token Unique identifier of the reward policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveRewardPolicy(token: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).retrieveRewardPolicy(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific APR policy.
     * @summary Update APR policy
     * @param {string} token Unique identifier of the APR policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/aprs&#x60; to retrieve existing APR policy tokens.
     * @param {PolicyAprUpdateReq} policyAprUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAprPolicyWithToken(token: string, policyAprUpdateReq: PolicyAprUpdateReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updateAprPolicyWithToken(token, policyAprUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific document policy, which consists of all the pre- and post-application disclosures and credit program documents known as assets and templates. Assets contain finalized values after a bundle is created; templates do not contain finalized values.
     * @summary Update document policy
     * @param {string} token Unique identifier of the document policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/documents&#x60; to retrieve existing document policy tokens.
     * @param {PolicyDocumentUpdateReq} policyDocumentUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDocumentPolicy(token: string, policyDocumentUpdateReq: PolicyDocumentUpdateReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updateDocumentPolicy(token, policyDocumentUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific fee policy.
     * @summary Update fee policy
     * @param {string} token Unique identifier of the fee policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/fee&#x60; to retrieve existing fee policy tokens.
     * @param {PolicyFeeUpdateReq} policyFeeUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateFeePolicyWithToken(token: string, policyFeeUpdateReq: PolicyFeeUpdateReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updateFeePolicyWithToken(token, policyFeeUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a specific credit product policy.
     * @summary Update credit product policy
     * @param {string} token Unique identifier of the credit product policy to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/policies/products&#x60; to retrieve existing credit product policy tokens.
     * @param {PolicyProductUpdateReq} policyProductUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProductPolicy(token: string, policyProductUpdateReq: PolicyProductUpdateReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updateProductPolicy(token, policyProductUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a reward policy.
     * @summary Update reward policy
     * @param {string} token Unique identifier of the reward policy to update.  Send a &#x60;GET&#x60; request to &#x60;/policies/rewards&#x60; to retrieve existing reward policy tokens.
     * @param {PolicyRewardReq} policyRewardReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateRewardPolicy(token: string, policyRewardReq: PolicyRewardReq, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updateRewardPolicy(token, policyRewardReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetAprPoliciesSortByEnum = {
    EffectiveDate: 'effectiveDate',
    EffectiveDate2: '-effectiveDate'
} as const;
export type GetAprPoliciesSortByEnum = typeof GetAprPoliciesSortByEnum[keyof typeof GetAprPoliciesSortByEnum];
export const GetAprPolicySchedulesWithTokenSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type GetAprPolicySchedulesWithTokenSortByEnum = typeof GetAprPolicySchedulesWithTokenSortByEnum[keyof typeof GetAprPolicySchedulesWithTokenSortByEnum];
export const GetFeePoliciesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type GetFeePoliciesSortByEnum = typeof GetFeePoliciesSortByEnum[keyof typeof GetFeePoliciesSortByEnum];
export const ListDocumentPoliciesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListDocumentPoliciesSortByEnum = typeof ListDocumentPoliciesSortByEnum[keyof typeof ListDocumentPoliciesSortByEnum];
export const ListProductPoliciesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListProductPoliciesSortByEnum = typeof ListProductPoliciesSortByEnum[keyof typeof ListProductPoliciesSortByEnum];
export const ListRewardPoliciesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListRewardPoliciesSortByEnum = typeof ListRewardPoliciesSortByEnum[keyof typeof ListRewardPoliciesSortByEnum];


/**
 * ProgramFundingApi - axios parameter creator
 */
export const ProgramFundingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an array of program funding entries.
         * @summary List program fundings
         * @param {number} [count] Number of program funding resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Start date for filtering program funding entries.
         * @param {string} [endDate] End date for filtering program funding entries.
         * @param {string} [shortCode] Short code for filtering program funding entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramFundings: async (count?: number, startIndex?: number, startDate?: string, endDate?: string, shortCode?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/programs/funding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (shortCode !== undefined) {
                localVarQueryParameter['short_code'] = shortCode;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of program funding entries.
         * @summary List program fundings
         * @param {number} [count] Number of program funding resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Start date for filtering program funding entries.
         * @param {string} [endDate] End date for filtering program funding entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramFundingsByShortCode: async (count?: number, startIndex?: number, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programs/funding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramFundingApi - functional programming interface
 */
export const ProgramFundingApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramFundingApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an array of program funding entries.
         * @summary List program fundings
         * @param {number} [count] Number of program funding resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Start date for filtering program funding entries.
         * @param {string} [endDate] End date for filtering program funding entries.
         * @param {string} [shortCode] Short code for filtering program funding entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramFundings(count?: number, startIndex?: number, startDate?: string, endDate?: string, shortCode?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramFundingPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramFundings(count, startIndex, startDate, endDate, shortCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramFundingApi.getProgramFundings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of program funding entries.
         * @summary List program fundings
         * @param {number} [count] Number of program funding resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Start date for filtering program funding entries.
         * @param {string} [endDate] End date for filtering program funding entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramFundingsByShortCode(count?: number, startIndex?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramFundingPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramFundingsByShortCode(count, startIndex, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramFundingApi.getProgramFundingsByShortCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProgramFundingApi - factory interface
 */
export const ProgramFundingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramFundingApiFp(configuration)
    return {
        /**
         * Retrieve an array of program funding entries.
         * @summary List program fundings
         * @param {number} [count] Number of program funding resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Start date for filtering program funding entries.
         * @param {string} [endDate] End date for filtering program funding entries.
         * @param {string} [shortCode] Short code for filtering program funding entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramFundings(count?: number, startIndex?: number, startDate?: string, endDate?: string, shortCode?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramFundingPage> {
            return localVarFp.getProgramFundings(count, startIndex, startDate, endDate, shortCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of program funding entries.
         * @summary List program fundings
         * @param {number} [count] Number of program funding resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [startDate] Start date for filtering program funding entries.
         * @param {string} [endDate] End date for filtering program funding entries.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramFundingsByShortCode(count?: number, startIndex?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramFundingPage> {
            return localVarFp.getProgramFundingsByShortCode(count, startIndex, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramFundingApi - object-oriented interface
 */
export class ProgramFundingApi extends BaseAPI {
    /**
     * Retrieve an array of program funding entries.
     * @summary List program fundings
     * @param {number} [count] Number of program funding resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [startDate] Start date for filtering program funding entries.
     * @param {string} [endDate] End date for filtering program funding entries.
     * @param {string} [shortCode] Short code for filtering program funding entries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProgramFundings(count?: number, startIndex?: number, startDate?: string, endDate?: string, shortCode?: string, options?: RawAxiosRequestConfig) {
        return ProgramFundingApiFp(this.configuration).getProgramFundings(count, startIndex, startDate, endDate, shortCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of program funding entries.
     * @summary List program fundings
     * @param {number} [count] Number of program funding resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [startDate] Start date for filtering program funding entries.
     * @param {string} [endDate] End date for filtering program funding entries.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProgramFundingsByShortCode(count?: number, startIndex?: number, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return ProgramFundingApiFp(this.configuration).getProgramFundingsByShortCode(count, startIndex, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramGatewaysApi - axios parameter creator
 */
export const ProgramGatewaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new Credit Program Gateway.  Use this endpoint to configure your Program Gateway to receive gateway requests from Marqeta\'s credit platform. You can create multiple Program Gateways, but only one can be active per credit program.  [NOTE] To create a Program Gateway, you must have consumer or admin credentials.
         * @summary Create Program Gateway
         * @param {ProgramGatewayCreateReq} programGatewayCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProgramGateway: async (programGatewayCreateReq: ProgramGatewayCreateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'programGatewayCreateReq' is not null or undefined
            assertParamExists('createProgramGateway', 'programGatewayCreateReq', programGatewayCreateReq)
            const localVarPath = `/programgateways`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(programGatewayCreateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of existing Credit Program Gateways.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List Program Gateways
         * @param {number} [count] Number of Program Gateway resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProgramGatewaysSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProgramGateways: async (count?: number, startIndex?: number, sortBy?: ListProgramGatewaysSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programgateways`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an existing Credit Program Gateway.
         * @summary Retrieve Program Gateway
         * @param {string} token Unique identifier of the Program Gateway to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/programgateways&#x60; to retrieve existing Program Gateway tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProgramGateway: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('retrieveProgramGateway', 'token', token)
            const localVarPath = `/programgateways/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing Credit Program Gateway.  You may want to update a Program Gateway if you are switching it to active or inactive, updating the URL, username, or password, and more.
         * @summary Update Program Gateway
         * @param {string} token Unique identifier of the Program Gateway to update.
         * @param {ProgramGatewayUpdateReq} programGatewayUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramGateway: async (token: string, programGatewayUpdateReq: ProgramGatewayUpdateReq, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('updateProgramGateway', 'token', token)
            // verify required parameter 'programGatewayUpdateReq' is not null or undefined
            assertParamExists('updateProgramGateway', 'programGatewayUpdateReq', programGatewayUpdateReq)
            const localVarPath = `/programgateways/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(programGatewayUpdateReq, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramGatewaysApi - functional programming interface
 */
export const ProgramGatewaysApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramGatewaysApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new Credit Program Gateway.  Use this endpoint to configure your Program Gateway to receive gateway requests from Marqeta\'s credit platform. You can create multiple Program Gateways, but only one can be active per credit program.  [NOTE] To create a Program Gateway, you must have consumer or admin credentials.
         * @summary Create Program Gateway
         * @param {ProgramGatewayCreateReq} programGatewayCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProgramGateway(programGatewayCreateReq: ProgramGatewayCreateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramGatewayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProgramGateway(programGatewayCreateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramGatewaysApi.createProgramGateway']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of existing Credit Program Gateways.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List Program Gateways
         * @param {number} [count] Number of Program Gateway resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProgramGatewaysSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProgramGateways(count?: number, startIndex?: number, sortBy?: ListProgramGatewaysSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramGatewayPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProgramGateways(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramGatewaysApi.listProgramGateways']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an existing Credit Program Gateway.
         * @summary Retrieve Program Gateway
         * @param {string} token Unique identifier of the Program Gateway to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/programgateways&#x60; to retrieve existing Program Gateway tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProgramGateway(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramGatewayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProgramGateway(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramGatewaysApi.retrieveProgramGateway']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing Credit Program Gateway.  You may want to update a Program Gateway if you are switching it to active or inactive, updating the URL, username, or password, and more.
         * @summary Update Program Gateway
         * @param {string} token Unique identifier of the Program Gateway to update.
         * @param {ProgramGatewayUpdateReq} programGatewayUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProgramGateway(token: string, programGatewayUpdateReq: ProgramGatewayUpdateReq, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramGatewayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProgramGateway(token, programGatewayUpdateReq, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramGatewaysApi.updateProgramGateway']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProgramGatewaysApi - factory interface
 */
export const ProgramGatewaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramGatewaysApiFp(configuration)
    return {
        /**
         * Create a new Credit Program Gateway.  Use this endpoint to configure your Program Gateway to receive gateway requests from Marqeta\'s credit platform. You can create multiple Program Gateways, but only one can be active per credit program.  [NOTE] To create a Program Gateway, you must have consumer or admin credentials.
         * @summary Create Program Gateway
         * @param {ProgramGatewayCreateReq} programGatewayCreateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProgramGateway(programGatewayCreateReq: ProgramGatewayCreateReq, options?: RawAxiosRequestConfig): AxiosPromise<ProgramGatewayResponse> {
            return localVarFp.createProgramGateway(programGatewayCreateReq, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of existing Credit Program Gateways.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List Program Gateways
         * @param {number} [count] Number of Program Gateway resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {ListProgramGatewaysSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProgramGateways(count?: number, startIndex?: number, sortBy?: ListProgramGatewaysSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<ProgramGatewayPage> {
            return localVarFp.listProgramGateways(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an existing Credit Program Gateway.
         * @summary Retrieve Program Gateway
         * @param {string} token Unique identifier of the Program Gateway to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/programgateways&#x60; to retrieve existing Program Gateway tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProgramGateway(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramGatewayResponse> {
            return localVarFp.retrieveProgramGateway(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing Credit Program Gateway.  You may want to update a Program Gateway if you are switching it to active or inactive, updating the URL, username, or password, and more.
         * @summary Update Program Gateway
         * @param {string} token Unique identifier of the Program Gateway to update.
         * @param {ProgramGatewayUpdateReq} programGatewayUpdateReq 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramGateway(token: string, programGatewayUpdateReq: ProgramGatewayUpdateReq, options?: RawAxiosRequestConfig): AxiosPromise<ProgramGatewayResponse> {
            return localVarFp.updateProgramGateway(token, programGatewayUpdateReq, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramGatewaysApi - object-oriented interface
 */
export class ProgramGatewaysApi extends BaseAPI {
    /**
     * Create a new Credit Program Gateway.  Use this endpoint to configure your Program Gateway to receive gateway requests from Marqeta\'s credit platform. You can create multiple Program Gateways, but only one can be active per credit program.  [NOTE] To create a Program Gateway, you must have consumer or admin credentials.
     * @summary Create Program Gateway
     * @param {ProgramGatewayCreateReq} programGatewayCreateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createProgramGateway(programGatewayCreateReq: ProgramGatewayCreateReq, options?: RawAxiosRequestConfig) {
        return ProgramGatewaysApiFp(this.configuration).createProgramGateway(programGatewayCreateReq, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of existing Credit Program Gateways.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List Program Gateways
     * @param {number} [count] Number of Program Gateway resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {ListProgramGatewaysSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listProgramGateways(count?: number, startIndex?: number, sortBy?: ListProgramGatewaysSortByEnum, options?: RawAxiosRequestConfig) {
        return ProgramGatewaysApiFp(this.configuration).listProgramGateways(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an existing Credit Program Gateway.
     * @summary Retrieve Program Gateway
     * @param {string} token Unique identifier of the Program Gateway to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/programgateways&#x60; to retrieve existing Program Gateway tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveProgramGateway(token: string, options?: RawAxiosRequestConfig) {
        return ProgramGatewaysApiFp(this.configuration).retrieveProgramGateway(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing Credit Program Gateway.  You may want to update a Program Gateway if you are switching it to active or inactive, updating the URL, username, or password, and more.
     * @summary Update Program Gateway
     * @param {string} token Unique identifier of the Program Gateway to update.
     * @param {ProgramGatewayUpdateReq} programGatewayUpdateReq 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateProgramGateway(token: string, programGatewayUpdateReq: ProgramGatewayUpdateReq, options?: RawAxiosRequestConfig) {
        return ProgramGatewaysApiFp(this.configuration).updateProgramGateway(token, programGatewayUpdateReq, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListProgramGatewaysSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListProgramGatewaysSortByEnum = typeof ListProgramGatewaysSortByEnum[keyof typeof ListProgramGatewaysSortByEnum];


/**
 * ProgramReserveApi - axios parameter creator
 */
export const ProgramReserveApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProgramReserveDepositRequest} [programReserveDepositRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deposit: async (programReserveDepositRequest?: ProgramReserveDepositRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programreserve/deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(programReserveDepositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getProgramReserveDeposits: async (count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programreserve/deposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to return balances for your program reserve account (sometimes referred to as a _program funding account_).
         * @summary Retrieve reserve account balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveBalances: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programreserve/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to return a list of credits and debits made to your program reserve account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List program reserve transactions
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveTransactions: async (count?: number, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programreserve/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramReserveApi - functional programming interface
 */
export const ProgramReserveApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramReserveApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProgramReserveDepositRequest} [programReserveDepositRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deposit(programReserveDepositRequest?: ProgramReserveDepositRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deposit(programReserveDepositRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramReserveApi.deposit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getProgramReserveDeposits(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramReserveDeposits(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramReserveApi.getProgramReserveDeposits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to return balances for your program reserve account (sometimes referred to as a _program funding account_).
         * @summary Retrieve reserve account balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramreserveBalances(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramReserveAccountBalance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramreserveBalances(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramReserveApi.getProgramreserveBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to return a list of credits and debits made to your program reserve account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List program reserve transactions
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramreserveTransactions(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramReserveTransactionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramreserveTransactions(count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramReserveApi.getProgramreserveTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProgramReserveApi - factory interface
 */
export const ProgramReserveApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramReserveApiFp(configuration)
    return {
        /**
         * 
         * @param {ProgramReserveDepositRequest} [programReserveDepositRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deposit(programReserveDepositRequest?: ProgramReserveDepositRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deposit(programReserveDepositRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [count] Number of items to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getProgramReserveDeposits(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getProgramReserveDeposits(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to return balances for your program reserve account (sometimes referred to as a _program funding account_).
         * @summary Retrieve reserve account balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveBalances(options?: RawAxiosRequestConfig): AxiosPromise<ProgramReserveAccountBalance> {
            return localVarFp.getProgramreserveBalances(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to return a list of credits and debits made to your program reserve account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
         * @summary List program reserve transactions
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramreserveTransactions(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramReserveTransactionListResponse> {
            return localVarFp.getProgramreserveTransactions(count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramReserveApi - object-oriented interface
 */
export class ProgramReserveApi extends BaseAPI {
    /**
     * 
     * @param {ProgramReserveDepositRequest} [programReserveDepositRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public deposit(programReserveDepositRequest?: ProgramReserveDepositRequest, options?: RawAxiosRequestConfig) {
        return ProgramReserveApiFp(this.configuration).deposit(programReserveDepositRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [count] Number of items to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getProgramReserveDeposits(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return ProgramReserveApiFp(this.configuration).getProgramReserveDeposits(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to return balances for your program reserve account (sometimes referred to as a _program funding account_).
     * @summary Retrieve reserve account balances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProgramreserveBalances(options?: RawAxiosRequestConfig) {
        return ProgramReserveApiFp(this.configuration).getProgramreserveBalances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to return a list of credits and debits made to your program reserve account.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>.
     * @summary List program reserve transactions
     * @param {number} [count] Number of resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProgramreserveTransactions(count?: number, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return ProgramReserveApiFp(this.configuration).getProgramreserveTransactions(count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProgramTransfersApi - axios parameter creator
 */
export const ProgramTransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to list all program transfers.  To narrow your result set to program transfers of a particular type or that are associated with a particular account holder, include the appropriate parameters from the following URL Query Parameters table. This endpoint also supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List program transfers
         * @param {number} [count] Number of program transfers to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [userToken] Unique identifier of the user account holder whose program transfers you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve user tokens.
         * @param {string} [businessToken] Unique identifier of the business account holder whose program transfers you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/businesses&#x60; to retrieve business tokens.
         * @param {string} [typeToken] Unique identifier of the program transfer type to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfers: async (count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, typeToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programtransfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (typeToken !== undefined) {
                localVarQueryParameter['type_token'] = typeToken;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a specific program transfer. Include the program transfer `token` path parameter to specify the program transfer to retrieve.
         * @summary Retrieve program transfer
         * @param {string} token Unique identifier of the program transfer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getProgramtransfersToken', 'token', token)
            const localVarPath = `/programtransfers/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to list all program transfer types.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List program transfer types
         * @param {number} [count] Number of program transfer types to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypes: async (count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programtransfers/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a specific program transfer. Include the `type_token` path parameter to indicate the program transfer type to return.
         * @summary Retrieve program transfer type
         * @param {string} typeToken Unique identifier of the program transfer type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypesTypetoken: async (typeToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeToken' is not null or undefined
            assertParamExists('getProgramtransfersTypesTypetoken', 'typeToken', typeToken)
            const localVarPath = `/programtransfers/types/{type_token}`
                .replace(`{${"type_token"}}`, encodeURIComponent(String(typeToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create a program transfer. Add the program transfer details to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format.  Include either `user_token` or `business_token` in the message body to specify the account holder whose general purpose account (GPA) will be debited by the program transfer. The user or business must already exist.  [NOTE] If the GPA has insufficient funds to cover both the amount of the program transfer and all attached fees, then no funds are transferred.
         * @summary Create program transfer
         * @param {ProgramTransfer} [programTransfer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfers: async (programTransfer?: ProgramTransfer, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programtransfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(programTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create a program transfer type. Add the program transfer details to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format.  You are required to pass in a `program_funding_source_token` to associate a program funding source with the program transfer type. You must therefore create a program funding source before creating a program transfer type.
         * @summary Create program transfer type
         * @param {ProgramTransferTypeRequest} [programTransferTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfersTypes: async (programTransferTypeRequest?: ProgramTransferTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/programtransfers/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(programTransferTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update a program transfer type. Include the `type_token` path parameter to indicate the program transfer type to update. Add the modified detail parameters to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format. Only values of parameters in the request are modified; all others are left unchanged.
         * @summary Update program transfer type
         * @param {string} typeToken Unique identifier of the program transfer type.
         * @param {ProgramTransferTypeRequest} [programTransferTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProgramtransfersTypesTypetoken: async (typeToken: string, programTransferTypeRequest?: ProgramTransferTypeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'typeToken' is not null or undefined
            assertParamExists('putProgramtransfersTypesTypetoken', 'typeToken', typeToken)
            const localVarPath = `/programtransfers/types/{type_token}`
                .replace(`{${"type_token"}}`, encodeURIComponent(String(typeToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(programTransferTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramTransfersApi - functional programming interface
 */
export const ProgramTransfersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramTransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to list all program transfers.  To narrow your result set to program transfers of a particular type or that are associated with a particular account holder, include the appropriate parameters from the following URL Query Parameters table. This endpoint also supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List program transfers
         * @param {number} [count] Number of program transfers to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [userToken] Unique identifier of the user account holder whose program transfers you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve user tokens.
         * @param {string} [businessToken] Unique identifier of the business account holder whose program transfers you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/businesses&#x60; to retrieve business tokens.
         * @param {string} [typeToken] Unique identifier of the program transfer type to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramtransfers(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, typeToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramTransferListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramtransfers(count, startIndex, fields, sortBy, userToken, businessToken, typeToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramTransfersApi.getProgramtransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a specific program transfer. Include the program transfer `token` path parameter to specify the program transfer to retrieve.
         * @summary Retrieve program transfer
         * @param {string} token Unique identifier of the program transfer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramtransfersToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramtransfersToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramTransfersApi.getProgramtransfersToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to list all program transfer types.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List program transfer types
         * @param {number} [count] Number of program transfer types to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramtransfersTypes(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramTransferTypeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramtransfersTypes(count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramTransfersApi.getProgramtransfersTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a specific program transfer. Include the `type_token` path parameter to indicate the program transfer type to return.
         * @summary Retrieve program transfer type
         * @param {string} typeToken Unique identifier of the program transfer type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramtransfersTypesTypetoken(typeToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramTransferTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramtransfersTypesTypetoken(typeToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramTransfersApi.getProgramtransfersTypesTypetoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to create a program transfer. Add the program transfer details to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format.  Include either `user_token` or `business_token` in the message body to specify the account holder whose general purpose account (GPA) will be debited by the program transfer. The user or business must already exist.  [NOTE] If the GPA has insufficient funds to cover both the amount of the program transfer and all attached fees, then no funds are transferred.
         * @summary Create program transfer
         * @param {ProgramTransfer} [programTransfer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProgramtransfers(programTransfer?: ProgramTransfer, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramTransferResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProgramtransfers(programTransfer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramTransfersApi.postProgramtransfers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to create a program transfer type. Add the program transfer details to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format.  You are required to pass in a `program_funding_source_token` to associate a program funding source with the program transfer type. You must therefore create a program funding source before creating a program transfer type.
         * @summary Create program transfer type
         * @param {ProgramTransferTypeRequest} [programTransferTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProgramtransfersTypes(programTransferTypeRequest?: ProgramTransferTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramTransferTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProgramtransfersTypes(programTransferTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramTransfersApi.postProgramtransfersTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update a program transfer type. Include the `type_token` path parameter to indicate the program transfer type to update. Add the modified detail parameters to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format. Only values of parameters in the request are modified; all others are left unchanged.
         * @summary Update program transfer type
         * @param {string} typeToken Unique identifier of the program transfer type.
         * @param {ProgramTransferTypeRequest} [programTransferTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProgramtransfersTypesTypetoken(typeToken: string, programTransferTypeRequest?: ProgramTransferTypeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramTransferTypeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProgramtransfersTypesTypetoken(typeToken, programTransferTypeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProgramTransfersApi.putProgramtransfersTypesTypetoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProgramTransfersApi - factory interface
 */
export const ProgramTransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramTransfersApiFp(configuration)
    return {
        /**
         * Use this endpoint to list all program transfers.  To narrow your result set to program transfers of a particular type or that are associated with a particular account holder, include the appropriate parameters from the following URL Query Parameters table. This endpoint also supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List program transfers
         * @param {number} [count] Number of program transfers to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [userToken] Unique identifier of the user account holder whose program transfers you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve user tokens.
         * @param {string} [businessToken] Unique identifier of the business account holder whose program transfers you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/businesses&#x60; to retrieve business tokens.
         * @param {string} [typeToken] Unique identifier of the program transfer type to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfers(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, typeToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramTransferListResponse> {
            return localVarFp.getProgramtransfers(count, startIndex, fields, sortBy, userToken, businessToken, typeToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a specific program transfer. Include the program transfer `token` path parameter to specify the program transfer to retrieve.
         * @summary Retrieve program transfer
         * @param {string} token Unique identifier of the program transfer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramTransferResponse> {
            return localVarFp.getProgramtransfersToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to list all program transfer types.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
         * @summary List program transfer types
         * @param {number} [count] Number of program transfer types to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypes(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramTransferTypeListResponse> {
            return localVarFp.getProgramtransfersTypes(count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a specific program transfer. Include the `type_token` path parameter to indicate the program transfer type to return.
         * @summary Retrieve program transfer type
         * @param {string} typeToken Unique identifier of the program transfer type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramtransfersTypesTypetoken(typeToken: string, options?: RawAxiosRequestConfig): AxiosPromise<ProgramTransferTypeResponse> {
            return localVarFp.getProgramtransfersTypesTypetoken(typeToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create a program transfer. Add the program transfer details to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format.  Include either `user_token` or `business_token` in the message body to specify the account holder whose general purpose account (GPA) will be debited by the program transfer. The user or business must already exist.  [NOTE] If the GPA has insufficient funds to cover both the amount of the program transfer and all attached fees, then no funds are transferred.
         * @summary Create program transfer
         * @param {ProgramTransfer} [programTransfer] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfers(programTransfer?: ProgramTransfer, options?: RawAxiosRequestConfig): AxiosPromise<ProgramTransferResponse> {
            return localVarFp.postProgramtransfers(programTransfer, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create a program transfer type. Add the program transfer details to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format.  You are required to pass in a `program_funding_source_token` to associate a program funding source with the program transfer type. You must therefore create a program funding source before creating a program transfer type.
         * @summary Create program transfer type
         * @param {ProgramTransferTypeRequest} [programTransferTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProgramtransfersTypes(programTransferTypeRequest?: ProgramTransferTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProgramTransferTypeResponse> {
            return localVarFp.postProgramtransfersTypes(programTransferTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update a program transfer type. Include the `type_token` path parameter to indicate the program transfer type to update. Add the modified detail parameters to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format. Only values of parameters in the request are modified; all others are left unchanged.
         * @summary Update program transfer type
         * @param {string} typeToken Unique identifier of the program transfer type.
         * @param {ProgramTransferTypeRequest} [programTransferTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProgramtransfersTypesTypetoken(typeToken: string, programTransferTypeRequest?: ProgramTransferTypeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProgramTransferTypeResponse> {
            return localVarFp.putProgramtransfersTypesTypetoken(typeToken, programTransferTypeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramTransfersApi - object-oriented interface
 */
export class ProgramTransfersApi extends BaseAPI {
    /**
     * Use this endpoint to list all program transfers.  To narrow your result set to program transfers of a particular type or that are associated with a particular account holder, include the appropriate parameters from the following URL Query Parameters table. This endpoint also supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
     * @summary List program transfers
     * @param {number} [count] Number of program transfers to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {string} [userToken] Unique identifier of the user account holder whose program transfers you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/users&#x60; to retrieve user tokens.
     * @param {string} [businessToken] Unique identifier of the business account holder whose program transfers you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/businesses&#x60; to retrieve business tokens.
     * @param {string} [typeToken] Unique identifier of the program transfer type to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProgramtransfers(count?: number, startIndex?: number, fields?: string, sortBy?: string, userToken?: string, businessToken?: string, typeToken?: string, options?: RawAxiosRequestConfig) {
        return ProgramTransfersApiFp(this.configuration).getProgramtransfers(count, startIndex, fields, sortBy, userToken, businessToken, typeToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a specific program transfer. Include the program transfer `token` path parameter to specify the program transfer to retrieve.
     * @summary Retrieve program transfer
     * @param {string} token Unique identifier of the program transfer.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProgramtransfersToken(token: string, options?: RawAxiosRequestConfig) {
        return ProgramTransfersApiFp(this.configuration).getProgramtransfersToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to list all program transfer types.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, pagination>>, and <</core-api/sorting-and-pagination, sorting>>.
     * @summary List program transfer types
     * @param {number} [count] Number of program transfer types to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProgramtransfersTypes(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return ProgramTransfersApiFp(this.configuration).getProgramtransfersTypes(count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a specific program transfer. Include the `type_token` path parameter to indicate the program transfer type to return.
     * @summary Retrieve program transfer type
     * @param {string} typeToken Unique identifier of the program transfer type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getProgramtransfersTypesTypetoken(typeToken: string, options?: RawAxiosRequestConfig) {
        return ProgramTransfersApiFp(this.configuration).getProgramtransfersTypesTypetoken(typeToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create a program transfer. Add the program transfer details to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format.  Include either `user_token` or `business_token` in the message body to specify the account holder whose general purpose account (GPA) will be debited by the program transfer. The user or business must already exist.  [NOTE] If the GPA has insufficient funds to cover both the amount of the program transfer and all attached fees, then no funds are transferred.
     * @summary Create program transfer
     * @param {ProgramTransfer} [programTransfer] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postProgramtransfers(programTransfer?: ProgramTransfer, options?: RawAxiosRequestConfig) {
        return ProgramTransfersApiFp(this.configuration).postProgramtransfers(programTransfer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create a program transfer type. Add the program transfer details to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format.  You are required to pass in a `program_funding_source_token` to associate a program funding source with the program transfer type. You must therefore create a program funding source before creating a program transfer type.
     * @summary Create program transfer type
     * @param {ProgramTransferTypeRequest} [programTransferTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postProgramtransfersTypes(programTransferTypeRequest?: ProgramTransferTypeRequest, options?: RawAxiosRequestConfig) {
        return ProgramTransfersApiFp(this.configuration).postProgramtransfersTypes(programTransferTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update a program transfer type. Include the `type_token` path parameter to indicate the program transfer type to update. Add the modified detail parameters to the body of the request in link:http://www.json.org/[JSON, window=\"_blank\"] format. Only values of parameters in the request are modified; all others are left unchanged.
     * @summary Update program transfer type
     * @param {string} typeToken Unique identifier of the program transfer type.
     * @param {ProgramTransferTypeRequest} [programTransferTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putProgramtransfersTypesTypetoken(typeToken: string, programTransferTypeRequest?: ProgramTransferTypeRequest, options?: RawAxiosRequestConfig) {
        return ProgramTransfersApiFp(this.configuration).putProgramtransfersTypesTypetoken(typeToken, programTransferTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PushToCardApi - axios parameter creator
 */
export const PushToCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all push-to-card disbursements
         * @param {number} [count] Number of push-to-card disbursements to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburse: async (count?: number, fields?: string, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pushtocards/disburse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific push-to-card disbursement
         * @param {string} token Push-to-card disbursement token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburseToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getPushtocardsDisburseToken', 'token', token)
            const localVarPath = `/pushtocards/disburse/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all push-to-card payment card details
         * @param {string} userToken User token
         * @param {number} [count] Number of push-to-card payment cards to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcard: async (userToken: string, count?: number, fields?: string, startIndex?: number, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('getPushtocardsPaymentcard', 'userToken', userToken)
            const localVarPath = `/pushtocards/paymentcard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a specific paymentcard object
         * @param {string} token Push-to-card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcardToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getPushtocardsPaymentcardToken', 'token', token)
            const localVarPath = `/pushtocards/paymentcard/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiates a push-to-card money disbursement
         * @param {PushToCardDisburseRequest} [pushToCardDisburseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsDisburse: async (pushToCardDisburseRequest?: PushToCardDisburseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pushtocards/disburse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(pushToCardDisburseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an external card to which funds will be pushed
         * @param {PushToCardRequest} [pushToCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsPaymentcard: async (pushToCardRequest?: PushToCardRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pushtocards/paymentcard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(pushToCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushToCardApi - functional programming interface
 */
export const PushToCardApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = PushToCardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Lists all push-to-card disbursements
         * @param {number} [count] Number of push-to-card disbursements to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushtocardsDisburse(count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushToCardDisburseListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPushtocardsDisburse(count, fields, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushToCardApi.getPushtocardsDisburse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific push-to-card disbursement
         * @param {string} token Push-to-card disbursement token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushtocardsDisburseToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushToCardDisbursementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPushtocardsDisburseToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushToCardApi.getPushtocardsDisburseToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns all push-to-card payment card details
         * @param {string} userToken User token
         * @param {number} [count] Number of push-to-card payment cards to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushtocardsPaymentcard(userToken: string, count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushToCardListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPushtocardsPaymentcard(userToken, count, fields, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushToCardApi.getPushtocardsPaymentcard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a specific paymentcard object
         * @param {string} token Push-to-card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPushtocardsPaymentcardToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushToCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPushtocardsPaymentcardToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushToCardApi.getPushtocardsPaymentcardToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Initiates a push-to-card money disbursement
         * @param {PushToCardDisburseRequest} [pushToCardDisburseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPushtocardsDisburse(pushToCardDisburseRequest?: PushToCardDisburseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushToCardDisbursementResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPushtocardsDisburse(pushToCardDisburseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushToCardApi.postPushtocardsDisburse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Adds an external card to which funds will be pushed
         * @param {PushToCardRequest} [pushToCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPushtocardsPaymentcard(pushToCardRequest?: PushToCardRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushToCardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postPushtocardsPaymentcard(pushToCardRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PushToCardApi.postPushtocardsPaymentcard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PushToCardApi - factory interface
 */
export const PushToCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PushToCardApiFp(configuration)
    return {
        /**
         * 
         * @summary Lists all push-to-card disbursements
         * @param {number} [count] Number of push-to-card disbursements to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburse(count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<PushToCardDisburseListResponse> {
            return localVarFp.getPushtocardsDisburse(count, fields, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific push-to-card disbursement
         * @param {string} token Push-to-card disbursement token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsDisburseToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<PushToCardDisbursementResponse> {
            return localVarFp.getPushtocardsDisburseToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all push-to-card payment card details
         * @param {string} userToken User token
         * @param {number} [count] Number of push-to-card payment cards to retrieve
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {number} [startIndex] Start index
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcard(userToken: string, count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<PushToCardListResponse> {
            return localVarFp.getPushtocardsPaymentcard(userToken, count, fields, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a specific paymentcard object
         * @param {string} token Push-to-card token
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushtocardsPaymentcardToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<PushToCardResponse> {
            return localVarFp.getPushtocardsPaymentcardToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiates a push-to-card money disbursement
         * @param {PushToCardDisburseRequest} [pushToCardDisburseRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsDisburse(pushToCardDisburseRequest?: PushToCardDisburseRequest, options?: RawAxiosRequestConfig): AxiosPromise<PushToCardDisbursementResponse> {
            return localVarFp.postPushtocardsDisburse(pushToCardDisburseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds an external card to which funds will be pushed
         * @param {PushToCardRequest} [pushToCardRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPushtocardsPaymentcard(pushToCardRequest?: PushToCardRequest, options?: RawAxiosRequestConfig): AxiosPromise<PushToCardResponse> {
            return localVarFp.postPushtocardsPaymentcard(pushToCardRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PushToCardApi - object-oriented interface
 */
export class PushToCardApi extends BaseAPI {
    /**
     * 
     * @summary Lists all push-to-card disbursements
     * @param {number} [count] Number of push-to-card disbursements to retrieve
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPushtocardsDisburse(count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return PushToCardApiFp(this.configuration).getPushtocardsDisburse(count, fields, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific push-to-card disbursement
     * @param {string} token Push-to-card disbursement token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPushtocardsDisburseToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return PushToCardApiFp(this.configuration).getPushtocardsDisburseToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all push-to-card payment card details
     * @param {string} userToken User token
     * @param {number} [count] Number of push-to-card payment cards to retrieve
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {number} [startIndex] Start index
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPushtocardsPaymentcard(userToken: string, count?: number, fields?: string, startIndex?: number, sortBy?: string, options?: RawAxiosRequestConfig) {
        return PushToCardApiFp(this.configuration).getPushtocardsPaymentcard(userToken, count, fields, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a specific paymentcard object
     * @param {string} token Push-to-card token
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPushtocardsPaymentcardToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return PushToCardApiFp(this.configuration).getPushtocardsPaymentcardToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiates a push-to-card money disbursement
     * @param {PushToCardDisburseRequest} [pushToCardDisburseRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPushtocardsDisburse(pushToCardDisburseRequest?: PushToCardDisburseRequest, options?: RawAxiosRequestConfig) {
        return PushToCardApiFp(this.configuration).postPushtocardsDisburse(pushToCardDisburseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds an external card to which funds will be pushed
     * @param {PushToCardRequest} [pushToCardRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postPushtocardsPaymentcard(pushToCardRequest?: PushToCardRequest, options?: RawAxiosRequestConfig) {
        return PushToCardApiFp(this.configuration).postPushtocardsPaymentcard(pushToCardRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RealTimeFeeGroupsApi - axios parameter creator
 */
export const RealTimeFeeGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to list existing real-time fee groups.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List real-time fee groups
         * @param {number} [count] Number of real-time fee groups to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on).  Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroups: async (count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/realtimefeegroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to retrieve a specific real-time fee group. Include the real-time fee group `token` path parameter to specify the real-time fee group to return.
         * @summary Retrieve real-time fee group
         * @param {string} token Unique identifier of the real-time fee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroupsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getRealtimefeegroupsToken', 'token', token)
            const localVarPath = `/realtimefeegroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create a real-time fee group.
         * @summary Create real-time fee group
         * @param {RealTimeFeeGroupCreateRequest} [realTimeFeeGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRealtimefeegroups: async (realTimeFeeGroupCreateRequest?: RealTimeFeeGroupCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/realtimefeegroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(realTimeFeeGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to update a real-time fee group. Include the real-time fee group `token` path parameter to specify the real-time fee group to update.
         * @summary Update real-time fee group
         * @param {string} token Unique identifier of the real-time fee group.
         * @param {RealTimeFeeGroupRequest} [realTimeFeeGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRealtimefeegroupsToken: async (token: string, realTimeFeeGroupRequest?: RealTimeFeeGroupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putRealtimefeegroupsToken', 'token', token)
            const localVarPath = `/realtimefeegroups/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(realTimeFeeGroupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RealTimeFeeGroupsApi - functional programming interface
 */
export const RealTimeFeeGroupsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RealTimeFeeGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to list existing real-time fee groups.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List real-time fee groups
         * @param {number} [count] Number of real-time fee groups to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on).  Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealtimefeegroups(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealTimeFeeGroupListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimefeegroups(count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealTimeFeeGroupsApi.getRealtimefeegroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to retrieve a specific real-time fee group. Include the real-time fee group `token` path parameter to specify the real-time fee group to return.
         * @summary Retrieve real-time fee group
         * @param {string} token Unique identifier of the real-time fee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealtimefeegroupsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealTimeFeeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealtimefeegroupsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealTimeFeeGroupsApi.getRealtimefeegroupsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to create a real-time fee group.
         * @summary Create real-time fee group
         * @param {RealTimeFeeGroupCreateRequest} [realTimeFeeGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRealtimefeegroups(realTimeFeeGroupCreateRequest?: RealTimeFeeGroupCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealTimeFeeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRealtimefeegroups(realTimeFeeGroupCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealTimeFeeGroupsApi.postRealtimefeegroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to update a real-time fee group. Include the real-time fee group `token` path parameter to specify the real-time fee group to update.
         * @summary Update real-time fee group
         * @param {string} token Unique identifier of the real-time fee group.
         * @param {RealTimeFeeGroupRequest} [realTimeFeeGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putRealtimefeegroupsToken(token: string, realTimeFeeGroupRequest?: RealTimeFeeGroupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RealTimeFeeGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putRealtimefeegroupsToken(token, realTimeFeeGroupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RealTimeFeeGroupsApi.putRealtimefeegroupsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RealTimeFeeGroupsApi - factory interface
 */
export const RealTimeFeeGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RealTimeFeeGroupsApiFp(configuration)
    return {
        /**
         * Use this endpoint to list existing real-time fee groups.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List real-time fee groups
         * @param {number} [count] Number of real-time fee groups to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on).  Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroups(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<RealTimeFeeGroupListResponse> {
            return localVarFp.getRealtimefeegroups(count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to retrieve a specific real-time fee group. Include the real-time fee group `token` path parameter to specify the real-time fee group to return.
         * @summary Retrieve real-time fee group
         * @param {string} token Unique identifier of the real-time fee group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealtimefeegroupsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<RealTimeFeeGroup> {
            return localVarFp.getRealtimefeegroupsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create a real-time fee group.
         * @summary Create real-time fee group
         * @param {RealTimeFeeGroupCreateRequest} [realTimeFeeGroupCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRealtimefeegroups(realTimeFeeGroupCreateRequest?: RealTimeFeeGroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RealTimeFeeGroup> {
            return localVarFp.postRealtimefeegroups(realTimeFeeGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to update a real-time fee group. Include the real-time fee group `token` path parameter to specify the real-time fee group to update.
         * @summary Update real-time fee group
         * @param {string} token Unique identifier of the real-time fee group.
         * @param {RealTimeFeeGroupRequest} [realTimeFeeGroupRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRealtimefeegroupsToken(token: string, realTimeFeeGroupRequest?: RealTimeFeeGroupRequest, options?: RawAxiosRequestConfig): AxiosPromise<RealTimeFeeGroup> {
            return localVarFp.putRealtimefeegroupsToken(token, realTimeFeeGroupRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RealTimeFeeGroupsApi - object-oriented interface
 */
export class RealTimeFeeGroupsApi extends BaseAPI {
    /**
     * Use this endpoint to list existing real-time fee groups.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
     * @summary List real-time fee groups
     * @param {number} [count] Number of real-time fee groups to retrieve.
     * @param {number} [startIndex] The sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on).  Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRealtimefeegroups(count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return RealTimeFeeGroupsApiFp(this.configuration).getRealtimefeegroups(count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to retrieve a specific real-time fee group. Include the real-time fee group `token` path parameter to specify the real-time fee group to return.
     * @summary Retrieve real-time fee group
     * @param {string} token Unique identifier of the real-time fee group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRealtimefeegroupsToken(token: string, options?: RawAxiosRequestConfig) {
        return RealTimeFeeGroupsApiFp(this.configuration).getRealtimefeegroupsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create a real-time fee group.
     * @summary Create real-time fee group
     * @param {RealTimeFeeGroupCreateRequest} [realTimeFeeGroupCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postRealtimefeegroups(realTimeFeeGroupCreateRequest?: RealTimeFeeGroupCreateRequest, options?: RawAxiosRequestConfig) {
        return RealTimeFeeGroupsApiFp(this.configuration).postRealtimefeegroups(realTimeFeeGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to update a real-time fee group. Include the real-time fee group `token` path parameter to specify the real-time fee group to update.
     * @summary Update real-time fee group
     * @param {string} token Unique identifier of the real-time fee group.
     * @param {RealTimeFeeGroupRequest} [realTimeFeeGroupRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putRealtimefeegroupsToken(token: string, realTimeFeeGroupRequest?: RealTimeFeeGroupRequest, options?: RawAxiosRequestConfig) {
        return RealTimeFeeGroupsApiFp(this.configuration).putRealtimefeegroupsToken(token, realTimeFeeGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RefundsApi - axios parameter creator
 */
export const RefundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * api to simulate status transition of a refund.
         * @summary Simulate Refund Transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds/{refund_token}&#x60; to retrieve existing refunds.
         * @param {SimulateRefundTransitionRequest} simulateRefundTransitionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateTransitionRefund: async (accountToken: string, refundToken: string, simulateRefundTransitionRequest: SimulateRefundTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('simulateTransitionRefund', 'accountToken', accountToken)
            // verify required parameter 'refundToken' is not null or undefined
            assertParamExists('simulateTransitionRefund', 'refundToken', refundToken)
            // verify required parameter 'simulateRefundTransitionRequest' is not null or undefined
            assertParamExists('simulateTransitionRefund', 'simulateRefundTransitionRequest', simulateRefundTransitionRequest)
            const localVarPath = `/simulation/accounts/{account_token}/refunds/{refund_token}/transitions`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"refund_token"}}`, encodeURIComponent(String(refundToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(simulateRefundTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefundsApi - functional programming interface
 */
export const RefundsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RefundsApiAxiosParamCreator(configuration)
    return {
        /**
         * api to simulate status transition of a refund.
         * @summary Simulate Refund Transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds/{refund_token}&#x60; to retrieve existing refunds.
         * @param {SimulateRefundTransitionRequest} simulateRefundTransitionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateTransitionRefund(accountToken: string, refundToken: string, simulateRefundTransitionRequest: SimulateRefundTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateTransitionRefund(accountToken, refundToken, simulateRefundTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RefundsApi.simulateTransitionRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RefundsApi - factory interface
 */
export const RefundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefundsApiFp(configuration)
    return {
        /**
         * api to simulate status transition of a refund.
         * @summary Simulate Refund Transition
         * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} refundToken Unique identifier of the refund to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds/{refund_token}&#x60; to retrieve existing refunds.
         * @param {SimulateRefundTransitionRequest} simulateRefundTransitionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateTransitionRefund(accountToken: string, refundToken: string, simulateRefundTransitionRequest: SimulateRefundTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefundResponse> {
            return localVarFp.simulateTransitionRefund(accountToken, refundToken, simulateRefundTransitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefundsApi - object-oriented interface
 */
export class RefundsApi extends BaseAPI {
    /**
     * api to simulate status transition of a refund.
     * @summary Simulate Refund Transition
     * @param {string} accountToken Unique identifier of the credit account for which you want to create a balance refund.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} refundToken Unique identifier of the refund to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/refunds/{refund_token}&#x60; to retrieve existing refunds.
     * @param {SimulateRefundTransitionRequest} simulateRefundTransitionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public simulateTransitionRefund(accountToken: string, refundToken: string, simulateRefundTransitionRequest: SimulateRefundTransitionRequest, options?: RawAxiosRequestConfig) {
        return RefundsApiFp(this.configuration).simulateTransitionRefund(accountToken, refundToken, simulateRefundTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RewardsApi - axios parameter creator
 */
export const RewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the signup bonus progress, including the bonus amount and the remaining amount to be earned.
         * @summary Retrieve account signup bonus progress.
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the sign up bonus for.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSignupBonusProgress: async (accountToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveSignupBonusProgress', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/signupbonusprogress`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardsApi - functional programming interface
 */
export const RewardsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = RewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the signup bonus progress, including the bonus amount and the remaining amount to be earned.
         * @summary Retrieve account signup bonus progress.
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the sign up bonus for.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSignupBonusProgress(accountToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountSignupBonusProgressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSignupBonusProgress(accountToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.retrieveSignupBonusProgress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RewardsApi - factory interface
 */
export const RewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewardsApiFp(configuration)
    return {
        /**
         * Retrieve the signup bonus progress, including the bonus amount and the remaining amount to be earned.
         * @summary Retrieve account signup bonus progress.
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the sign up bonus for.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSignupBonusProgress(accountToken: string, options?: RawAxiosRequestConfig): AxiosPromise<AccountSignupBonusProgressResponse> {
            return localVarFp.retrieveSignupBonusProgress(accountToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewardsApi - object-oriented interface
 */
export class RewardsApi extends BaseAPI {
    /**
     * Retrieve the signup bonus progress, including the bonus amount and the remaining amount to be earned.
     * @summary Retrieve account signup bonus progress.
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the sign up bonus for.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveSignupBonusProgress(accountToken: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).retrieveSignupBonusProgress(accountToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SimulateApi - axios parameter creator
 */
export const SimulateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Simulates an authorization
         * @param {AuthRequestModel} [authRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorization: async (authRequestModel?: AuthRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/simulate/authorization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(authRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates an authorization advice transaction
         * @param {AuthorizationAdviceModel} [authorizationAdviceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorizationAdvice: async (authorizationAdviceModel?: AuthorizationAdviceModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/simulate/authorization/advice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(authorizationAdviceModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a clearing/settlement transaction
         * @param {ClearingModel} [clearingModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateClearing: async (clearingModel?: ClearingModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/simulate/clearing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(clearingModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates the creation of direct deposit
         * @param {DirectDepositRequest} directDepositRequest Direct deposit simulate request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateDirectdeposits: async (directDepositRequest: DirectDepositRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directDepositRequest' is not null or undefined
            assertParamExists('postSimulateDirectdeposits', 'directDepositRequest', directDepositRequest)
            const localVarPath = `/simulate/directdeposits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(directDepositRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a financial request (PIN debit) transaction with optional cash back
         * @param {FinancialRequestModel} financialRequestModel Financial request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancial: async (financialRequestModel: FinancialRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'financialRequestModel' is not null or undefined
            assertParamExists('postSimulateFinancial', 'financialRequestModel', financialRequestModel)
            const localVarPath = `/simulate/financial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(financialRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a financial advice transaction
         * @param {AuthorizationAdviceModel} authorizationAdviceModel Financial advice request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialAdvice: async (authorizationAdviceModel: AuthorizationAdviceModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationAdviceModel' is not null or undefined
            assertParamExists('postSimulateFinancialAdvice', 'authorizationAdviceModel', authorizationAdviceModel)
            const localVarPath = `/simulate/financial/advice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(authorizationAdviceModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a balance inquiry
         * @param {BalanceInquiryRequestModel} balanceInquiryRequestModel Balance inquiry request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialBalanceinquiry: async (balanceInquiryRequestModel: BalanceInquiryRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'balanceInquiryRequestModel' is not null or undefined
            assertParamExists('postSimulateFinancialBalanceinquiry', 'balanceInquiryRequestModel', balanceInquiryRequestModel)
            const localVarPath = `/simulate/financial/balanceinquiry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(balanceInquiryRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates an orignal credit transaction
         * @param {OrignalcreditRequestModel} orignalcreditRequestModel Orignal Credit request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialOriginalcredit: async (orignalcreditRequestModel: OrignalcreditRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orignalcreditRequestModel' is not null or undefined
            assertParamExists('postSimulateFinancialOriginalcredit', 'orignalcreditRequestModel', orignalcreditRequestModel)
            const localVarPath = `/simulate/financial/originalcredit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(orignalcreditRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates an ATM withdrawal transaction
         * @param {WithdrawalRequestModel} withdrawalRequestModel ATM withdrawal request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialWithdrawal: async (withdrawalRequestModel: WithdrawalRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalRequestModel' is not null or undefined
            assertParamExists('postSimulateFinancialWithdrawal', 'withdrawalRequestModel', withdrawalRequestModel)
            const localVarPath = `/simulate/financial/withdrawal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawalRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Simulates a reversal transaction
         * @param {ReversalModel} [reversalModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateReversal: async (reversalModel?: ReversalModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/simulate/reversal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(reversalModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimulateApi - functional programming interface
 */
export const SimulateApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = SimulateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Simulates an authorization
         * @param {AuthRequestModel} [authRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateAuthorization(authRequestModel?: AuthRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateAuthorization(authRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateAuthorization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates an authorization advice transaction
         * @param {AuthorizationAdviceModel} [authorizationAdviceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateAuthorizationAdvice(authorizationAdviceModel?: AuthorizationAdviceModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateAuthorizationAdvice(authorizationAdviceModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateAuthorizationAdvice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates a clearing/settlement transaction
         * @param {ClearingModel} [clearingModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateClearing(clearingModel?: ClearingModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateClearing(clearingModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateClearing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates the creation of direct deposit
         * @param {DirectDepositRequest} directDepositRequest Direct deposit simulate request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateDirectdeposits(directDepositRequest: DirectDepositRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DepositDepositResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateDirectdeposits(directDepositRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateDirectdeposits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates a financial request (PIN debit) transaction with optional cash back
         * @param {FinancialRequestModel} financialRequestModel Financial request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateFinancial(financialRequestModel: FinancialRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateFinancial(financialRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateFinancial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates a financial advice transaction
         * @param {AuthorizationAdviceModel} authorizationAdviceModel Financial advice request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateFinancialAdvice(authorizationAdviceModel: AuthorizationAdviceModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateFinancialAdvice(authorizationAdviceModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateFinancialAdvice']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates a balance inquiry
         * @param {BalanceInquiryRequestModel} balanceInquiryRequestModel Balance inquiry request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateFinancialBalanceinquiry(balanceInquiryRequestModel: BalanceInquiryRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateFinancialBalanceinquiry(balanceInquiryRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateFinancialBalanceinquiry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates an orignal credit transaction
         * @param {OrignalcreditRequestModel} orignalcreditRequestModel Orignal Credit request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateFinancialOriginalcredit(orignalcreditRequestModel: OrignalcreditRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateFinancialOriginalcredit(orignalcreditRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateFinancialOriginalcredit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates an ATM withdrawal transaction
         * @param {WithdrawalRequestModel} withdrawalRequestModel ATM withdrawal request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateFinancialWithdrawal(withdrawalRequestModel: WithdrawalRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateFinancialWithdrawal(withdrawalRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateFinancialWithdrawal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Simulates a reversal transaction
         * @param {ReversalModel} [reversalModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSimulateReversal(reversalModel?: ReversalModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSimulateReversal(reversalModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulateApi.postSimulateReversal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SimulateApi - factory interface
 */
export const SimulateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SimulateApiFp(configuration)
    return {
        /**
         * 
         * @summary Simulates an authorization
         * @param {AuthRequestModel} [authRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorization(authRequestModel?: AuthRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateAuthorization(authRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates an authorization advice transaction
         * @param {AuthorizationAdviceModel} [authorizationAdviceModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateAuthorizationAdvice(authorizationAdviceModel?: AuthorizationAdviceModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateAuthorizationAdvice(authorizationAdviceModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates a clearing/settlement transaction
         * @param {ClearingModel} [clearingModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateClearing(clearingModel?: ClearingModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateClearing(clearingModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates the creation of direct deposit
         * @param {DirectDepositRequest} directDepositRequest Direct deposit simulate request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateDirectdeposits(directDepositRequest: DirectDepositRequest, options?: RawAxiosRequestConfig): AxiosPromise<DepositDepositResponse> {
            return localVarFp.postSimulateDirectdeposits(directDepositRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates a financial request (PIN debit) transaction with optional cash back
         * @param {FinancialRequestModel} financialRequestModel Financial request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancial(financialRequestModel: FinancialRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateFinancial(financialRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates a financial advice transaction
         * @param {AuthorizationAdviceModel} authorizationAdviceModel Financial advice request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialAdvice(authorizationAdviceModel: AuthorizationAdviceModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateFinancialAdvice(authorizationAdviceModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates a balance inquiry
         * @param {BalanceInquiryRequestModel} balanceInquiryRequestModel Balance inquiry request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialBalanceinquiry(balanceInquiryRequestModel: BalanceInquiryRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateFinancialBalanceinquiry(balanceInquiryRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates an orignal credit transaction
         * @param {OrignalcreditRequestModel} orignalcreditRequestModel Orignal Credit request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialOriginalcredit(orignalcreditRequestModel: OrignalcreditRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateFinancialOriginalcredit(orignalcreditRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates an ATM withdrawal transaction
         * @param {WithdrawalRequestModel} withdrawalRequestModel ATM withdrawal request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateFinancialWithdrawal(withdrawalRequestModel: WithdrawalRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateFinancialWithdrawal(withdrawalRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Simulates a reversal transaction
         * @param {ReversalModel} [reversalModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSimulateReversal(reversalModel?: ReversalModel, options?: RawAxiosRequestConfig): AxiosPromise<SimulationResponseModel> {
            return localVarFp.postSimulateReversal(reversalModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SimulateApi - object-oriented interface
 */
export class SimulateApi extends BaseAPI {
    /**
     * 
     * @summary Simulates an authorization
     * @param {AuthRequestModel} [authRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateAuthorization(authRequestModel?: AuthRequestModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateAuthorization(authRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates an authorization advice transaction
     * @param {AuthorizationAdviceModel} [authorizationAdviceModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateAuthorizationAdvice(authorizationAdviceModel?: AuthorizationAdviceModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateAuthorizationAdvice(authorizationAdviceModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates a clearing/settlement transaction
     * @param {ClearingModel} [clearingModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateClearing(clearingModel?: ClearingModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateClearing(clearingModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates the creation of direct deposit
     * @param {DirectDepositRequest} directDepositRequest Direct deposit simulate request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateDirectdeposits(directDepositRequest: DirectDepositRequest, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateDirectdeposits(directDepositRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates a financial request (PIN debit) transaction with optional cash back
     * @param {FinancialRequestModel} financialRequestModel Financial request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateFinancial(financialRequestModel: FinancialRequestModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateFinancial(financialRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates a financial advice transaction
     * @param {AuthorizationAdviceModel} authorizationAdviceModel Financial advice request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateFinancialAdvice(authorizationAdviceModel: AuthorizationAdviceModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateFinancialAdvice(authorizationAdviceModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates a balance inquiry
     * @param {BalanceInquiryRequestModel} balanceInquiryRequestModel Balance inquiry request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateFinancialBalanceinquiry(balanceInquiryRequestModel: BalanceInquiryRequestModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateFinancialBalanceinquiry(balanceInquiryRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates an orignal credit transaction
     * @param {OrignalcreditRequestModel} orignalcreditRequestModel Orignal Credit request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateFinancialOriginalcredit(orignalcreditRequestModel: OrignalcreditRequestModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateFinancialOriginalcredit(orignalcreditRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates an ATM withdrawal transaction
     * @param {WithdrawalRequestModel} withdrawalRequestModel ATM withdrawal request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateFinancialWithdrawal(withdrawalRequestModel: WithdrawalRequestModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateFinancialWithdrawal(withdrawalRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Simulates a reversal transaction
     * @param {ReversalModel} [reversalModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postSimulateReversal(reversalModel?: ReversalModel, options?: RawAxiosRequestConfig) {
        return SimulateApiFp(this.configuration).postSimulateReversal(reversalModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatementsApi - axios parameter creator
 */
export const StatementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a single payment reminder on a specific statement summary
         * @summary Get payment reminder
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment reminder. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary for which you want to retrieve the statement payment reminder. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {string} token Unique identifier of the payment reminder you want to retrieve. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentReminder: async (accountToken: string, statementSummaryToken: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getPaymentReminder', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('getPaymentReminder', 'statementSummaryToken', statementSummaryToken)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getPaymentReminder', 'token', token)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of payment reminder details for a specific statement summary token.
         * @summary List payment reminders by statement summary
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment information. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the payment information. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of payment reminder resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetPaymentRemindersByStatementSummarySortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order. *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRemindersByStatementSummary: async (accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, sortBy?: GetPaymentRemindersByStatementSummarySortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getPaymentRemindersByStatementSummary', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('getPaymentRemindersByStatementSummary', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of statement files for a specific credit account.
         * @summary List files for an account
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve statement files.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Start date of the date range for which to return statement files.
         * @param {string} [endDate] End date of the date range for which to return statement files.
         * @param {number} [count] Number of statement file resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetStatementFilesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementFilesByAccount: async (accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: GetStatementFilesByAccountSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getStatementFilesByAccount', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/statements/files`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of statement summaries tied to a cardholder\'s account.  The statement summary, which is a summary of account activity on a statement, provides account holders with a synopsis of activity that occurred on the account during a specified billing cycle.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>. You can use optional query parameters to return a statement based on its exact opening or closing date, or a statement whose closing date falls within a range of dates.
         * @summary List account statement summaries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve statement summaries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Returns statements with a matching opening date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
         * @param {string} [endDate] Returns statements with a matching closing date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
         * @param {number} [count] Number of account statement resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetStatementSummariesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementSummariesByAccount: async (accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: GetStatementSummariesByAccountSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getStatementSummariesByAccount', 'accountToken', accountToken)
            const localVarPath = `/accounts/{account_token}/statements`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of journal entries on a credit account\'s statement summary.  This endpoint supports <</core-api/sorting-and-pagination, sorting>>.
         * @summary List account statement journal entries
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the statement journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of journal entry resources to return.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {Array<ListStatementJournalEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListStatementJournalEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStatementJournalEntries: async (accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, expand?: Array<ListStatementJournalEntriesExpandEnum>, sortBy?: ListStatementJournalEntriesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('listStatementJournalEntries', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('listStatementJournalEntries', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/journalentries`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [IMPORTANT] This feature is being deprecated and replaced by statement journal entries. To list statement journal entries, see <</core-api/credit-account-journal-entries#listStatementJournalEntries, List account statement journal entries>>.  Retrieve an array of ledger entries on a credit account\'s statement summary.  This endpoint supports <</core-api/sorting-and-pagination, sorting>>.
         * @summary List account statement ledger entries
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the statement ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {Array<ListStatementLedgerEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListStatementLedgerEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStatementLedgerEntries: async (accountToken: string, statementSummaryToken: string, expand?: Array<ListStatementLedgerEntriesExpandEnum>, sortBy?: ListStatementLedgerEntriesSortByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('listStatementLedgerEntries', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('listStatementLedgerEntries', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/ledgerentries`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent: async (eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('resendWebhookEvent', 'eventType', eventType)
            // verify required parameter 'resourceToken' is not null or undefined
            assertParamExists('resendWebhookEvent', 'resourceToken', resourceToken)
            const localVarPath = `/webhooks/{event_type}/{resource_token}`
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"resource_token"}}`, encodeURIComponent(String(resourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an array of statement files for a specific statement summary.
         * @summary List files for a statement summary
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve statement files for a statement summary.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary whose statement files you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of statement files to return.
         * @param {number} [startIndex] Sort order index from which to begin returning files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementFiles: async (accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveStatementFiles', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('retrieveStatementFiles', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/files`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the interest charges on a credit account\'s statement summary.
         * @summary Retrieve account statement interest charges
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement interest charges.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the interest charges.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementInterestCharges: async (accountToken: string, statementSummaryToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveStatementInterestCharges', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('retrieveStatementInterestCharges', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/interestcharges`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the payment information on a credit account\'s statement summary.
         * @summary Retrieve account statement payment information
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment information.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the payment information.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementPaymentInfo: async (accountToken: string, statementSummaryToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveStatementPaymentInfo', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('retrieveStatementPaymentInfo', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/paymentinfo`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the rewards on a credit account\'s statement summary.
         * @summary Retrieve account statement rewards
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve statement rewards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve rewards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementReward: async (accountToken: string, statementSummaryToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveStatementReward', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('retrieveStatementReward', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/rewards`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a statement summary for a credit account.
         * @summary Retrieve account statement summary
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a statement summary.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementSummary: async (accountToken: string, statementSummaryToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveStatementSummary', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('retrieveStatementSummary', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the year-to-date fee and interest totals on a credit account\'s statement summary.
         * @summary Retrieve account statement year-to-date totals
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve statement year-to-date totals.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve year-to-date totals.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveYearToDateForStatementSummary: async (accountToken: string, statementSummaryToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('retrieveYearToDateForStatementSummary', 'accountToken', accountToken)
            // verify required parameter 'statementSummaryToken' is not null or undefined
            assertParamExists('retrieveYearToDateForStatementSummary', 'statementSummaryToken', statementSummaryToken)
            const localVarPath = `/accounts/{account_token}/statements/{statement_summary_token}/yeartodate`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)))
                .replace(`{${"statement_summary_token"}}`, encodeURIComponent(String(statementSummaryToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatementsApi - functional programming interface
 */
export const StatementsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = StatementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a single payment reminder on a specific statement summary
         * @summary Get payment reminder
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment reminder. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary for which you want to retrieve the statement payment reminder. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {string} token Unique identifier of the payment reminder you want to retrieve. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentReminder(accountToken: string, statementSummaryToken: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentReminderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentReminder(accountToken, statementSummaryToken, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.getPaymentReminder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of payment reminder details for a specific statement summary token.
         * @summary List payment reminders by statement summary
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment information. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the payment information. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of payment reminder resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetPaymentRemindersByStatementSummarySortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order. *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentRemindersByStatementSummary(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, sortBy?: GetPaymentRemindersByStatementSummarySortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentReminderPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentRemindersByStatementSummary(accountToken, statementSummaryToken, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.getPaymentRemindersByStatementSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of statement files for a specific credit account.
         * @summary List files for an account
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve statement files.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Start date of the date range for which to return statement files.
         * @param {string} [endDate] End date of the date range for which to return statement files.
         * @param {number} [count] Number of statement file resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetStatementFilesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementFilesByAccount(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: GetStatementFilesByAccountSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementFilePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementFilesByAccount(accountToken, startDate, endDate, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.getStatementFilesByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of statement summaries tied to a cardholder\'s account.  The statement summary, which is a summary of account activity on a statement, provides account holders with a synopsis of activity that occurred on the account during a specified billing cycle.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>. You can use optional query parameters to return a statement based on its exact opening or closing date, or a statement whose closing date falls within a range of dates.
         * @summary List account statement summaries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve statement summaries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Returns statements with a matching opening date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
         * @param {string} [endDate] Returns statements with a matching closing date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
         * @param {number} [count] Number of account statement resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetStatementSummariesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementSummariesByAccount(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: GetStatementSummariesByAccountSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementSummaryPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementSummariesByAccount(accountToken, startDate, endDate, count, startIndex, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.getStatementSummariesByAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of journal entries on a credit account\'s statement summary.  This endpoint supports <</core-api/sorting-and-pagination, sorting>>.
         * @summary List account statement journal entries
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the statement journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of journal entry resources to return.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {Array<ListStatementJournalEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListStatementJournalEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStatementJournalEntries(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, expand?: Array<ListStatementJournalEntriesExpandEnum>, sortBy?: ListStatementJournalEntriesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalEntriesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStatementJournalEntries(accountToken, statementSummaryToken, count, startIndex, expand, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.listStatementJournalEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [IMPORTANT] This feature is being deprecated and replaced by statement journal entries. To list statement journal entries, see <</core-api/credit-account-journal-entries#listStatementJournalEntries, List account statement journal entries>>.  Retrieve an array of ledger entries on a credit account\'s statement summary.  This endpoint supports <</core-api/sorting-and-pagination, sorting>>.
         * @summary List account statement ledger entries
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the statement ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {Array<ListStatementLedgerEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListStatementLedgerEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStatementLedgerEntries(accountToken: string, statementSummaryToken: string, expand?: Array<ListStatementLedgerEntriesExpandEnum>, sortBy?: ListStatementLedgerEntriesSortByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LedgerEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStatementLedgerEntries(accountToken, statementSummaryToken, expand, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.listStatementLedgerEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookEventResendContainerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendWebhookEvent(eventType, resourceToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.resendWebhookEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an array of statement files for a specific statement summary.
         * @summary List files for a statement summary
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve statement files for a statement summary.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary whose statement files you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of statement files to return.
         * @param {number} [startIndex] Sort order index from which to begin returning files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStatementFiles(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementFilePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStatementFiles(accountToken, statementSummaryToken, count, startIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.retrieveStatementFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the interest charges on a credit account\'s statement summary.
         * @summary Retrieve account statement interest charges
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement interest charges.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the interest charges.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStatementInterestCharges(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementInterestChargesPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStatementInterestCharges(accountToken, statementSummaryToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.retrieveStatementInterestCharges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the payment information on a credit account\'s statement summary.
         * @summary Retrieve account statement payment information
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment information.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the payment information.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStatementPaymentInfo(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementPaymentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStatementPaymentInfo(accountToken, statementSummaryToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.retrieveStatementPaymentInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rewards on a credit account\'s statement summary.
         * @summary Retrieve account statement rewards
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve statement rewards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve rewards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStatementReward(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementReward>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStatementReward(accountToken, statementSummaryToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.retrieveStatementReward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a statement summary for a credit account.
         * @summary Retrieve account statement summary
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a statement summary.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStatementSummary(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatementSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStatementSummary(accountToken, statementSummaryToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.retrieveStatementSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the year-to-date fee and interest totals on a credit account\'s statement summary.
         * @summary Retrieve account statement year-to-date totals
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve statement year-to-date totals.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve year-to-date totals.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveYearToDateForStatementSummary(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<YearToDate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveYearToDateForStatementSummary(accountToken, statementSummaryToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatementsApi.retrieveYearToDateForStatementSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatementsApi - factory interface
 */
export const StatementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatementsApiFp(configuration)
    return {
        /**
         * Retrieve a single payment reminder on a specific statement summary
         * @summary Get payment reminder
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment reminder. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary for which you want to retrieve the statement payment reminder. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {string} token Unique identifier of the payment reminder you want to retrieve. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentReminder(accountToken: string, statementSummaryToken: string, token: string, options?: RawAxiosRequestConfig): AxiosPromise<PaymentReminderResponse> {
            return localVarFp.getPaymentReminder(accountToken, statementSummaryToken, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of payment reminder details for a specific statement summary token.
         * @summary List payment reminders by statement summary
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment information. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the payment information. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of payment reminder resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetPaymentRemindersByStatementSummarySortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order. *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentRemindersByStatementSummary(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, sortBy?: GetPaymentRemindersByStatementSummarySortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<PaymentReminderPage> {
            return localVarFp.getPaymentRemindersByStatementSummary(accountToken, statementSummaryToken, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of statement files for a specific credit account.
         * @summary List files for an account
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve statement files.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Start date of the date range for which to return statement files.
         * @param {string} [endDate] End date of the date range for which to return statement files.
         * @param {number} [count] Number of statement file resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetStatementFilesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementFilesByAccount(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: GetStatementFilesByAccountSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<StatementFilePage> {
            return localVarFp.getStatementFilesByAccount(accountToken, startDate, endDate, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of statement summaries tied to a cardholder\'s account.  The statement summary, which is a summary of account activity on a statement, provides account holders with a synopsis of activity that occurred on the account during a specified billing cycle.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>. You can use optional query parameters to return a statement based on its exact opening or closing date, or a statement whose closing date falls within a range of dates.
         * @summary List account statement summaries
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve statement summaries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} [startDate] Returns statements with a matching opening date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
         * @param {string} [endDate] Returns statements with a matching closing date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
         * @param {number} [count] Number of account statement resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {GetStatementSummariesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementSummariesByAccount(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: GetStatementSummariesByAccountSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<StatementSummaryPage> {
            return localVarFp.getStatementSummariesByAccount(accountToken, startDate, endDate, count, startIndex, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of journal entries on a credit account\'s statement summary.  This endpoint supports <</core-api/sorting-and-pagination, sorting>>.
         * @summary List account statement journal entries
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the statement journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of journal entry resources to return.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {Array<ListStatementJournalEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListStatementJournalEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStatementJournalEntries(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, expand?: Array<ListStatementJournalEntriesExpandEnum>, sortBy?: ListStatementJournalEntriesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<JournalEntriesPage> {
            return localVarFp.listStatementJournalEntries(accountToken, statementSummaryToken, count, startIndex, expand, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * [IMPORTANT] This feature is being deprecated and replaced by statement journal entries. To list statement journal entries, see <</core-api/credit-account-journal-entries#listStatementJournalEntries, List account statement journal entries>>.  Retrieve an array of ledger entries on a credit account\'s statement summary.  This endpoint supports <</core-api/sorting-and-pagination, sorting>>.
         * @summary List account statement ledger entries
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve the statement ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {Array<ListStatementLedgerEntriesExpandEnum>} [expand] Embeds the specified object into the response.
         * @param {ListStatementLedgerEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStatementLedgerEntries(accountToken: string, statementSummaryToken: string, expand?: Array<ListStatementLedgerEntriesExpandEnum>, sortBy?: ListStatementLedgerEntriesSortByEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<LedgerEntry>> {
            return localVarFp.listStatementLedgerEntries(accountToken, statementSummaryToken, expand, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
         * @summary Resend credit event notification
         * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookEventResendContainerResponse> {
            return localVarFp.resendWebhookEvent(eventType, resourceToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an array of statement files for a specific statement summary.
         * @summary List files for a statement summary
         * @param {string} accountToken Unique identifier of the credit account for which to retrieve statement files for a statement summary.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary whose statement files you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements&#x60; to retrieve existing statement summary tokens.
         * @param {number} [count] Number of statement files to return.
         * @param {number} [startIndex] Sort order index from which to begin returning files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementFiles(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<StatementFilePage> {
            return localVarFp.retrieveStatementFiles(accountToken, statementSummaryToken, count, startIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the interest charges on a credit account\'s statement summary.
         * @summary Retrieve account statement interest charges
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement interest charges.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the interest charges.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementInterestCharges(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): AxiosPromise<StatementInterestChargesPage> {
            return localVarFp.retrieveStatementInterestCharges(accountToken, statementSummaryToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the payment information on a credit account\'s statement summary.
         * @summary Retrieve account statement payment information
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment information.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the payment information.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementPaymentInfo(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): AxiosPromise<StatementPaymentInfo> {
            return localVarFp.retrieveStatementPaymentInfo(accountToken, statementSummaryToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rewards on a credit account\'s statement summary.
         * @summary Retrieve account statement rewards
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve statement rewards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve rewards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementReward(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): AxiosPromise<StatementReward> {
            return localVarFp.retrieveStatementReward(accountToken, statementSummaryToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a statement summary for a credit account.
         * @summary Retrieve account statement summary
         * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a statement summary.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStatementSummary(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): AxiosPromise<StatementSummary> {
            return localVarFp.retrieveStatementSummary(accountToken, statementSummaryToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the year-to-date fee and interest totals on a credit account\'s statement summary.
         * @summary Retrieve account statement year-to-date totals
         * @param {string} accountToken Unique identifier of the credit account from which to retrieve statement year-to-date totals.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
         * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve year-to-date totals.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveYearToDateForStatementSummary(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig): AxiosPromise<YearToDate> {
            return localVarFp.retrieveYearToDateForStatementSummary(accountToken, statementSummaryToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatementsApi - object-oriented interface
 */
export class StatementsApi extends BaseAPI {
    /**
     * Retrieve a single payment reminder on a specific statement summary
     * @summary Get payment reminder
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment reminder. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary for which you want to retrieve the statement payment reminder. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {string} token Unique identifier of the payment reminder you want to retrieve. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPaymentReminder(accountToken: string, statementSummaryToken: string, token: string, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).getPaymentReminder(accountToken, statementSummaryToken, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of payment reminder details for a specific statement summary token.
     * @summary List payment reminders by statement summary
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment information. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the payment information. Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {number} [count] Number of payment reminder resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetPaymentRemindersByStatementSummarySortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order. *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPaymentRemindersByStatementSummary(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, sortBy?: GetPaymentRemindersByStatementSummarySortByEnum, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).getPaymentRemindersByStatementSummary(accountToken, statementSummaryToken, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of statement files for a specific credit account.
     * @summary List files for an account
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve statement files.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} [startDate] Start date of the date range for which to return statement files.
     * @param {string} [endDate] End date of the date range for which to return statement files.
     * @param {number} [count] Number of statement file resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetStatementFilesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatementFilesByAccount(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: GetStatementFilesByAccountSortByEnum, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).getStatementFilesByAccount(accountToken, startDate, endDate, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of statement summaries tied to a cardholder\'s account.  The statement summary, which is a summary of account activity on a statement, provides account holders with a synopsis of activity that occurred on the account during a specified billing cycle.  This endpoint supports <</core-api/sorting-and-pagination, sorting and pagination>>. You can use optional query parameters to return a statement based on its exact opening or closing date, or a statement whose closing date falls within a range of dates.
     * @summary List account statement summaries
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve statement summaries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} [startDate] Returns statements with a matching opening date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
     * @param {string} [endDate] Returns statements with a matching closing date.  If both &#x60;start_date&#x60; and &#x60;end_date&#x60; are specified, statements whose closing date falls between the start and end dates are returned.
     * @param {number} [count] Number of account statement resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {GetStatementSummariesByAccountSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;createdTime&#x60;, and not by the field names appearing in response bodies such as &#x60;created_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatementSummariesByAccount(accountToken: string, startDate?: string, endDate?: string, count?: number, startIndex?: number, sortBy?: GetStatementSummariesByAccountSortByEnum, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).getStatementSummariesByAccount(accountToken, startDate, endDate, count, startIndex, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of journal entries on a credit account\'s statement summary.  This endpoint supports <</core-api/sorting-and-pagination, sorting>>.
     * @summary List account statement journal entries
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve the statement journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve journal entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {number} [count] Number of journal entry resources to return.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {Array<ListStatementJournalEntriesExpandEnum>} [expand] Embeds the specified object into the response.
     * @param {ListStatementJournalEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listStatementJournalEntries(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, expand?: Array<ListStatementJournalEntriesExpandEnum>, sortBy?: ListStatementJournalEntriesSortByEnum, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).listStatementJournalEntries(accountToken, statementSummaryToken, count, startIndex, expand, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [IMPORTANT] This feature is being deprecated and replaced by statement journal entries. To list statement journal entries, see <</core-api/credit-account-journal-entries#listStatementJournalEntries, List account statement journal entries>>.  Retrieve an array of ledger entries on a credit account\'s statement summary.  This endpoint supports <</core-api/sorting-and-pagination, sorting>>.
     * @summary List account statement ledger entries
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve the statement ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve ledger entries.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {Array<ListStatementLedgerEntriesExpandEnum>} [expand] Embeds the specified object into the response.
     * @param {ListStatementLedgerEntriesSortByEnum} [sortBy] Field on which to sort. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.  *NOTE:* You must sort using system field names such as &#x60;lastModifiedTime&#x60;, and not by the field names appearing in response bodies such as &#x60;last_modified_time&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listStatementLedgerEntries(accountToken: string, statementSummaryToken: string, expand?: Array<ListStatementLedgerEntriesExpandEnum>, sortBy?: ListStatementLedgerEntriesSortByEnum, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).listStatementLedgerEntries(accountToken, statementSummaryToken, expand, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends a credit event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and also returned in the response to this request.  For details on how to configure your webhook endpoint, see the About Webhooks <</developer-guides/about-webhooks#_tutorial, tutorial>>. For the complete `/webhooks` endpoint reference, see <</core-api/webhooks, Webhooks>>.
     * @summary Resend credit event notification
     * @param {ResendWebhookEventEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} resourceToken Unique identifier of the resource for which you want to resend a notification.  * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/journalentries&#x60; to retrieve existing journal entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/ledgerentries&#x60; to retrieve existing ledger entry tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/accounttransitions&#x60; to retrieve existing account transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{account_token}/payments/{payment_token}&#x60; to retrieve existing payment transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements&#x60; to retrieve existing statement summary tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/delinquencystate/transitions&#x60; to retrieve existing delinquency state transition tokens. * Send a &#x60;GET&#x60; request to &#x60;/accounts/{account_token}/statements/{statement_summary_token}/paymentreminders/{token}&#x60; to retrieve existing payment reminder tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/substatuses&#x60; to retrieve existing substatus tokens. * Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens and identify the specific account for the resend event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendWebhookEvent(eventType: ResendWebhookEventEventTypeEnum, resourceToken: string, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).resendWebhookEvent(eventType, resourceToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an array of statement files for a specific statement summary.
     * @summary List files for a statement summary
     * @param {string} accountToken Unique identifier of the credit account for which to retrieve statement files for a statement summary.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary whose statement files you want to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements&#x60; to retrieve existing statement summary tokens.
     * @param {number} [count] Number of statement files to return.
     * @param {number} [startIndex] Sort order index from which to begin returning files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveStatementFiles(accountToken: string, statementSummaryToken: string, count?: number, startIndex?: number, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).retrieveStatementFiles(accountToken, statementSummaryToken, count, startIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the interest charges on a credit account\'s statement summary.
     * @summary Retrieve account statement interest charges
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement interest charges.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the interest charges.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveStatementInterestCharges(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).retrieveStatementInterestCharges(accountToken, statementSummaryToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the payment information on a credit account\'s statement summary.
     * @summary Retrieve account statement payment information
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve the statement payment information.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve the payment information.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveStatementPaymentInfo(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).retrieveStatementPaymentInfo(accountToken, statementSummaryToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the rewards on a credit account\'s statement summary.
     * @summary Retrieve account statement rewards
     * @param {string} accountToken Unique identifier of the credit account from which to retrieve statement rewards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve rewards.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveStatementReward(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).retrieveStatementReward(accountToken, statementSummaryToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a statement summary for a credit account.
     * @summary Retrieve account statement summary
     * @param {string} accountToken Unique identifier of the credit account for which you want to retrieve a statement summary.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary to retrieve.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveStatementSummary(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).retrieveStatementSummary(accountToken, statementSummaryToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the year-to-date fee and interest totals on a credit account\'s statement summary.
     * @summary Retrieve account statement year-to-date totals
     * @param {string} accountToken Unique identifier of the credit account from which to retrieve statement year-to-date totals.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts&#x60; to retrieve existing credit account tokens.
     * @param {string} statementSummaryToken Unique identifier of the statement summary from which to retrieve year-to-date totals.  Send a &#x60;GET&#x60; request to &#x60;/credit/accounts/{token}/statements/&#x60; to retrieve existing statement summary tokens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public retrieveYearToDateForStatementSummary(accountToken: string, statementSummaryToken: string, options?: RawAxiosRequestConfig) {
        return StatementsApiFp(this.configuration).retrieveYearToDateForStatementSummary(accountToken, statementSummaryToken, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetPaymentRemindersByStatementSummarySortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime'
} as const;
export type GetPaymentRemindersByStatementSummarySortByEnum = typeof GetPaymentRemindersByStatementSummarySortByEnum[keyof typeof GetPaymentRemindersByStatementSummarySortByEnum];
export const GetStatementFilesByAccountSortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime'
} as const;
export type GetStatementFilesByAccountSortByEnum = typeof GetStatementFilesByAccountSortByEnum[keyof typeof GetStatementFilesByAccountSortByEnum];
export const GetStatementSummariesByAccountSortByEnum = {
    CreatedTime: 'createdTime',
    CreatedTime2: '-createdTime'
} as const;
export type GetStatementSummariesByAccountSortByEnum = typeof GetStatementSummariesByAccountSortByEnum[keyof typeof GetStatementSummariesByAccountSortByEnum];
export const ListStatementJournalEntriesExpandEnum = {
    DetailObject: 'detailObject',
    OriginalCurrency: 'originalCurrency'
} as const;
export type ListStatementJournalEntriesExpandEnum = typeof ListStatementJournalEntriesExpandEnum[keyof typeof ListStatementJournalEntriesExpandEnum];
export const ListStatementJournalEntriesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListStatementJournalEntriesSortByEnum = typeof ListStatementJournalEntriesSortByEnum[keyof typeof ListStatementJournalEntriesSortByEnum];
export const ListStatementLedgerEntriesExpandEnum = {
    DetailObject: 'detailObject',
    OriginalCurrency: 'originalCurrency'
} as const;
export type ListStatementLedgerEntriesExpandEnum = typeof ListStatementLedgerEntriesExpandEnum[keyof typeof ListStatementLedgerEntriesExpandEnum];
export const ListStatementLedgerEntriesSortByEnum = {
    LastModifiedTime: 'lastModifiedTime',
    LastModifiedTime2: '-lastModifiedTime'
} as const;
export type ListStatementLedgerEntriesSortByEnum = typeof ListStatementLedgerEntriesSortByEnum[keyof typeof ListStatementLedgerEntriesSortByEnum];



/**
 * TransactionsApi - axios parameter creator
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all transactions.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, `GET /transactions` returns transactions having either `PENDING` or `COMPLETION` states.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List transactions
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {string} [userToken] The unique identifier of the user account holder.
         * @param {string} [businessToken] The unique identifier of the business account holder.
         * @param {string} [actingUserToken] The unique identifier of the acting user.
         * @param {string} [cardToken] The unique identifier of the card.
         * @param {string} [accountToken] Account token
         * @param {string} [state] Comma-delimited list of transaction states to display.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {number} [startIdentifier] Start identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsSortByEnum, startDate?: string, endDate?: string, type?: string, userToken?: string, businessToken?: string, actingUserToken?: string, cardToken?: string, accountToken?: string, state?: string, version?: string, verbose?: boolean, startIdentifier?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (userToken !== undefined) {
                localVarQueryParameter['user_token'] = userToken;
            }

            if (businessToken !== undefined) {
                localVarQueryParameter['business_token'] = businessToken;
            }

            if (actingUserToken !== undefined) {
                localVarQueryParameter['acting_user_token'] = actingUserToken;
            }

            if (cardToken !== undefined) {
                localVarQueryParameter['card_token'] = cardToken;
            }

            if (accountToken !== undefined) {
                localVarQueryParameter['account_token'] = accountToken;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }

            if (startIdentifier !== undefined) {
                localVarQueryParameter['start_identifier'] = startIdentifier;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List transactions for a specific funding source.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, `GET /transactions/fundingsource/{funding_source_token}` returns transactions having either `PENDING` or `COMPLETION` states.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List transactions for a funding account
         * @param {string} fundingSourceToken The unique identifier of the funding account.
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsFundingsourceFundingsourcetokenSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {GetTransactionsFundingsourceFundingsourcetokenPolarityEnum} [polarity] Specifies whether to return credit or debit transactions.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsFundingsourceFundingsourcetoken: async (fundingSourceToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsFundingsourceFundingsourcetokenSortByEnum, startDate?: string, endDate?: string, type?: string, polarity?: GetTransactionsFundingsourceFundingsourcetokenPolarityEnum, version?: string, verbose?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fundingSourceToken' is not null or undefined
            assertParamExists('getTransactionsFundingsourceFundingsourcetoken', 'fundingSourceToken', fundingSourceToken)
            const localVarPath = `/transactions/fundingsource/{funding_source_token}`
                .replace(`{${"funding_source_token"}}`, encodeURIComponent(String(fundingSourceToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (polarity !== undefined) {
                localVarQueryParameter['polarity'] = polarity;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a specific transaction. Include the `token` path parameter to identify the transaction.  [NOTE] Transactions are not available in real time via this endpoint, and typically appear after 30 seconds. On occasion, a transaction may require up to four hours to appear.
         * @summary Retrieve transaction
         * @param {string} token The unique identifier of the transaction.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsToken: async (token: string, fields?: string, version?: string, verbose?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getTransactionsToken', 'token', token)
            const localVarPath = `/transactions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transactions related to the specified transaction.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, this endpoint returns transactions of any state. To return transactions in specific states, you must include the `state` query parameter in your request.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List related transactions
         * @param {string} token The unique identifier of the transaction.
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsTokenRelatedSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {string} [state] Comma-delimited list of transaction states to display.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsTokenRelated: async (token: string, count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsTokenRelatedSortByEnum, startDate?: string, endDate?: string, type?: string, state?: string, version?: string, verbose?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getTransactionsTokenRelated', 'token', token)
            const localVarPath = `/transactions/{token}/related`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = endDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (verbose !== undefined) {
                localVarQueryParameter['verbose'] = verbose;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 */
export const TransactionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all transactions.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, `GET /transactions` returns transactions having either `PENDING` or `COMPLETION` states.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List transactions
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {string} [userToken] The unique identifier of the user account holder.
         * @param {string} [businessToken] The unique identifier of the business account holder.
         * @param {string} [actingUserToken] The unique identifier of the acting user.
         * @param {string} [cardToken] The unique identifier of the card.
         * @param {string} [accountToken] Account token
         * @param {string} [state] Comma-delimited list of transaction states to display.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {number} [startIdentifier] Start identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsSortByEnum, startDate?: string, endDate?: string, type?: string, userToken?: string, businessToken?: string, actingUserToken?: string, cardToken?: string, accountToken?: string, state?: string, version?: string, verbose?: boolean, startIdentifier?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionModelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(count, startIndex, fields, sortBy, startDate, endDate, type, userToken, businessToken, actingUserToken, cardToken, accountToken, state, version, verbose, startIdentifier, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List transactions for a specific funding source.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, `GET /transactions/fundingsource/{funding_source_token}` returns transactions having either `PENDING` or `COMPLETION` states.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List transactions for a funding account
         * @param {string} fundingSourceToken The unique identifier of the funding account.
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsFundingsourceFundingsourcetokenSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {GetTransactionsFundingsourceFundingsourcetokenPolarityEnum} [polarity] Specifies whether to return credit or debit transactions.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsFundingsourceFundingsourcetokenSortByEnum, startDate?: string, endDate?: string, type?: string, polarity?: GetTransactionsFundingsourceFundingsourcetokenPolarityEnum, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionModelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken, count, startIndex, fields, sortBy, startDate, endDate, type, polarity, version, verbose, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionsFundingsourceFundingsourcetoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific transaction. Include the `token` path parameter to identify the transaction.  [NOTE] Transactions are not available in real time via this endpoint, and typically appear after 30 seconds. On occasion, a transaction may require up to four hours to appear.
         * @summary Retrieve transaction
         * @param {string} token The unique identifier of the transaction.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsToken(token: string, fields?: string, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsToken(token, fields, version, verbose, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all transactions related to the specified transaction.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, this endpoint returns transactions of any state. To return transactions in specific states, you must include the `state` query parameter in your request.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List related transactions
         * @param {string} token The unique identifier of the transaction.
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsTokenRelatedSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {string} [state] Comma-delimited list of transaction states to display.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsTokenRelated(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsTokenRelatedSortByEnum, startDate?: string, endDate?: string, type?: string, state?: string, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionModelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsTokenRelated(token, count, startIndex, fields, sortBy, startDate, endDate, type, state, version, verbose, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.getTransactionsTokenRelated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * List all transactions.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, `GET /transactions` returns transactions having either `PENDING` or `COMPLETION` states.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List transactions
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {string} [userToken] The unique identifier of the user account holder.
         * @param {string} [businessToken] The unique identifier of the business account holder.
         * @param {string} [actingUserToken] The unique identifier of the acting user.
         * @param {string} [cardToken] The unique identifier of the card.
         * @param {string} [accountToken] Account token
         * @param {string} [state] Comma-delimited list of transaction states to display.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {number} [startIdentifier] Start identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsSortByEnum, startDate?: string, endDate?: string, type?: string, userToken?: string, businessToken?: string, actingUserToken?: string, cardToken?: string, accountToken?: string, state?: string, version?: string, verbose?: boolean, startIdentifier?: number, options?: RawAxiosRequestConfig): AxiosPromise<TransactionModelListResponse> {
            return localVarFp.getTransactions(count, startIndex, fields, sortBy, startDate, endDate, type, userToken, businessToken, actingUserToken, cardToken, accountToken, state, version, verbose, startIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List transactions for a specific funding source.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, `GET /transactions/fundingsource/{funding_source_token}` returns transactions having either `PENDING` or `COMPLETION` states.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List transactions for a funding account
         * @param {string} fundingSourceToken The unique identifier of the funding account.
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsFundingsourceFundingsourcetokenSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {GetTransactionsFundingsourceFundingsourcetokenPolarityEnum} [polarity] Specifies whether to return credit or debit transactions.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsFundingsourceFundingsourcetokenSortByEnum, startDate?: string, endDate?: string, type?: string, polarity?: GetTransactionsFundingsourceFundingsourcetokenPolarityEnum, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<TransactionModelListResponse> {
            return localVarFp.getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken, count, startIndex, fields, sortBy, startDate, endDate, type, polarity, version, verbose, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific transaction. Include the `token` path parameter to identify the transaction.  [NOTE] Transactions are not available in real time via this endpoint, and typically appear after 30 seconds. On occasion, a transaction may require up to four hours to appear.
         * @summary Retrieve transaction
         * @param {string} token The unique identifier of the transaction.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsToken(token: string, fields?: string, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<TransactionModel> {
            return localVarFp.getTransactionsToken(token, fields, version, verbose, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transactions related to the specified transaction.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, this endpoint returns transactions of any state. To return transactions in specific states, you must include the `state` query parameter in your request.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List related transactions
         * @param {string} token The unique identifier of the transaction.
         * @param {number} [count] The number of transactions to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {GetTransactionsTokenRelatedSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
         * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
         * @param {string} [type] Comma-delimited list of transaction types to include.
         * @param {string} [state] Comma-delimited list of transaction states to display.
         * @param {string} [version] Specifies the API version for the request.
         * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsTokenRelated(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsTokenRelatedSortByEnum, startDate?: string, endDate?: string, type?: string, state?: string, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<TransactionModelListResponse> {
            return localVarFp.getTransactionsTokenRelated(token, count, startIndex, fields, sortBy, startDate, endDate, type, state, version, verbose, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 */
export class TransactionsApi extends BaseAPI {
    /**
     * List all transactions.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, `GET /transactions` returns transactions having either `PENDING` or `COMPLETION` states.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
     * @summary List transactions
     * @param {number} [count] The number of transactions to retrieve.
     * @param {number} [startIndex] The sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {GetTransactionsSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
     * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
     * @param {string} [type] Comma-delimited list of transaction types to include.
     * @param {string} [userToken] The unique identifier of the user account holder.
     * @param {string} [businessToken] The unique identifier of the business account holder.
     * @param {string} [actingUserToken] The unique identifier of the acting user.
     * @param {string} [cardToken] The unique identifier of the card.
     * @param {string} [accountToken] Account token
     * @param {string} [state] Comma-delimited list of transaction states to display.
     * @param {string} [version] Specifies the API version for the request.
     * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
     * @param {number} [startIdentifier] Start identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactions(count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsSortByEnum, startDate?: string, endDate?: string, type?: string, userToken?: string, businessToken?: string, actingUserToken?: string, cardToken?: string, accountToken?: string, state?: string, version?: string, verbose?: boolean, startIdentifier?: number, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactions(count, startIndex, fields, sortBy, startDate, endDate, type, userToken, businessToken, actingUserToken, cardToken, accountToken, state, version, verbose, startIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List transactions for a specific funding source.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, `GET /transactions/fundingsource/{funding_source_token}` returns transactions having either `PENDING` or `COMPLETION` states.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
     * @summary List transactions for a funding account
     * @param {string} fundingSourceToken The unique identifier of the funding account.
     * @param {number} [count] The number of transactions to retrieve.
     * @param {number} [startIndex] The sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {GetTransactionsFundingsourceFundingsourcetokenSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
     * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
     * @param {string} [type] Comma-delimited list of transaction types to include.
     * @param {GetTransactionsFundingsourceFundingsourcetokenPolarityEnum} [polarity] Specifies whether to return credit or debit transactions.
     * @param {string} [version] Specifies the API version for the request.
     * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsFundingsourceFundingsourcetokenSortByEnum, startDate?: string, endDate?: string, type?: string, polarity?: GetTransactionsFundingsourceFundingsourcetokenPolarityEnum, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionsFundingsourceFundingsourcetoken(fundingSourceToken, count, startIndex, fields, sortBy, startDate, endDate, type, polarity, version, verbose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a specific transaction. Include the `token` path parameter to identify the transaction.  [NOTE] Transactions are not available in real time via this endpoint, and typically appear after 30 seconds. On occasion, a transaction may require up to four hours to appear.
     * @summary Retrieve transaction
     * @param {string} token The unique identifier of the transaction.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [version] Specifies the API version for the request.
     * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactionsToken(token: string, fields?: string, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionsToken(token, fields, version, verbose, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transactions related to the specified transaction.  By default, this endpoint returns transactions conducted within the last 30 days. To return transactions older than 30 days, you must include the `start_date` and `end_date` query parameters in your request.  By default, this endpoint returns transactions of any state. To return transactions in specific states, you must include the `state` query parameter in your request.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
     * @summary List related transactions
     * @param {string} token The unique identifier of the transaction.
     * @param {number} [count] The number of transactions to retrieve.
     * @param {number} [startIndex] The sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {GetTransactionsTokenRelatedSortByEnum} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {string} [startDate] The starting date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;start_date&#x60; and &#x60;end_date&#x60; fields.
     * @param {string} [endDate] The ending date (or date-time) of a date range from which to return transactions. To return transactions for a single day, enter the same date in both the &#x60;end_date&#x60; and &#x60;start_date&#x60; fields.
     * @param {string} [type] Comma-delimited list of transaction types to include.
     * @param {string} [state] Comma-delimited list of transaction states to display.
     * @param {string} [version] Specifies the API version for the request.
     * @param {boolean} [verbose] If &#x60;true&#x60;, the query returns additional information for diagnostic purposes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactionsTokenRelated(token: string, count?: number, startIndex?: number, fields?: string, sortBy?: GetTransactionsTokenRelatedSortByEnum, startDate?: string, endDate?: string, type?: string, state?: string, version?: string, verbose?: boolean, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionsTokenRelated(token, count, startIndex, fields, sortBy, startDate, endDate, type, state, version, verbose, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetTransactionsSortByEnum = {
    CreatedTime: '-created_time',
    CreatedTime2: 'created_time',
    UserTransactionTime: '-user_transaction_time',
    UserTransactionTime2: 'user_transaction_time'
} as const;
export type GetTransactionsSortByEnum = typeof GetTransactionsSortByEnum[keyof typeof GetTransactionsSortByEnum];
export const GetTransactionsFundingsourceFundingsourcetokenSortByEnum = {
    CreatedTime: '-created_time',
    CreatedTime2: 'created_time',
    UserTransactionTime: '-user_transaction_time',
    UserTransactionTime2: 'user_transaction_time'
} as const;
export type GetTransactionsFundingsourceFundingsourcetokenSortByEnum = typeof GetTransactionsFundingsourceFundingsourcetokenSortByEnum[keyof typeof GetTransactionsFundingsourceFundingsourcetokenSortByEnum];
export const GetTransactionsFundingsourceFundingsourcetokenPolarityEnum = {
    Credit: 'CREDIT',
    Debit: 'DEBIT',
    PendingCredit: 'PENDING_CREDIT',
    PendingDebit: 'PENDING_DEBIT'
} as const;
export type GetTransactionsFundingsourceFundingsourcetokenPolarityEnum = typeof GetTransactionsFundingsourceFundingsourcetokenPolarityEnum[keyof typeof GetTransactionsFundingsourceFundingsourcetokenPolarityEnum];
export const GetTransactionsTokenRelatedSortByEnum = {
    CreatedTime: '-created_time',
    CreatedTime2: 'created_time',
    UserTransactionTime: '-user_transaction_time',
    UserTransactionTime2: 'user_transaction_time'
} as const;
export type GetTransactionsTokenRelatedSortByEnum = typeof GetTransactionsTokenRelatedSortByEnum[keyof typeof GetTransactionsTokenRelatedSortByEnum];


/**
 * UserTransitionsApi - axios parameter creator
 */
export const UserTransitionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a user transition.
         * @summary Retrieve user transition
         * @param {string} token Unique identifier of the user transition you want to retrieve.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getUsertransitionsToken', 'token', token)
            const localVarPath = `/usertransitions/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all transitions for a given user.
         * @summary List transitions for user
         * @param {string} userToken Unique identifier of the user resource.
         * @param {number} [count] Number of user transitions to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsUserUsertoken: async (userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('getUsertransitionsUserUsertoken', 'userToken', userToken)
            const localVarPath = `/usertransitions/user/{user_token}`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables you to change a user\'s status, depending on your role and the previous status change. By changing a user\'s status, you can control the user\'s capabilities and the setting of the `user.active` field. Do not set the value of the `user.active` field directly.  [cols=\"2a,4a,3a\"] |=== | The user.status Field | Description | User Limitations  | `UNVERIFIED` | Initial status of a new user belonging to an account holder group where KYC is always required.  *Allowable Transitions:*  + `ACTIVE`, `CLOSED`, `TERMINATED` | Cannot activate cards or load funds.  *user.active Field:*  + `false`  | `LIMITED` | Initial status of a new user belonging to an account holder group where KYC is conditionally required.  *Allowable Transitions:*  + `ACTIVE`, `SUSPENDED`, `CLOSED` | Restricted by rules in `accountholdergroups.pre_kyc_controls`.  *user.active Field:*  + `true`  | `ACTIVE` | Status of a user who has passed KYC, or initial status of a new user belonging to an account holder group where KYC is never required.  *Allowable Transitions:*  + `SUSPENDED`, `CLOSED`, `UNVERIFIED` | None.  *user.active Field:*  + `true`  | `SUSPENDED` | The user is temporarily inactive.  Transitioning a suspended user to the `ACTIVE` status is restricted, based on your role and the details of the previous status change.  *Allowable Transitions:*  + `ACTIVE`, `LIMITED`, `UNVERIFIED`, `CLOSED`, `TERMINATED` | Cannot activate cards, load funds, or transact.  *user.active Field:*  + `false`  | `CLOSED` | The user is permanently inactive.  In general, the `CLOSED` status should be terminal. For exceptional cases, you can transition a user to other statuses, depending on your role and the details of the previous status change. Contact your Marqeta representative for more information.  *Allowable Transitions:*  + `ACTIVE`, `LIMITED`, `UNVERIFIED`, `SUSPENDED`, `TERMINATED` | Cannot activate cards, load funds, or transact.  *user.active Field:*  + `false`  | `TERMINATED` | The user account is permanently closed. Use the `TERMINATED` state to comply with regulatory requirements, such as the requirement that a user account be irreversibly closed when it does not pass Know Your Customer (KYC) verification.  *NOTE:* `TERMINATED` is a terminal status. You must have the Admin or Program Manager role to transition a user to the `TERMINATED` state. You cannot transition a user from `TERMINATED` to any other state. Contact your Marqeta representative for more information.  *Allowable Transitions:*   + None | Cannot load funds, activate cards, or transact.  *The user.active field:*   + `false`  |===  [NOTE] The Marqeta platform transitions a user\'s status in response to certain events. For example, a user in the `UNVERIFIED` status is transitioned to `ACTIVE` when the user passes KYC verification.
         * @summary Create user transition
         * @param {UserTransitionRequest} [userTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsertransitions: async (userTransitionRequest?: UserTransitionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usertransitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(userTransitionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTransitionsApi - functional programming interface
 */
export const UserTransitionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UserTransitionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a user transition.
         * @summary Retrieve user transition
         * @param {string} token Unique identifier of the user transition you want to retrieve.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsertransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsertransitionsToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTransitionsApi.getUsertransitionsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all transitions for a given user.
         * @summary List transitions for user
         * @param {string} userToken Unique identifier of the user resource.
         * @param {number} [count] Number of user transitions to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsertransitionsUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTransitionListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsertransitionsUserUsertoken(userToken, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTransitionsApi.getUsertransitionsUserUsertoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint enables you to change a user\'s status, depending on your role and the previous status change. By changing a user\'s status, you can control the user\'s capabilities and the setting of the `user.active` field. Do not set the value of the `user.active` field directly.  [cols=\"2a,4a,3a\"] |=== | The user.status Field | Description | User Limitations  | `UNVERIFIED` | Initial status of a new user belonging to an account holder group where KYC is always required.  *Allowable Transitions:*  + `ACTIVE`, `CLOSED`, `TERMINATED` | Cannot activate cards or load funds.  *user.active Field:*  + `false`  | `LIMITED` | Initial status of a new user belonging to an account holder group where KYC is conditionally required.  *Allowable Transitions:*  + `ACTIVE`, `SUSPENDED`, `CLOSED` | Restricted by rules in `accountholdergroups.pre_kyc_controls`.  *user.active Field:*  + `true`  | `ACTIVE` | Status of a user who has passed KYC, or initial status of a new user belonging to an account holder group where KYC is never required.  *Allowable Transitions:*  + `SUSPENDED`, `CLOSED`, `UNVERIFIED` | None.  *user.active Field:*  + `true`  | `SUSPENDED` | The user is temporarily inactive.  Transitioning a suspended user to the `ACTIVE` status is restricted, based on your role and the details of the previous status change.  *Allowable Transitions:*  + `ACTIVE`, `LIMITED`, `UNVERIFIED`, `CLOSED`, `TERMINATED` | Cannot activate cards, load funds, or transact.  *user.active Field:*  + `false`  | `CLOSED` | The user is permanently inactive.  In general, the `CLOSED` status should be terminal. For exceptional cases, you can transition a user to other statuses, depending on your role and the details of the previous status change. Contact your Marqeta representative for more information.  *Allowable Transitions:*  + `ACTIVE`, `LIMITED`, `UNVERIFIED`, `SUSPENDED`, `TERMINATED` | Cannot activate cards, load funds, or transact.  *user.active Field:*  + `false`  | `TERMINATED` | The user account is permanently closed. Use the `TERMINATED` state to comply with regulatory requirements, such as the requirement that a user account be irreversibly closed when it does not pass Know Your Customer (KYC) verification.  *NOTE:* `TERMINATED` is a terminal status. You must have the Admin or Program Manager role to transition a user to the `TERMINATED` state. You cannot transition a user from `TERMINATED` to any other state. Contact your Marqeta representative for more information.  *Allowable Transitions:*   + None | Cannot load funds, activate cards, or transact.  *The user.active field:*   + `false`  |===  [NOTE] The Marqeta platform transitions a user\'s status in response to certain events. For example, a user in the `UNVERIFIED` status is transitioned to `ACTIVE` when the user passes KYC verification.
         * @summary Create user transition
         * @param {UserTransitionRequest} [userTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsertransitions(userTransitionRequest?: UserTransitionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTransitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsertransitions(userTransitionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTransitionsApi.postUsertransitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserTransitionsApi - factory interface
 */
export const UserTransitionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserTransitionsApiFp(configuration)
    return {
        /**
         * Retrieve a user transition.
         * @summary Retrieve user transition
         * @param {string} token Unique identifier of the user transition you want to retrieve.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserTransitionResponse> {
            return localVarFp.getUsertransitionsToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * List all transitions for a given user.
         * @summary List transitions for user
         * @param {string} userToken Unique identifier of the user resource.
         * @param {number} [count] Number of user transitions to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsertransitionsUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserTransitionListResponse> {
            return localVarFp.getUsertransitionsUserUsertoken(userToken, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables you to change a user\'s status, depending on your role and the previous status change. By changing a user\'s status, you can control the user\'s capabilities and the setting of the `user.active` field. Do not set the value of the `user.active` field directly.  [cols=\"2a,4a,3a\"] |=== | The user.status Field | Description | User Limitations  | `UNVERIFIED` | Initial status of a new user belonging to an account holder group where KYC is always required.  *Allowable Transitions:*  + `ACTIVE`, `CLOSED`, `TERMINATED` | Cannot activate cards or load funds.  *user.active Field:*  + `false`  | `LIMITED` | Initial status of a new user belonging to an account holder group where KYC is conditionally required.  *Allowable Transitions:*  + `ACTIVE`, `SUSPENDED`, `CLOSED` | Restricted by rules in `accountholdergroups.pre_kyc_controls`.  *user.active Field:*  + `true`  | `ACTIVE` | Status of a user who has passed KYC, or initial status of a new user belonging to an account holder group where KYC is never required.  *Allowable Transitions:*  + `SUSPENDED`, `CLOSED`, `UNVERIFIED` | None.  *user.active Field:*  + `true`  | `SUSPENDED` | The user is temporarily inactive.  Transitioning a suspended user to the `ACTIVE` status is restricted, based on your role and the details of the previous status change.  *Allowable Transitions:*  + `ACTIVE`, `LIMITED`, `UNVERIFIED`, `CLOSED`, `TERMINATED` | Cannot activate cards, load funds, or transact.  *user.active Field:*  + `false`  | `CLOSED` | The user is permanently inactive.  In general, the `CLOSED` status should be terminal. For exceptional cases, you can transition a user to other statuses, depending on your role and the details of the previous status change. Contact your Marqeta representative for more information.  *Allowable Transitions:*  + `ACTIVE`, `LIMITED`, `UNVERIFIED`, `SUSPENDED`, `TERMINATED` | Cannot activate cards, load funds, or transact.  *user.active Field:*  + `false`  | `TERMINATED` | The user account is permanently closed. Use the `TERMINATED` state to comply with regulatory requirements, such as the requirement that a user account be irreversibly closed when it does not pass Know Your Customer (KYC) verification.  *NOTE:* `TERMINATED` is a terminal status. You must have the Admin or Program Manager role to transition a user to the `TERMINATED` state. You cannot transition a user from `TERMINATED` to any other state. Contact your Marqeta representative for more information.  *Allowable Transitions:*   + None | Cannot load funds, activate cards, or transact.  *The user.active field:*   + `false`  |===  [NOTE] The Marqeta platform transitions a user\'s status in response to certain events. For example, a user in the `UNVERIFIED` status is transitioned to `ACTIVE` when the user passes KYC verification.
         * @summary Create user transition
         * @param {UserTransitionRequest} [userTransitionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsertransitions(userTransitionRequest?: UserTransitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserTransitionResponse> {
            return localVarFp.postUsertransitions(userTransitionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserTransitionsApi - object-oriented interface
 */
export class UserTransitionsApi extends BaseAPI {
    /**
     * Retrieve a user transition.
     * @summary Retrieve user transition
     * @param {string} token Unique identifier of the user transition you want to retrieve.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsertransitionsToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return UserTransitionsApiFp(this.configuration).getUsertransitionsToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all transitions for a given user.
     * @summary List transitions for user
     * @param {string} userToken Unique identifier of the user resource.
     * @param {number} [count] Number of user transitions to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsertransitionsUserUsertoken(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return UserTransitionsApiFp(this.configuration).getUsertransitionsUserUsertoken(userToken, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables you to change a user\'s status, depending on your role and the previous status change. By changing a user\'s status, you can control the user\'s capabilities and the setting of the `user.active` field. Do not set the value of the `user.active` field directly.  [cols=\"2a,4a,3a\"] |=== | The user.status Field | Description | User Limitations  | `UNVERIFIED` | Initial status of a new user belonging to an account holder group where KYC is always required.  *Allowable Transitions:*  + `ACTIVE`, `CLOSED`, `TERMINATED` | Cannot activate cards or load funds.  *user.active Field:*  + `false`  | `LIMITED` | Initial status of a new user belonging to an account holder group where KYC is conditionally required.  *Allowable Transitions:*  + `ACTIVE`, `SUSPENDED`, `CLOSED` | Restricted by rules in `accountholdergroups.pre_kyc_controls`.  *user.active Field:*  + `true`  | `ACTIVE` | Status of a user who has passed KYC, or initial status of a new user belonging to an account holder group where KYC is never required.  *Allowable Transitions:*  + `SUSPENDED`, `CLOSED`, `UNVERIFIED` | None.  *user.active Field:*  + `true`  | `SUSPENDED` | The user is temporarily inactive.  Transitioning a suspended user to the `ACTIVE` status is restricted, based on your role and the details of the previous status change.  *Allowable Transitions:*  + `ACTIVE`, `LIMITED`, `UNVERIFIED`, `CLOSED`, `TERMINATED` | Cannot activate cards, load funds, or transact.  *user.active Field:*  + `false`  | `CLOSED` | The user is permanently inactive.  In general, the `CLOSED` status should be terminal. For exceptional cases, you can transition a user to other statuses, depending on your role and the details of the previous status change. Contact your Marqeta representative for more information.  *Allowable Transitions:*  + `ACTIVE`, `LIMITED`, `UNVERIFIED`, `SUSPENDED`, `TERMINATED` | Cannot activate cards, load funds, or transact.  *user.active Field:*  + `false`  | `TERMINATED` | The user account is permanently closed. Use the `TERMINATED` state to comply with regulatory requirements, such as the requirement that a user account be irreversibly closed when it does not pass Know Your Customer (KYC) verification.  *NOTE:* `TERMINATED` is a terminal status. You must have the Admin or Program Manager role to transition a user to the `TERMINATED` state. You cannot transition a user from `TERMINATED` to any other state. Contact your Marqeta representative for more information.  *Allowable Transitions:*   + None | Cannot load funds, activate cards, or transact.  *The user.active field:*   + `false`  |===  [NOTE] The Marqeta platform transitions a user\'s status in response to certain events. For example, a user in the `UNVERIFIED` status is transitioned to `ACTIVE` when the user passes KYC verification.
     * @summary Create user transition
     * @param {UserTransitionRequest} [userTransitionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsertransitions(userTransitionRequest?: UserTransitionRequest, options?: RawAxiosRequestConfig) {
        return UserTransitionsApiFp(this.configuration).postUsertransitions(userTransitionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To return an array of all of a program\'s users, send a `GET` request to the `/users` endpoint. This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>. To narrow your result set to users that match certain criteria, see the <<search_users,Search users>> endpoint.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===
         * @summary List users
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [searchType] Search type.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To retrieve application and card information using a client access token, send a `GET` request to the `/users/auth/clientaccesstoken/{token}` endpoint.
         * @summary Retrieve client access token
         * @param {string} token Client access token.
         * @param {string} [applicationToken] Unique identifier of the &#x60;application&#x60; object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAuthClientaccesstokenToken: async (token: string, applicationToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getUsersAuthClientaccesstokenToken', 'token', token)
            const localVarPath = `/users/auth/clientaccesstoken/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (applicationToken !== undefined) {
                localVarQueryParameter['application_token'] = applicationToken;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To retrieve users who are children of a parent user or business, send a `GET` request to the `/users/{parent_token}/children` endpoint. Include the parent\'s user or business token as a URL path parameter.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary List user child accounts
         * @param {string} parentToken Unique identifier of the parent account holder.
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParenttokenChildren: async (parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentToken' is not null or undefined
            assertParamExists('getUsersParenttokenChildren', 'parentToken', parentToken)
            const localVarPath = `/users/{parent_token}/children`
                .replace(`{${"parent_token"}}`, encodeURIComponent(String(parentToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists all users who match a phone number
         * @param {string} phoneNumber Phone number
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPhonenumberPhonenumber: async (phoneNumber: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'phoneNumber' is not null or undefined
            assertParamExists('getUsersPhonenumberPhonenumber', 'phoneNumber', phoneNumber)
            const localVarPath = `/users/phonenumber/{phone_number}`
                .replace(`{${"phone_number"}}`, encodeURIComponent(String(phoneNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To retrieve a specific user, send a `GET` request to the `/users/{token}` endpoint. Include the user `token` path parameter to specify the user to return.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary Retrieve user
         * @param {string} token Unique identifier of the user resource.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getUsersToken', 'token', token)
            const localVarPath = `/users/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists cardholder notes
         * @param {string} token User token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenNotes: async (token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getUsersTokenNotes', 'token', token)
            const localVarPath = `/users/{token}/notes`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (createdByUserRole !== undefined) {
                localVarQueryParameter['created_by_user_role'] = createdByUserRole;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['include_private'] = includePrivate;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To retrieve the government-issued identification number for a user, send a `GET` request to the `/users/{token}/ssn` endpoint. Include the `token` path parameter to specify the user whose identification number (SSN, ITIN, TIN, NIN, SIN) you wish to return. You can indicate whether to return the full number or the last four digits only.
         * @summary Retrieve user identification number
         * @param {string} token Unique identifier of the user resource.
         * @param {boolean} [fullSsn] To return the full identification number, set to &#x60;true&#x60;. To return only the last four digits, set to &#x60;false&#x60;.  If the identifications array contains only the last four digits of the identification number, the &#x60;/users/{token}/ssn&#x60; endpoint will return only the last four digits, regardless of the &#x60;full_ssn&#x60; parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenSsn: async (token: string, fullSsn?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getUsersTokenSsn', 'token', token)
            const localVarPath = `/users/{token}/ssn`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fullSsn !== undefined) {
                localVarQueryParameter['full_ssn'] = fullSsn;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint enables you to create a user. A new user\'s initial status depends on the <</core-api/kyc-verification, Know Your Customer (KYC) requirements>> of the program or associated <</core-api/account-holder-groups, account holder group>>.  [cols=\"1,1,1,1\"] |=== | KYC Required | Initial User Status | User Active on Creation | User Limitations  | Always | `UNVERIFIED` | Optional | Cannot load funds; cannot activate cards.  | Conditionally | `LIMITED` | Optional | Restricted by rules in `accountholdergroups.pre_kyc_controls`.  | Never | `ACTIVE` | Required | None. |===  [NOTE] Use the `/usertransitions` endpoints to transition user resources between statuses and to view the history of a user\'s status. Do not set the value of the `user.active` field directly. For more information on status changes, see <</core-api/user-transitions#postUsertransitions, Create User Transition>>.  To perform KYC verification on users, the user object must have the following fields configured:  * `first_name` (legal first name only, no prefixes) * `last_name` (legal last name only, no suffixes) * `address1` (cannot be a PO Box) * `city` * `state` * `postal_code` * `country` * `birth_date` * `identifications` * `phone` (required in some cases) * `email` (required in some cases)  [NOTE] The `identifications` requirement depends on your program\'s configuration. To determine if you should provide a full or abbreviated identification number, contact your Marqeta representative. KYC verification requires the full Social Security Number (SSN) or Individual Taxpayer Identification Number (ITIN) of the user.  To create a child user, you must identify the parent user or business and determine whether the child user shares an account with the parent.  The parent must be an existing user or business. On the child user, set the `parent_token` field to the value of the parent\'s `token` field. If either the parent or the grandparent is a business, a `business_token` field is added to the user. This field\'s value is set to the token of either the parent or grandparent (whichever is the business).  The `uses_parent_account` field determines whether the child shares balances with the parent (`true`) or whether the child balances are independent of the parent (`false`). If you do not specify a value for `uses_parent_account`, it is set to `false` by default (the user does not share the parent\'s balance) and returned in the response body. This field cannot be updated, so you must decide upon creation whether the child user shares the parent balance.  Sharing an account with a parent user affects how the child user interacts with cards as follows:  * A child user cannot spend funds if its parent is not active. * An active child user can activate cards, whether the parent is active or not.
         * @summary Create user
         * @param {CardHolderModel} [cardHolderModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers: async (cardHolderModel?: CardHolderModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardHolderModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To change a user password, send a `POST` request to the `/users/auth/changepassword` endpoint and include the `current_password` and `new_password` in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. This endpoint operates in the context of a currently logged-in user.  A successful password change returns an empty response body with a response code of `204 No Content`.
         * @summary Update user password
         * @param {PasswordUpdateModel} passwordUpdateModel Password update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthChangepassword: async (passwordUpdateModel: PasswordUpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordUpdateModel' is not null or undefined
            assertParamExists('postUsersAuthChangepassword', 'passwordUpdateModel', passwordUpdateModel)
            const localVarPath = `/users/auth/changepassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(passwordUpdateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Each time you want to display a virtual card\'s sensitive data (for example, when using `marqeta.js`), you must first request a new, single-use client access token from the Marqeta platform by sending a `POST` request to the `/users/auth/clientaccesstoken` endpoint. Unredeemed client access tokens expire after five minutes.
         * @summary Create client access token
         * @param {ClientAccessTokenRequest} [clientAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthClientaccesstoken: async (clientAccessTokenRequest?: ClientAccessTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/auth/clientaccesstoken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(clientAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To log in a user and return a user access token, send a `POST` request to the `/users/auth/login` endpoint and include the user details in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request.  [TIP] To check a user\'s credentials without logging out the user, call the `/users/auth/onetime` endpoint.
         * @summary Log in user
         * @param {LoginRequestModel} [loginRequestModel] User login object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogin: async (loginRequestModel?: LoginRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To log out a user, send a `POST` request to the `/users/auth/logout` endpoint.  A successful logout returns an empty response body with a response code of `204 No Content`.
         * @summary Log out user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a single-use access token. This type of token authorizes a single request to access API endpoints and data associated with a particular user. A single-use access token differs from a user access token (as returned by `POST` `/users/auth/login`) only in the number of times it can be used.  To return a single-use access token, send a `POST` request to the `/users/auth/onetime` endpoint. Provide one of these sets of input data:  * *Case #1*  Application token and user access token * *Case #2*  Application token, admin access token, and user token * *Case #3*  Application token, user\'s Marqeta password, and user\'s email address  In each case, provide the application token as the HTTP Basic Authentication username in the request header\'s Authorization field. When applicable, provide the user access token or admin access token as the HTTP Basic Authentication password. When applicable, provide the user token or user\'s Marqeta password and email address in link:http://www.json.org/[JSON, window=\"_blank\"] format in the request body.  Before instantiating an embedded Marqeta widget, call this endpoint to obtain the single-use access token required as input (cases #1 and #2).  This endpoint is also useful when you want to check a user\'s credentials before performing a sensitive operation without having to log out the user (case #3).  [NOTE] Calling this endpoint and returning a single-use access token does not invalidate the user\'s current user access token.
         * @summary Create single-use token
         * @param {OneTimeRequestModel} [oneTimeRequestModel] One-time object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthOnetime: async (oneTimeRequestModel?: OneTimeRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/auth/onetime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(oneTimeRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to generate a password reset token for a user. Send a `POST` request to the `/users/auth/resetpassword` endpoint and include the user\'s email address in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. This request generates and sends an email message containing the `user_token` and `password_reset_token` to the user\'s email address. You must customize the email message with a link that passes the `user_token` and `password_reset_token` to a web page where a subsequent request updates the password.  A successful request returns an empty response body with a response code of `204 No Content`.
         * @summary Request user password reset token
         * @param {ResetUserPasswordEmailModel} [resetUserPasswordEmailModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpassword: async (resetUserPasswordEmailModel?: ResetUserPasswordEmailModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/auth/resetpassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(resetUserPasswordEmailModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To reset the user\'s password, send a `POST` request to the `/users/auth/resetpassword/{token}` endpoint that includes a password reset token generated using the `POST /users/auth/resetpassword` operation. Include the `user_token` and `new_password` in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. Include the `password_reset_token` as a path parameter.  A successful password reset returns an empty response body with a response code of `204 No Content`.
         * @summary Reset user password
         * @param {string} token Password reset token generated using the &#x60;POST /users/auth/resetpassword&#x60; operation.
         * @param {ResetUserPasswordModel} [resetUserPasswordModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpasswordToken: async (token: string, resetUserPasswordModel?: ResetUserPasswordModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postUsersAuthResetpasswordToken', 'token', token)
            const localVarPath = `/users/auth/resetpassword/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(resetUserPasswordModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a `POST` request to the `/users/auth/verifyemail` endpoint to request an email verification token. No input parameters are required because this operation is performed in the context of an authenticated user.  This initial request generates and sends an email message containing the email verification token to the cardholder\'s email address. This email message must include a link that passes the email verification token to a web page where a subsequent request verifies the email address.  A successful request returns an empty response body with a response code of `204 No Content`.
         * @summary Request email verification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemail: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/auth/verifyemail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To verify a user\'s email address, send a `POST` request to the `/users/auth/verifyemail/{email_verification_token}` endpoint that includes an `email_verification_token` generated using the `POST /users/auth/verifyemail` operation. Include the `email_verification_token` as a path parameter.  A successful email verification returns an empty response body with a response code of `204 No Content`.
         * @summary Verify email address
         * @param {string} token Email verification token generated using the &#x60;POST /users/auth/verifyemail&#x60; operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemailToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postUsersAuthVerifyemailToken', 'token', token)
            const localVarPath = `/users/auth/verifyemail/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To search for one or more users, send a `POST` request to the `/users/lookup` endpoint. Include in the message body any parameters by which you want to query. This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary Search users
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [searchType] Search type.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {UserCardHolderSearchModel} [userCardHolderSearchModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersLookup: async (count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, userCardHolderSearchModel?: UserCardHolderSearchModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(userCardHolderSearchModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a note for the cardholder
         * @param {string} token User token
         * @param {CardholderNoteRequestModel} [cardholderNoteRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersTokenNotes: async (token: string, cardholderNoteRequestModel?: CardholderNoteRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postUsersTokenNotes', 'token', token)
            const localVarPath = `/users/{token}/notes`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardholderNoteRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To update a specific user resource, send a `PUT` request to the `/users/{token}` endpoint. Include the user `token` path parameter to specify the user to update.  To unlink a child user account from a parent account, pass a null value to the `parent_token` field of the child user resource.
         * @summary Update user
         * @param {string} token Unique identifier of the user resource you want to update.
         * @param {UserCardHolderUpdateModel} userCardHolderUpdateModel User object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersToken: async (token: string, userCardHolderUpdateModel: UserCardHolderUpdateModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putUsersToken', 'token', token)
            // verify required parameter 'userCardHolderUpdateModel' is not null or undefined
            assertParamExists('putUsersToken', 'userCardHolderUpdateModel', userCardHolderUpdateModel)
            const localVarPath = `/users/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(userCardHolderUpdateModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a specific note for a cardholder
         * @param {string} token User token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [cardholderNoteUpdateRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersTokenNotesNotestoken: async (token: string, notesToken: string, cardholderNoteUpdateRequestModel?: CardholderNoteUpdateRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putUsersTokenNotesNotestoken', 'token', token)
            // verify required parameter 'notesToken' is not null or undefined
            assertParamExists('putUsersTokenNotesNotestoken', 'notesToken', notesToken)
            const localVarPath = `/users/{token}/notes/{notes_token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"notes_token"}}`, encodeURIComponent(String(notesToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cardholderNoteUpdateRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * To return an array of all of a program\'s users, send a `GET` request to the `/users` endpoint. This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>. To narrow your result set to users that match certain criteria, see the <<search_users,Search users>> endpoint.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===
         * @summary List users
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [searchType] Search type.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCardHolderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(count, startIndex, searchType, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To retrieve application and card information using a client access token, send a `GET` request to the `/users/auth/clientaccesstoken/{token}` endpoint.
         * @summary Retrieve client access token
         * @param {string} token Client access token.
         * @param {string} [applicationToken] Unique identifier of the &#x60;application&#x60; object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersAuthClientaccesstokenToken(token: string, applicationToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersAuthClientaccesstokenToken(token, applicationToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersAuthClientaccesstokenToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To retrieve users who are children of a parent user or business, send a `GET` request to the `/users/{parent_token}/children` endpoint. Include the parent\'s user or business token as a URL path parameter.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary List user child accounts
         * @param {string} parentToken Unique identifier of the parent account holder.
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCardHolderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersParenttokenChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists all users who match a phone number
         * @param {string} phoneNumber Phone number
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersPhonenumberPhonenumber(phoneNumber: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCardHolderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersPhonenumberPhonenumber(phoneNumber, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersPhonenumberPhonenumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To retrieve a specific user, send a `GET` request to the `/users/{token}` endpoint. Include the user `token` path parameter to specify the user to return.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary Retrieve user
         * @param {string} token Unique identifier of the user resource.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCardHolderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists cardholder notes
         * @param {string} token User token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardHolderNoteListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersTokenNotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To retrieve the government-issued identification number for a user, send a `GET` request to the `/users/{token}/ssn` endpoint. Include the `token` path parameter to specify the user whose identification number (SSN, ITIN, TIN, NIN, SIN) you wish to return. You can indicate whether to return the full number or the last four digits only.
         * @summary Retrieve user identification number
         * @param {string} token Unique identifier of the user resource.
         * @param {boolean} [fullSsn] To return the full identification number, set to &#x60;true&#x60;. To return only the last four digits, set to &#x60;false&#x60;.  If the identifications array contains only the last four digits of the identification number, the &#x60;/users/{token}/ssn&#x60; endpoint will return only the last four digits, regardless of the &#x60;full_ssn&#x60; parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersTokenSsn(token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsnResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersTokenSsn(token, fullSsn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getUsersTokenSsn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint enables you to create a user. A new user\'s initial status depends on the <</core-api/kyc-verification, Know Your Customer (KYC) requirements>> of the program or associated <</core-api/account-holder-groups, account holder group>>.  [cols=\"1,1,1,1\"] |=== | KYC Required | Initial User Status | User Active on Creation | User Limitations  | Always | `UNVERIFIED` | Optional | Cannot load funds; cannot activate cards.  | Conditionally | `LIMITED` | Optional | Restricted by rules in `accountholdergroups.pre_kyc_controls`.  | Never | `ACTIVE` | Required | None. |===  [NOTE] Use the `/usertransitions` endpoints to transition user resources between statuses and to view the history of a user\'s status. Do not set the value of the `user.active` field directly. For more information on status changes, see <</core-api/user-transitions#postUsertransitions, Create User Transition>>.  To perform KYC verification on users, the user object must have the following fields configured:  * `first_name` (legal first name only, no prefixes) * `last_name` (legal last name only, no suffixes) * `address1` (cannot be a PO Box) * `city` * `state` * `postal_code` * `country` * `birth_date` * `identifications` * `phone` (required in some cases) * `email` (required in some cases)  [NOTE] The `identifications` requirement depends on your program\'s configuration. To determine if you should provide a full or abbreviated identification number, contact your Marqeta representative. KYC verification requires the full Social Security Number (SSN) or Individual Taxpayer Identification Number (ITIN) of the user.  To create a child user, you must identify the parent user or business and determine whether the child user shares an account with the parent.  The parent must be an existing user or business. On the child user, set the `parent_token` field to the value of the parent\'s `token` field. If either the parent or the grandparent is a business, a `business_token` field is added to the user. This field\'s value is set to the token of either the parent or grandparent (whichever is the business).  The `uses_parent_account` field determines whether the child shares balances with the parent (`true`) or whether the child balances are independent of the parent (`false`). If you do not specify a value for `uses_parent_account`, it is set to `false` by default (the user does not share the parent\'s balance) and returned in the response body. This field cannot be updated, so you must decide upon creation whether the child user shares the parent balance.  Sharing an account with a parent user affects how the child user interacts with cards as follows:  * A child user cannot spend funds if its parent is not active. * An active child user can activate cards, whether the parent is active or not.
         * @summary Create user
         * @param {CardHolderModel} [cardHolderModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsers(cardHolderModel?: CardHolderModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCardHolderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsers(cardHolderModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To change a user password, send a `POST` request to the `/users/auth/changepassword` endpoint and include the `current_password` and `new_password` in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. This endpoint operates in the context of a currently logged-in user.  A successful password change returns an empty response body with a response code of `204 No Content`.
         * @summary Update user password
         * @param {PasswordUpdateModel} passwordUpdateModel Password update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthChangepassword(passwordUpdateModel: PasswordUpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthChangepassword(passwordUpdateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthChangepassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Each time you want to display a virtual card\'s sensitive data (for example, when using `marqeta.js`), you must first request a new, single-use client access token from the Marqeta platform by sending a `POST` request to the `/users/auth/clientaccesstoken` endpoint. Unredeemed client access tokens expire after five minutes.
         * @summary Create client access token
         * @param {ClientAccessTokenRequest} [clientAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthClientaccesstoken(clientAccessTokenRequest?: ClientAccessTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthClientaccesstoken(clientAccessTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthClientaccesstoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To log in a user and return a user access token, send a `POST` request to the `/users/auth/login` endpoint and include the user details in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request.  [TIP] To check a user\'s credentials without logging out the user, call the `/users/auth/onetime` endpoint.
         * @summary Log in user
         * @param {LoginRequestModel} [loginRequestModel] User login object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthLogin(loginRequestModel?: LoginRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthLogin(loginRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To log out a user, send a `POST` request to the `/users/auth/logout` endpoint.  A successful logout returns an empty response body with a response code of `204 No Content`.
         * @summary Log out user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns a single-use access token. This type of token authorizes a single request to access API endpoints and data associated with a particular user. A single-use access token differs from a user access token (as returned by `POST` `/users/auth/login`) only in the number of times it can be used.  To return a single-use access token, send a `POST` request to the `/users/auth/onetime` endpoint. Provide one of these sets of input data:  * *Case #1*  Application token and user access token * *Case #2*  Application token, admin access token, and user token * *Case #3*  Application token, user\'s Marqeta password, and user\'s email address  In each case, provide the application token as the HTTP Basic Authentication username in the request header\'s Authorization field. When applicable, provide the user access token or admin access token as the HTTP Basic Authentication password. When applicable, provide the user token or user\'s Marqeta password and email address in link:http://www.json.org/[JSON, window=\"_blank\"] format in the request body.  Before instantiating an embedded Marqeta widget, call this endpoint to obtain the single-use access token required as input (cases #1 and #2).  This endpoint is also useful when you want to check a user\'s credentials before performing a sensitive operation without having to log out the user (case #3).  [NOTE] Calling this endpoint and returning a single-use access token does not invalidate the user\'s current user access token.
         * @summary Create single-use token
         * @param {OneTimeRequestModel} [oneTimeRequestModel] One-time object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthOnetime(oneTimeRequestModel?: OneTimeRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthOnetime(oneTimeRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthOnetime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to generate a password reset token for a user. Send a `POST` request to the `/users/auth/resetpassword` endpoint and include the user\'s email address in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. This request generates and sends an email message containing the `user_token` and `password_reset_token` to the user\'s email address. You must customize the email message with a link that passes the `user_token` and `password_reset_token` to a web page where a subsequent request updates the password.  A successful request returns an empty response body with a response code of `204 No Content`.
         * @summary Request user password reset token
         * @param {ResetUserPasswordEmailModel} [resetUserPasswordEmailModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthResetpassword(resetUserPasswordEmailModel?: ResetUserPasswordEmailModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthResetpassword(resetUserPasswordEmailModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthResetpassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To reset the user\'s password, send a `POST` request to the `/users/auth/resetpassword/{token}` endpoint that includes a password reset token generated using the `POST /users/auth/resetpassword` operation. Include the `user_token` and `new_password` in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. Include the `password_reset_token` as a path parameter.  A successful password reset returns an empty response body with a response code of `204 No Content`.
         * @summary Reset user password
         * @param {string} token Password reset token generated using the &#x60;POST /users/auth/resetpassword&#x60; operation.
         * @param {ResetUserPasswordModel} [resetUserPasswordModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthResetpasswordToken(token: string, resetUserPasswordModel?: ResetUserPasswordModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthResetpasswordToken(token, resetUserPasswordModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthResetpasswordToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a `POST` request to the `/users/auth/verifyemail` endpoint to request an email verification token. No input parameters are required because this operation is performed in the context of an authenticated user.  This initial request generates and sends an email message containing the email verification token to the cardholder\'s email address. This email message must include a link that passes the email verification token to a web page where a subsequent request verifies the email address.  A successful request returns an empty response body with a response code of `204 No Content`.
         * @summary Request email verification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthVerifyemail(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthVerifyemail(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthVerifyemail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To verify a user\'s email address, send a `POST` request to the `/users/auth/verifyemail/{email_verification_token}` endpoint that includes an `email_verification_token` generated using the `POST /users/auth/verifyemail` operation. Include the `email_verification_token` as a path parameter.  A successful email verification returns an empty response body with a response code of `204 No Content`.
         * @summary Verify email address
         * @param {string} token Email verification token generated using the &#x60;POST /users/auth/verifyemail&#x60; operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersAuthVerifyemailToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersAuthVerifyemailToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersAuthVerifyemailToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To search for one or more users, send a `POST` request to the `/users/lookup` endpoint. Include in the message body any parameters by which you want to query. This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary Search users
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [searchType] Search type.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {UserCardHolderSearchModel} [userCardHolderSearchModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersLookup(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, userCardHolderSearchModel?: UserCardHolderSearchModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCardHolderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersLookup(count, startIndex, searchType, fields, sortBy, userCardHolderSearchModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersLookup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a note for the cardholder
         * @param {string} token User token
         * @param {CardholderNoteRequestModel} [cardholderNoteRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersTokenNotes(token: string, cardholderNoteRequestModel?: CardholderNoteRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderNoteResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersTokenNotes(token, cardholderNoteRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.postUsersTokenNotes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To update a specific user resource, send a `PUT` request to the `/users/{token}` endpoint. Include the user `token` path parameter to specify the user to update.  To unlink a child user account from a parent account, pass a null value to the `parent_token` field of the child user resource.
         * @summary Update user
         * @param {string} token Unique identifier of the user resource you want to update.
         * @param {UserCardHolderUpdateModel} userCardHolderUpdateModel User object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersToken(token: string, userCardHolderUpdateModel: UserCardHolderUpdateModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardHolderModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersToken(token, userCardHolderUpdateModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.putUsersToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a specific note for a cardholder
         * @param {string} token User token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [cardholderNoteUpdateRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersTokenNotesNotestoken(token: string, notesToken: string, cardholderNoteUpdateRequestModel?: CardholderNoteUpdateRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CardholderNoteResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersTokenNotesNotestoken(token, notesToken, cardholderNoteUpdateRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.putUsersTokenNotesNotestoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * To return an array of all of a program\'s users, send a `GET` request to the `/users` endpoint. This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>. To narrow your result set to users that match certain criteria, see the <<search_users,Search users>> endpoint.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===
         * @summary List users
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [searchType] Search type.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserCardHolderListResponse> {
            return localVarFp.getUsers(count, startIndex, searchType, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * To retrieve application and card information using a client access token, send a `GET` request to the `/users/auth/clientaccesstoken/{token}` endpoint.
         * @summary Retrieve client access token
         * @param {string} token Client access token.
         * @param {string} [applicationToken] Unique identifier of the &#x60;application&#x60; object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersAuthClientaccesstokenToken(token: string, applicationToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<ClientAccessTokenResponse> {
            return localVarFp.getUsersAuthClientaccesstokenToken(token, applicationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * To retrieve users who are children of a parent user or business, send a `GET` request to the `/users/{parent_token}/children` endpoint. Include the parent\'s user or business token as a URL path parameter.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary List user child accounts
         * @param {string} parentToken Unique identifier of the parent account holder.
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserCardHolderListResponse> {
            return localVarFp.getUsersParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists all users who match a phone number
         * @param {string} phoneNumber Phone number
         * @param {number} [count] Number of users to retrieve
         * @param {number} [startIndex] Start index
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersPhonenumberPhonenumber(phoneNumber: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserCardHolderListResponse> {
            return localVarFp.getUsersPhonenumberPhonenumber(phoneNumber, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * To retrieve a specific user, send a `GET` request to the `/users/{token}` endpoint. Include the user `token` path parameter to specify the user to return.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===  This endpoint supports <</core-api/field-filtering, field filtering>>.
         * @summary Retrieve user
         * @param {string} token Unique identifier of the user resource.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserCardHolderResponse> {
            return localVarFp.getUsersToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists cardholder notes
         * @param {string} token User token
         * @param {number} [startIndex] Start index
         * @param {number} [count] Number of notes to retrieve
         * @param {string} [createdBy] Created by
         * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
         * @param {boolean} [includePrivate] Include private notes and private fields in note response
         * @param {string} [searchType] Search type
         * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
         * @param {string} [sortBy] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<CardHolderNoteListResponse> {
            return localVarFp.getUsersTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * To retrieve the government-issued identification number for a user, send a `GET` request to the `/users/{token}/ssn` endpoint. Include the `token` path parameter to specify the user whose identification number (SSN, ITIN, TIN, NIN, SIN) you wish to return. You can indicate whether to return the full number or the last four digits only.
         * @summary Retrieve user identification number
         * @param {string} token Unique identifier of the user resource.
         * @param {boolean} [fullSsn] To return the full identification number, set to &#x60;true&#x60;. To return only the last four digits, set to &#x60;false&#x60;.  If the identifications array contains only the last four digits of the identification number, the &#x60;/users/{token}/ssn&#x60; endpoint will return only the last four digits, regardless of the &#x60;full_ssn&#x60; parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersTokenSsn(token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<SsnResponseModel> {
            return localVarFp.getUsersTokenSsn(token, fullSsn, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint enables you to create a user. A new user\'s initial status depends on the <</core-api/kyc-verification, Know Your Customer (KYC) requirements>> of the program or associated <</core-api/account-holder-groups, account holder group>>.  [cols=\"1,1,1,1\"] |=== | KYC Required | Initial User Status | User Active on Creation | User Limitations  | Always | `UNVERIFIED` | Optional | Cannot load funds; cannot activate cards.  | Conditionally | `LIMITED` | Optional | Restricted by rules in `accountholdergroups.pre_kyc_controls`.  | Never | `ACTIVE` | Required | None. |===  [NOTE] Use the `/usertransitions` endpoints to transition user resources between statuses and to view the history of a user\'s status. Do not set the value of the `user.active` field directly. For more information on status changes, see <</core-api/user-transitions#postUsertransitions, Create User Transition>>.  To perform KYC verification on users, the user object must have the following fields configured:  * `first_name` (legal first name only, no prefixes) * `last_name` (legal last name only, no suffixes) * `address1` (cannot be a PO Box) * `city` * `state` * `postal_code` * `country` * `birth_date` * `identifications` * `phone` (required in some cases) * `email` (required in some cases)  [NOTE] The `identifications` requirement depends on your program\'s configuration. To determine if you should provide a full or abbreviated identification number, contact your Marqeta representative. KYC verification requires the full Social Security Number (SSN) or Individual Taxpayer Identification Number (ITIN) of the user.  To create a child user, you must identify the parent user or business and determine whether the child user shares an account with the parent.  The parent must be an existing user or business. On the child user, set the `parent_token` field to the value of the parent\'s `token` field. If either the parent or the grandparent is a business, a `business_token` field is added to the user. This field\'s value is set to the token of either the parent or grandparent (whichever is the business).  The `uses_parent_account` field determines whether the child shares balances with the parent (`true`) or whether the child balances are independent of the parent (`false`). If you do not specify a value for `uses_parent_account`, it is set to `false` by default (the user does not share the parent\'s balance) and returned in the response body. This field cannot be updated, so you must decide upon creation whether the child user shares the parent balance.  Sharing an account with a parent user affects how the child user interacts with cards as follows:  * A child user cannot spend funds if its parent is not active. * An active child user can activate cards, whether the parent is active or not.
         * @summary Create user
         * @param {CardHolderModel} [cardHolderModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(cardHolderModel?: CardHolderModel, options?: RawAxiosRequestConfig): AxiosPromise<UserCardHolderResponse> {
            return localVarFp.postUsers(cardHolderModel, options).then((request) => request(axios, basePath));
        },
        /**
         * To change a user password, send a `POST` request to the `/users/auth/changepassword` endpoint and include the `current_password` and `new_password` in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. This endpoint operates in the context of a currently logged-in user.  A successful password change returns an empty response body with a response code of `204 No Content`.
         * @summary Update user password
         * @param {PasswordUpdateModel} passwordUpdateModel Password update object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthChangepassword(passwordUpdateModel: PasswordUpdateModel, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUsersAuthChangepassword(passwordUpdateModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Each time you want to display a virtual card\'s sensitive data (for example, when using `marqeta.js`), you must first request a new, single-use client access token from the Marqeta platform by sending a `POST` request to the `/users/auth/clientaccesstoken` endpoint. Unredeemed client access tokens expire after five minutes.
         * @summary Create client access token
         * @param {ClientAccessTokenRequest} [clientAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthClientaccesstoken(clientAccessTokenRequest?: ClientAccessTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClientAccessTokenResponse> {
            return localVarFp.postUsersAuthClientaccesstoken(clientAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * To log in a user and return a user access token, send a `POST` request to the `/users/auth/login` endpoint and include the user details in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request.  [TIP] To check a user\'s credentials without logging out the user, call the `/users/auth/onetime` endpoint.
         * @summary Log in user
         * @param {LoginRequestModel} [loginRequestModel] User login object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogin(loginRequestModel?: LoginRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponseModel> {
            return localVarFp.postUsersAuthLogin(loginRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * To log out a user, send a `POST` request to the `/users/auth/logout` endpoint.  A successful logout returns an empty response body with a response code of `204 No Content`.
         * @summary Log out user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthLogout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUsersAuthLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a single-use access token. This type of token authorizes a single request to access API endpoints and data associated with a particular user. A single-use access token differs from a user access token (as returned by `POST` `/users/auth/login`) only in the number of times it can be used.  To return a single-use access token, send a `POST` request to the `/users/auth/onetime` endpoint. Provide one of these sets of input data:  * *Case #1*  Application token and user access token * *Case #2*  Application token, admin access token, and user token * *Case #3*  Application token, user\'s Marqeta password, and user\'s email address  In each case, provide the application token as the HTTP Basic Authentication username in the request header\'s Authorization field. When applicable, provide the user access token or admin access token as the HTTP Basic Authentication password. When applicable, provide the user token or user\'s Marqeta password and email address in link:http://www.json.org/[JSON, window=\"_blank\"] format in the request body.  Before instantiating an embedded Marqeta widget, call this endpoint to obtain the single-use access token required as input (cases #1 and #2).  This endpoint is also useful when you want to check a user\'s credentials before performing a sensitive operation without having to log out the user (case #3).  [NOTE] Calling this endpoint and returning a single-use access token does not invalidate the user\'s current user access token.
         * @summary Create single-use token
         * @param {OneTimeRequestModel} [oneTimeRequestModel] One-time object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthOnetime(oneTimeRequestModel?: OneTimeRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<AccessTokenResponse> {
            return localVarFp.postUsersAuthOnetime(oneTimeRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to generate a password reset token for a user. Send a `POST` request to the `/users/auth/resetpassword` endpoint and include the user\'s email address in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. This request generates and sends an email message containing the `user_token` and `password_reset_token` to the user\'s email address. You must customize the email message with a link that passes the `user_token` and `password_reset_token` to a web page where a subsequent request updates the password.  A successful request returns an empty response body with a response code of `204 No Content`.
         * @summary Request user password reset token
         * @param {ResetUserPasswordEmailModel} [resetUserPasswordEmailModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpassword(resetUserPasswordEmailModel?: ResetUserPasswordEmailModel, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUsersAuthResetpassword(resetUserPasswordEmailModel, options).then((request) => request(axios, basePath));
        },
        /**
         * To reset the user\'s password, send a `POST` request to the `/users/auth/resetpassword/{token}` endpoint that includes a password reset token generated using the `POST /users/auth/resetpassword` operation. Include the `user_token` and `new_password` in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. Include the `password_reset_token` as a path parameter.  A successful password reset returns an empty response body with a response code of `204 No Content`.
         * @summary Reset user password
         * @param {string} token Password reset token generated using the &#x60;POST /users/auth/resetpassword&#x60; operation.
         * @param {ResetUserPasswordModel} [resetUserPasswordModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthResetpasswordToken(token: string, resetUserPasswordModel?: ResetUserPasswordModel, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUsersAuthResetpasswordToken(token, resetUserPasswordModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a `POST` request to the `/users/auth/verifyemail` endpoint to request an email verification token. No input parameters are required because this operation is performed in the context of an authenticated user.  This initial request generates and sends an email message containing the email verification token to the cardholder\'s email address. This email message must include a link that passes the email verification token to a web page where a subsequent request verifies the email address.  A successful request returns an empty response body with a response code of `204 No Content`.
         * @summary Request email verification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemail(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUsersAuthVerifyemail(options).then((request) => request(axios, basePath));
        },
        /**
         * To verify a user\'s email address, send a `POST` request to the `/users/auth/verifyemail/{email_verification_token}` endpoint that includes an `email_verification_token` generated using the `POST /users/auth/verifyemail` operation. Include the `email_verification_token` as a path parameter.  A successful email verification returns an empty response body with a response code of `204 No Content`.
         * @summary Verify email address
         * @param {string} token Email verification token generated using the &#x60;POST /users/auth/verifyemail&#x60; operation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersAuthVerifyemailToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUsersAuthVerifyemailToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * To search for one or more users, send a `POST` request to the `/users/lookup` endpoint. Include in the message body any parameters by which you want to query. This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary Search users
         * @param {number} [count] Number of user resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [searchType] Search type.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {UserCardHolderSearchModel} [userCardHolderSearchModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersLookup(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, userCardHolderSearchModel?: UserCardHolderSearchModel, options?: RawAxiosRequestConfig): AxiosPromise<UserCardHolderListResponse> {
            return localVarFp.postUsersLookup(count, startIndex, searchType, fields, sortBy, userCardHolderSearchModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a note for the cardholder
         * @param {string} token User token
         * @param {CardholderNoteRequestModel} [cardholderNoteRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersTokenNotes(token: string, cardholderNoteRequestModel?: CardholderNoteRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<CardholderNoteResponseModel> {
            return localVarFp.postUsersTokenNotes(token, cardholderNoteRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * To update a specific user resource, send a `PUT` request to the `/users/{token}` endpoint. Include the user `token` path parameter to specify the user to update.  To unlink a child user account from a parent account, pass a null value to the `parent_token` field of the child user resource.
         * @summary Update user
         * @param {string} token Unique identifier of the user resource you want to update.
         * @param {UserCardHolderUpdateModel} userCardHolderUpdateModel User object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersToken(token: string, userCardHolderUpdateModel: UserCardHolderUpdateModel, options?: RawAxiosRequestConfig): AxiosPromise<CardHolderModel> {
            return localVarFp.putUsersToken(token, userCardHolderUpdateModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a specific note for a cardholder
         * @param {string} token User token
         * @param {string} notesToken Notes token
         * @param {CardholderNoteUpdateRequestModel} [cardholderNoteUpdateRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersTokenNotesNotestoken(token: string, notesToken: string, cardholderNoteUpdateRequestModel?: CardholderNoteUpdateRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<CardholderNoteResponseModel> {
            return localVarFp.putUsersTokenNotesNotestoken(token, notesToken, cardholderNoteUpdateRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * To return an array of all of a program\'s users, send a `GET` request to the `/users` endpoint. This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>. To narrow your result set to users that match certain criteria, see the <<search_users,Search users>> endpoint.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===
     * @summary List users
     * @param {number} [count] Number of user resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [searchType] Search type.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsers(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsers(count, startIndex, searchType, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To retrieve application and card information using a client access token, send a `GET` request to the `/users/auth/clientaccesstoken/{token}` endpoint.
     * @summary Retrieve client access token
     * @param {string} token Client access token.
     * @param {string} [applicationToken] Unique identifier of the &#x60;application&#x60; object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersAuthClientaccesstokenToken(token: string, applicationToken?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersAuthClientaccesstokenToken(token, applicationToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To retrieve users who are children of a parent user or business, send a `GET` request to the `/users/{parent_token}/children` endpoint. Include the parent\'s user or business token as a URL path parameter.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===  This endpoint supports <</core-api/field-filtering, field filtering>>.
     * @summary List user child accounts
     * @param {string} parentToken Unique identifier of the parent account holder.
     * @param {number} [count] Number of user resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersParenttokenChildren(parentToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersParenttokenChildren(parentToken, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists all users who match a phone number
     * @param {string} phoneNumber Phone number
     * @param {number} [count] Number of users to retrieve
     * @param {number} [startIndex] Start index
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersPhonenumberPhonenumber(phoneNumber: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersPhonenumberPhonenumber(phoneNumber, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To retrieve a specific user, send a `GET` request to the `/users/{token}` endpoint. Include the user `token` path parameter to specify the user to return.  The `business_token` field is conditionally returned in the response (it cannot be set through the API). You can use this field in conjunction with the `parent_token` field to determine whether the user has a parent or grandparent that is a business:  [cols=\"1,1,1\"] |=== | parent_token | business_token | Description  | Not populated | Not populated | User does not have a parent.  | Populated | Not populated | User\'s parent is a user.  | Populated; matches `business_token` | Populated; matches `parent_token` | User\'s parent is a business.  | Populated; does not match `business_token` | Populated; does not match `parent_token` | User\'s parent is a user and their grandparent is a business. |===  This endpoint supports <</core-api/field-filtering, field filtering>>.
     * @summary Retrieve user
     * @param {string} token Unique identifier of the user resource.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists cardholder notes
     * @param {string} token User token
     * @param {number} [startIndex] Start index
     * @param {number} [count] Number of notes to retrieve
     * @param {string} [createdBy] Created by
     * @param {string} [createdByUserRole] Comma-delimited list of created by user roles
     * @param {boolean} [includePrivate] Include private notes and private fields in note response
     * @param {string} [searchType] Search type
     * @param {string} [fields] Comma-delimited list of fields to return (e.g. field_1,field_2,..). Leave blank to return all fields.
     * @param {string} [sortBy] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersTokenNotes(token: string, startIndex?: number, count?: number, createdBy?: string, createdByUserRole?: string, includePrivate?: boolean, searchType?: string, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTokenNotes(token, startIndex, count, createdBy, createdByUserRole, includePrivate, searchType, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To retrieve the government-issued identification number for a user, send a `GET` request to the `/users/{token}/ssn` endpoint. Include the `token` path parameter to specify the user whose identification number (SSN, ITIN, TIN, NIN, SIN) you wish to return. You can indicate whether to return the full number or the last four digits only.
     * @summary Retrieve user identification number
     * @param {string} token Unique identifier of the user resource.
     * @param {boolean} [fullSsn] To return the full identification number, set to &#x60;true&#x60;. To return only the last four digits, set to &#x60;false&#x60;.  If the identifications array contains only the last four digits of the identification number, the &#x60;/users/{token}/ssn&#x60; endpoint will return only the last four digits, regardless of the &#x60;full_ssn&#x60; parameter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUsersTokenSsn(token: string, fullSsn?: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUsersTokenSsn(token, fullSsn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint enables you to create a user. A new user\'s initial status depends on the <</core-api/kyc-verification, Know Your Customer (KYC) requirements>> of the program or associated <</core-api/account-holder-groups, account holder group>>.  [cols=\"1,1,1,1\"] |=== | KYC Required | Initial User Status | User Active on Creation | User Limitations  | Always | `UNVERIFIED` | Optional | Cannot load funds; cannot activate cards.  | Conditionally | `LIMITED` | Optional | Restricted by rules in `accountholdergroups.pre_kyc_controls`.  | Never | `ACTIVE` | Required | None. |===  [NOTE] Use the `/usertransitions` endpoints to transition user resources between statuses and to view the history of a user\'s status. Do not set the value of the `user.active` field directly. For more information on status changes, see <</core-api/user-transitions#postUsertransitions, Create User Transition>>.  To perform KYC verification on users, the user object must have the following fields configured:  * `first_name` (legal first name only, no prefixes) * `last_name` (legal last name only, no suffixes) * `address1` (cannot be a PO Box) * `city` * `state` * `postal_code` * `country` * `birth_date` * `identifications` * `phone` (required in some cases) * `email` (required in some cases)  [NOTE] The `identifications` requirement depends on your program\'s configuration. To determine if you should provide a full or abbreviated identification number, contact your Marqeta representative. KYC verification requires the full Social Security Number (SSN) or Individual Taxpayer Identification Number (ITIN) of the user.  To create a child user, you must identify the parent user or business and determine whether the child user shares an account with the parent.  The parent must be an existing user or business. On the child user, set the `parent_token` field to the value of the parent\'s `token` field. If either the parent or the grandparent is a business, a `business_token` field is added to the user. This field\'s value is set to the token of either the parent or grandparent (whichever is the business).  The `uses_parent_account` field determines whether the child shares balances with the parent (`true`) or whether the child balances are independent of the parent (`false`). If you do not specify a value for `uses_parent_account`, it is set to `false` by default (the user does not share the parent\'s balance) and returned in the response body. This field cannot be updated, so you must decide upon creation whether the child user shares the parent balance.  Sharing an account with a parent user affects how the child user interacts with cards as follows:  * A child user cannot spend funds if its parent is not active. * An active child user can activate cards, whether the parent is active or not.
     * @summary Create user
     * @param {CardHolderModel} [cardHolderModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsers(cardHolderModel?: CardHolderModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsers(cardHolderModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To change a user password, send a `POST` request to the `/users/auth/changepassword` endpoint and include the `current_password` and `new_password` in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. This endpoint operates in the context of a currently logged-in user.  A successful password change returns an empty response body with a response code of `204 No Content`.
     * @summary Update user password
     * @param {PasswordUpdateModel} passwordUpdateModel Password update object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthChangepassword(passwordUpdateModel: PasswordUpdateModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthChangepassword(passwordUpdateModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Each time you want to display a virtual card\'s sensitive data (for example, when using `marqeta.js`), you must first request a new, single-use client access token from the Marqeta platform by sending a `POST` request to the `/users/auth/clientaccesstoken` endpoint. Unredeemed client access tokens expire after five minutes.
     * @summary Create client access token
     * @param {ClientAccessTokenRequest} [clientAccessTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthClientaccesstoken(clientAccessTokenRequest?: ClientAccessTokenRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthClientaccesstoken(clientAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To log in a user and return a user access token, send a `POST` request to the `/users/auth/login` endpoint and include the user details in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request.  [TIP] To check a user\'s credentials without logging out the user, call the `/users/auth/onetime` endpoint.
     * @summary Log in user
     * @param {LoginRequestModel} [loginRequestModel] User login object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthLogin(loginRequestModel?: LoginRequestModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthLogin(loginRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To log out a user, send a `POST` request to the `/users/auth/logout` endpoint.  A successful logout returns an empty response body with a response code of `204 No Content`.
     * @summary Log out user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthLogout(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a single-use access token. This type of token authorizes a single request to access API endpoints and data associated with a particular user. A single-use access token differs from a user access token (as returned by `POST` `/users/auth/login`) only in the number of times it can be used.  To return a single-use access token, send a `POST` request to the `/users/auth/onetime` endpoint. Provide one of these sets of input data:  * *Case #1*  Application token and user access token * *Case #2*  Application token, admin access token, and user token * *Case #3*  Application token, user\'s Marqeta password, and user\'s email address  In each case, provide the application token as the HTTP Basic Authentication username in the request header\'s Authorization field. When applicable, provide the user access token or admin access token as the HTTP Basic Authentication password. When applicable, provide the user token or user\'s Marqeta password and email address in link:http://www.json.org/[JSON, window=\"_blank\"] format in the request body.  Before instantiating an embedded Marqeta widget, call this endpoint to obtain the single-use access token required as input (cases #1 and #2).  This endpoint is also useful when you want to check a user\'s credentials before performing a sensitive operation without having to log out the user (case #3).  [NOTE] Calling this endpoint and returning a single-use access token does not invalidate the user\'s current user access token.
     * @summary Create single-use token
     * @param {OneTimeRequestModel} [oneTimeRequestModel] One-time object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthOnetime(oneTimeRequestModel?: OneTimeRequestModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthOnetime(oneTimeRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to generate a password reset token for a user. Send a `POST` request to the `/users/auth/resetpassword` endpoint and include the user\'s email address in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. This request generates and sends an email message containing the `user_token` and `password_reset_token` to the user\'s email address. You must customize the email message with a link that passes the `user_token` and `password_reset_token` to a web page where a subsequent request updates the password.  A successful request returns an empty response body with a response code of `204 No Content`.
     * @summary Request user password reset token
     * @param {ResetUserPasswordEmailModel} [resetUserPasswordEmailModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthResetpassword(resetUserPasswordEmailModel?: ResetUserPasswordEmailModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthResetpassword(resetUserPasswordEmailModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To reset the user\'s password, send a `POST` request to the `/users/auth/resetpassword/{token}` endpoint that includes a password reset token generated using the `POST /users/auth/resetpassword` operation. Include the `user_token` and `new_password` in link:http://www.json.org/[JSON, window=\"_blank\"] format in the body of the request. Include the `password_reset_token` as a path parameter.  A successful password reset returns an empty response body with a response code of `204 No Content`.
     * @summary Reset user password
     * @param {string} token Password reset token generated using the &#x60;POST /users/auth/resetpassword&#x60; operation.
     * @param {ResetUserPasswordModel} [resetUserPasswordModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthResetpasswordToken(token: string, resetUserPasswordModel?: ResetUserPasswordModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthResetpasswordToken(token, resetUserPasswordModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a `POST` request to the `/users/auth/verifyemail` endpoint to request an email verification token. No input parameters are required because this operation is performed in the context of an authenticated user.  This initial request generates and sends an email message containing the email verification token to the cardholder\'s email address. This email message must include a link that passes the email verification token to a web page where a subsequent request verifies the email address.  A successful request returns an empty response body with a response code of `204 No Content`.
     * @summary Request email verification token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthVerifyemail(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthVerifyemail(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To verify a user\'s email address, send a `POST` request to the `/users/auth/verifyemail/{email_verification_token}` endpoint that includes an `email_verification_token` generated using the `POST /users/auth/verifyemail` operation. Include the `email_verification_token` as a path parameter.  A successful email verification returns an empty response body with a response code of `204 No Content`.
     * @summary Verify email address
     * @param {string} token Email verification token generated using the &#x60;POST /users/auth/verifyemail&#x60; operation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersAuthVerifyemailToken(token: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersAuthVerifyemailToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To search for one or more users, send a `POST` request to the `/users/lookup` endpoint. Include in the message body any parameters by which you want to query. This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
     * @summary Search users
     * @param {number} [count] Number of user resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [searchType] Search type.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {UserCardHolderSearchModel} [userCardHolderSearchModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersLookup(count?: number, startIndex?: number, searchType?: string, fields?: string, sortBy?: string, userCardHolderSearchModel?: UserCardHolderSearchModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersLookup(count, startIndex, searchType, fields, sortBy, userCardHolderSearchModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a note for the cardholder
     * @param {string} token User token
     * @param {CardholderNoteRequestModel} [cardholderNoteRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postUsersTokenNotes(token: string, cardholderNoteRequestModel?: CardholderNoteRequestModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).postUsersTokenNotes(token, cardholderNoteRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To update a specific user resource, send a `PUT` request to the `/users/{token}` endpoint. Include the user `token` path parameter to specify the user to update.  To unlink a child user account from a parent account, pass a null value to the `parent_token` field of the child user resource.
     * @summary Update user
     * @param {string} token Unique identifier of the user resource you want to update.
     * @param {UserCardHolderUpdateModel} userCardHolderUpdateModel User object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putUsersToken(token: string, userCardHolderUpdateModel: UserCardHolderUpdateModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).putUsersToken(token, userCardHolderUpdateModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a specific note for a cardholder
     * @param {string} token User token
     * @param {string} notesToken Notes token
     * @param {CardholderNoteUpdateRequestModel} [cardholderNoteUpdateRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putUsersTokenNotesNotestoken(token: string, notesToken: string, cardholderNoteUpdateRequestModel?: CardholderNoteUpdateRequestModel, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).putUsersTokenNotesNotestoken(token, notesToken, cardholderNoteUpdateRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VelocityControlsApi - axios parameter creator
 */
export const VelocityControlsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Sets a specific velocity control to inactive to soft delete it
         * @param {string} token Velocity control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVelocitycontrolsToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('deleteVelocitycontrolsToken', 'token', token)
            const localVarPath = `/velocitycontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all the velocity controls associated with a specific user or card product, or lists all the velocity controls defined for your program.  Include either a `user` or a `card_product` query parameter to indicate the user or card product whose associated velocity controls you want to retrieve (do not include both).  To list all velocity controls for your program, omit the `user` and `card_product` query parameters from your request.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List velocity controls
         * @param {string} [cardProduct] Unique identifier of the card product. Enter the string &#x60;null&#x60; to retrieve velocity controls that are not associated with any card product.
         * @param {string} [user] Unique identifier of the user. Enter the string &#x60;null&#x60; to retrieve velocity controls that are not associated with any user.
         * @param {number} [count] Number of velocity control resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrols: async (cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/velocitycontrols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (cardProduct !== undefined) {
                localVarQueryParameter['card_product'] = cardProduct;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve velocity control available balances for an account token
         * @param {string} accountToken Account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsAccountAccountTokenAvailable: async (accountToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountToken' is not null or undefined
            assertParamExists('getVelocitycontrolsAccountAccountTokenAvailable', 'accountToken', accountToken)
            const localVarPath = `/velocitycontrols/account/{account_token}/available`
                .replace(`{${"account_token"}}`, encodeURIComponent(String(accountToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific velocity control.
         * @summary Returns a specific velocity control
         * @param {string} token Unique identifier of the velocity control resource.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsToken: async (token: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getVelocitycontrolsToken', 'token', token)
            const localVarPath = `/velocitycontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of the available balances of the velocity controls associated with a user. This operation is unavailable for velocity controls with a window of `TRANSACTION`, because available balances do not apply to single-transaction velocity windows.  Depending on the control, the balance can include an available monetary amount, the number of transactions remaining, and the number of days remaining in the time window.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List user velocity control balances
         * @param {string} userToken Unique identifier of the cardholder.
         * @param {number} [count] Number of available balance resources to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsUserUsertokenAvailable: async (userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('getVelocitycontrolsUserUsertokenAvailable', 'userToken', userToken)
            const localVarPath = `/velocitycontrols/user/{user_token}/available`
                .replace(`{${"user_token"}}`, encodeURIComponent(String(userToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Limits how much and how frequently a user can spend funds. If multiple velocity controls apply to the same user, the user cannot exceed any of the defined spending limits.  [TIP] You can create program-level controls in the sandbox environment. However, you must work with your Marqeta representative to create program-level controls in a production environment.
         * @summary Create velocity control
         * @param {VelocityControlRequest} velocityControlRequest Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVelocitycontrols: async (velocityControlRequest: VelocityControlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'velocityControlRequest' is not null or undefined
            assertParamExists('postVelocitycontrols', 'velocityControlRequest', velocityControlRequest)
            const localVarPath = `/velocitycontrols`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(velocityControlRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specific velocity control.
         * @summary Update velocity control
         * @param {string} token Unique identifier of the velocity control resource.
         * @param {VelocityControlUpdateRequest} velocityControlUpdateRequest Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVelocitycontrolsToken: async (token: string, velocityControlUpdateRequest: VelocityControlUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putVelocitycontrolsToken', 'token', token)
            // verify required parameter 'velocityControlUpdateRequest' is not null or undefined
            assertParamExists('putVelocitycontrolsToken', 'velocityControlUpdateRequest', velocityControlUpdateRequest)
            const localVarPath = `/velocitycontrols/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(velocityControlUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VelocityControlsApi - functional programming interface
 */
export const VelocityControlsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = VelocityControlsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Sets a specific velocity control to inactive to soft delete it
         * @param {string} token Velocity control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVelocitycontrolsToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VelocityControlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVelocitycontrolsToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VelocityControlsApi.deleteVelocitycontrolsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all the velocity controls associated with a specific user or card product, or lists all the velocity controls defined for your program.  Include either a `user` or a `card_product` query parameter to indicate the user or card product whose associated velocity controls you want to retrieve (do not include both).  To list all velocity controls for your program, omit the `user` and `card_product` query parameters from your request.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List velocity controls
         * @param {string} [cardProduct] Unique identifier of the card product. Enter the string &#x60;null&#x60; to retrieve velocity controls that are not associated with any card product.
         * @param {string} [user] Unique identifier of the user. Enter the string &#x60;null&#x60; to retrieve velocity controls that are not associated with any user.
         * @param {number} [count] Number of velocity control resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVelocitycontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VelocityControlListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVelocitycontrols(cardProduct, user, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VelocityControlsApi.getVelocitycontrols']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve velocity control available balances for an account token
         * @param {string} accountToken Account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVelocitycontrolsAccountAccountTokenAvailable(accountToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VelocityControlBalanceListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVelocitycontrolsAccountAccountTokenAvailable(accountToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VelocityControlsApi.getVelocitycontrolsAccountAccountTokenAvailable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific velocity control.
         * @summary Returns a specific velocity control
         * @param {string} token Unique identifier of the velocity control resource.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVelocitycontrolsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VelocityControlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVelocitycontrolsToken(token, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VelocityControlsApi.getVelocitycontrolsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of the available balances of the velocity controls associated with a user. This operation is unavailable for velocity controls with a window of `TRANSACTION`, because available balances do not apply to single-transaction velocity windows.  Depending on the control, the balance can include an available monetary amount, the number of transactions remaining, and the number of days remaining in the time window.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List user velocity control balances
         * @param {string} userToken Unique identifier of the cardholder.
         * @param {number} [count] Number of available balance resources to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVelocitycontrolsUserUsertokenAvailable(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VelocityControlBalanceListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVelocitycontrolsUserUsertokenAvailable(userToken, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VelocityControlsApi.getVelocitycontrolsUserUsertokenAvailable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Limits how much and how frequently a user can spend funds. If multiple velocity controls apply to the same user, the user cannot exceed any of the defined spending limits.  [TIP] You can create program-level controls in the sandbox environment. However, you must work with your Marqeta representative to create program-level controls in a production environment.
         * @summary Create velocity control
         * @param {VelocityControlRequest} velocityControlRequest Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVelocitycontrols(velocityControlRequest: VelocityControlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VelocityControlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postVelocitycontrols(velocityControlRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VelocityControlsApi.postVelocitycontrols']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a specific velocity control.
         * @summary Update velocity control
         * @param {string} token Unique identifier of the velocity control resource.
         * @param {VelocityControlUpdateRequest} velocityControlUpdateRequest Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putVelocitycontrolsToken(token: string, velocityControlUpdateRequest: VelocityControlUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VelocityControlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putVelocitycontrolsToken(token, velocityControlUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VelocityControlsApi.putVelocitycontrolsToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VelocityControlsApi - factory interface
 */
export const VelocityControlsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VelocityControlsApiFp(configuration)
    return {
        /**
         * 
         * @summary Sets a specific velocity control to inactive to soft delete it
         * @param {string} token Velocity control token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVelocitycontrolsToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<VelocityControlResponse> {
            return localVarFp.deleteVelocitycontrolsToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all the velocity controls associated with a specific user or card product, or lists all the velocity controls defined for your program.  Include either a `user` or a `card_product` query parameter to indicate the user or card product whose associated velocity controls you want to retrieve (do not include both).  To list all velocity controls for your program, omit the `user` and `card_product` query parameters from your request.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List velocity controls
         * @param {string} [cardProduct] Unique identifier of the card product. Enter the string &#x60;null&#x60; to retrieve velocity controls that are not associated with any card product.
         * @param {string} [user] Unique identifier of the user. Enter the string &#x60;null&#x60; to retrieve velocity controls that are not associated with any user.
         * @param {number} [count] Number of velocity control resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<VelocityControlListResponse> {
            return localVarFp.getVelocitycontrols(cardProduct, user, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve velocity control available balances for an account token
         * @param {string} accountToken Account token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsAccountAccountTokenAvailable(accountToken: string, options?: RawAxiosRequestConfig): AxiosPromise<VelocityControlBalanceListResponse> {
            return localVarFp.getVelocitycontrolsAccountAccountTokenAvailable(accountToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific velocity control.
         * @summary Returns a specific velocity control
         * @param {string} token Unique identifier of the velocity control resource.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsToken(token: string, fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<VelocityControlResponse> {
            return localVarFp.getVelocitycontrolsToken(token, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of the available balances of the velocity controls associated with a user. This operation is unavailable for velocity controls with a window of `TRANSACTION`, because available balances do not apply to single-transaction velocity windows.  Depending on the control, the balance can include an available monetary amount, the number of transactions remaining, and the number of days remaining in the time window.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
         * @summary List user velocity control balances
         * @param {string} userToken Unique identifier of the cardholder.
         * @param {number} [count] Number of available balance resources to retrieve.
         * @param {number} [startIndex] The sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVelocitycontrolsUserUsertokenAvailable(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<VelocityControlBalanceListResponse> {
            return localVarFp.getVelocitycontrolsUserUsertokenAvailable(userToken, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Limits how much and how frequently a user can spend funds. If multiple velocity controls apply to the same user, the user cannot exceed any of the defined spending limits.  [TIP] You can create program-level controls in the sandbox environment. However, you must work with your Marqeta representative to create program-level controls in a production environment.
         * @summary Create velocity control
         * @param {VelocityControlRequest} velocityControlRequest Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVelocitycontrols(velocityControlRequest: VelocityControlRequest, options?: RawAxiosRequestConfig): AxiosPromise<VelocityControlResponse> {
            return localVarFp.postVelocitycontrols(velocityControlRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specific velocity control.
         * @summary Update velocity control
         * @param {string} token Unique identifier of the velocity control resource.
         * @param {VelocityControlUpdateRequest} velocityControlUpdateRequest Velocity control object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putVelocitycontrolsToken(token: string, velocityControlUpdateRequest: VelocityControlUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<VelocityControlResponse> {
            return localVarFp.putVelocitycontrolsToken(token, velocityControlUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VelocityControlsApi - object-oriented interface
 */
export class VelocityControlsApi extends BaseAPI {
    /**
     * 
     * @summary Sets a specific velocity control to inactive to soft delete it
     * @param {string} token Velocity control token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteVelocitycontrolsToken(token: string, options?: RawAxiosRequestConfig) {
        return VelocityControlsApiFp(this.configuration).deleteVelocitycontrolsToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all the velocity controls associated with a specific user or card product, or lists all the velocity controls defined for your program.  Include either a `user` or a `card_product` query parameter to indicate the user or card product whose associated velocity controls you want to retrieve (do not include both).  To list all velocity controls for your program, omit the `user` and `card_product` query parameters from your request.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
     * @summary List velocity controls
     * @param {string} [cardProduct] Unique identifier of the card product. Enter the string &#x60;null&#x60; to retrieve velocity controls that are not associated with any card product.
     * @param {string} [user] Unique identifier of the user. Enter the string &#x60;null&#x60; to retrieve velocity controls that are not associated with any user.
     * @param {number} [count] Number of velocity control resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVelocitycontrols(cardProduct?: string, user?: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return VelocityControlsApiFp(this.configuration).getVelocitycontrols(cardProduct, user, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve velocity control available balances for an account token
     * @param {string} accountToken Account token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVelocitycontrolsAccountAccountTokenAvailable(accountToken: string, options?: RawAxiosRequestConfig) {
        return VelocityControlsApiFp(this.configuration).getVelocitycontrolsAccountAccountTokenAvailable(accountToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific velocity control.
     * @summary Returns a specific velocity control
     * @param {string} token Unique identifier of the velocity control resource.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVelocitycontrolsToken(token: string, fields?: string, options?: RawAxiosRequestConfig) {
        return VelocityControlsApiFp(this.configuration).getVelocitycontrolsToken(token, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of the available balances of the velocity controls associated with a user. This operation is unavailable for velocity controls with a window of `TRANSACTION`, because available balances do not apply to single-transaction velocity windows.  Depending on the control, the balance can include an available monetary amount, the number of transactions remaining, and the number of days remaining in the time window.  This endpoint supports <</core-api/field-filtering, field filtering>> and <</core-api/sorting-and-pagination, pagination>>.
     * @summary List user velocity control balances
     * @param {string} userToken Unique identifier of the cardholder.
     * @param {number} [count] Number of available balance resources to retrieve.
     * @param {number} [startIndex] The sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getVelocitycontrolsUserUsertokenAvailable(userToken: string, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return VelocityControlsApiFp(this.configuration).getVelocitycontrolsUserUsertokenAvailable(userToken, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Limits how much and how frequently a user can spend funds. If multiple velocity controls apply to the same user, the user cannot exceed any of the defined spending limits.  [TIP] You can create program-level controls in the sandbox environment. However, you must work with your Marqeta representative to create program-level controls in a production environment.
     * @summary Create velocity control
     * @param {VelocityControlRequest} velocityControlRequest Velocity control object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postVelocitycontrols(velocityControlRequest: VelocityControlRequest, options?: RawAxiosRequestConfig) {
        return VelocityControlsApiFp(this.configuration).postVelocitycontrols(velocityControlRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a specific velocity control.
     * @summary Update velocity control
     * @param {string} token Unique identifier of the velocity control resource.
     * @param {VelocityControlUpdateRequest} velocityControlUpdateRequest Velocity control object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putVelocitycontrolsToken(token: string, velocityControlUpdateRequest: VelocityControlUpdateRequest, options?: RawAxiosRequestConfig) {
        return VelocityControlsApiFp(this.configuration).putVelocitycontrolsToken(token, velocityControlUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VelocityControlsCardGroupBalanceApi - axios parameter creator
 */
export const VelocityControlsCardGroupBalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all Velocity Controls Card Group Balances in the program
         * @summary List Velocity Controls Card Group Balances
         * @param {string} cardGroupToken Unique identifier of the card group for which to retrieve balances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVelocityControlsCardGroupBalances: async (cardGroupToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cardGroupToken' is not null or undefined
            assertParamExists('listVelocityControlsCardGroupBalances', 'cardGroupToken', cardGroupToken)
            const localVarPath = `/velocitycontrols/cardgroup/{card_group_token}/available`
                .replace(`{${"card_group_token"}}`, encodeURIComponent(String(cardGroupToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VelocityControlsCardGroupBalanceApi - functional programming interface
 */
export const VelocityControlsCardGroupBalanceApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = VelocityControlsCardGroupBalanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all Velocity Controls Card Group Balances in the program
         * @summary List Velocity Controls Card Group Balances
         * @param {string} cardGroupToken Unique identifier of the card group for which to retrieve balances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listVelocityControlsCardGroupBalances(cardGroupToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VelocityControlBalancePage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listVelocityControlsCardGroupBalances(cardGroupToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VelocityControlsCardGroupBalanceApi.listVelocityControlsCardGroupBalances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VelocityControlsCardGroupBalanceApi - factory interface
 */
export const VelocityControlsCardGroupBalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VelocityControlsCardGroupBalanceApiFp(configuration)
    return {
        /**
         * Get a list of all Velocity Controls Card Group Balances in the program
         * @summary List Velocity Controls Card Group Balances
         * @param {string} cardGroupToken Unique identifier of the card group for which to retrieve balances.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listVelocityControlsCardGroupBalances(cardGroupToken: string, options?: RawAxiosRequestConfig): AxiosPromise<VelocityControlBalancePage> {
            return localVarFp.listVelocityControlsCardGroupBalances(cardGroupToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VelocityControlsCardGroupBalanceApi - object-oriented interface
 */
export class VelocityControlsCardGroupBalanceApi extends BaseAPI {
    /**
     * Get a list of all Velocity Controls Card Group Balances in the program
     * @summary List Velocity Controls Card Group Balances
     * @param {string} cardGroupToken Unique identifier of the card group for which to retrieve balances.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listVelocityControlsCardGroupBalances(cardGroupToken: string, options?: RawAxiosRequestConfig) {
        return VelocityControlsCardGroupBalanceApiFp(this.configuration).listVelocityControlsCardGroupBalances(cardGroupToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebPushProvisioningApi - axios parameter creator
 */
export const WebPushProvisioningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary API to query for the web push provisioning related parameters, such as: google piaid/integrator_id, apple partnerId, apple Card Template Identifier
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForWppParameters} requestForWppParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWPPParameters: async (reqSysId: string, requestForWppParameters: RequestForWppParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reqSysId' is not null or undefined
            assertParamExists('getWPPParameters', 'reqSysId', reqSysId)
            // verify required parameter 'requestForWppParameters' is not null or undefined
            assertParamExists('getWPPParameters', 'requestForWppParameters', requestForWppParameters)
            const localVarPath = `/digitalwallets/wpp/parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (reqSysId != null) {
                localVarHeaderParameter['req-sys-id'] = String(reqSysId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(requestForWppParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebPushProvisioningApi - functional programming interface
 */
export const WebPushProvisioningApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = WebPushProvisioningApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary API to query for the web push provisioning related parameters, such as: google piaid/integrator_id, apple partnerId, apple Card Template Identifier
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForWppParameters} requestForWppParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWPPParameters(reqSysId: string, requestForWppParameters: RequestForWppParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebPushProvisioning>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWPPParameters(reqSysId, requestForWppParameters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebPushProvisioningApi.getWPPParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebPushProvisioningApi - factory interface
 */
export const WebPushProvisioningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebPushProvisioningApiFp(configuration)
    return {
        /**
         * 
         * @summary API to query for the web push provisioning related parameters, such as: google piaid/integrator_id, apple partnerId, apple Card Template Identifier
         * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
         * @param {RequestForWppParameters} requestForWppParameters 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWPPParameters(reqSysId: string, requestForWppParameters: RequestForWppParameters, options?: RawAxiosRequestConfig): AxiosPromise<WebPushProvisioning> {
            return localVarFp.getWPPParameters(reqSysId, requestForWppParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebPushProvisioningApi - object-oriented interface
 */
export class WebPushProvisioningApi extends BaseAPI {
    /**
     * 
     * @summary API to query for the web push provisioning related parameters, such as: google piaid/integrator_id, apple partnerId, apple Card Template Identifier
     * @param {string} reqSysId Random pseudo unique value used for troubleshooting between multiple parties. 36 char max
     * @param {RequestForWppParameters} requestForWppParameters 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWPPParameters(reqSysId: string, requestForWppParameters: RequestForWppParameters, options?: RawAxiosRequestConfig) {
        return WebPushProvisioningApiFp(this.configuration).getWPPParameters(reqSysId, requestForWppParameters, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an array of all webhooks.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, sorting>>, and <</core-api/sorting-and-pagination, pagination>>.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To ensure you can access these values as needed, update them on your endpoint, store them securely, and then <</core-api/webhooks#put, update the webhook subscription>>.
         * @summary List webhooks
         * @param {boolean} [active] Set to &#x60;true&#x60; to return only active webhook configurations, otherwise all webhook configurations will be returned.
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: async (active?: boolean, count?: number, startIndex?: number, fields?: string, sortBy?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a webhook.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To ensure you can access these values as needed, update them on your endpoint, store them securely, and then <</core-api/webhooks#put, update the webhook subscription>>.
         * @summary Retrieve webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksToken: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getWebhooksToken', 'token', token)
            const localVarPath = `/webhooks/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a webhook.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To access these values later, store them securely before making the request.
         * @summary Create webhook
         * @param {WebhookRequestModel} [webhookRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooks: async (webhookRequestModel?: WebhookRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(webhookRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resends an event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and is also returned in the response to this request.
         * @summary Resend event notification
         * @param {string} token Unique identifier of the webhook.
         * @param {PostWebhooksTokenEventtypeEventtokenEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} eventToken Unique identifier of the event for which you want to resend a notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenEventtypeEventtoken: async (token: string, eventType: PostWebhooksTokenEventtypeEventtokenEventTypeEnum, eventToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postWebhooksTokenEventtypeEventtoken', 'token', token)
            // verify required parameter 'eventType' is not null or undefined
            assertParamExists('postWebhooksTokenEventtypeEventtoken', 'eventType', eventType)
            // verify required parameter 'eventToken' is not null or undefined
            assertParamExists('postWebhooksTokenEventtypeEventtoken', 'eventToken', eventToken)
            const localVarPath = `/webhooks/{token}/{event_type}/{event_token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)))
                .replace(`{${"event_type"}}`, encodeURIComponent(String(eventType)))
                .replace(`{${"event_token"}}`, encodeURIComponent(String(eventToken)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pings your webhook endpoint.  Send a ping request to your webhook endpoint to validate credentials and connectivity. Your webhook endpoint must be configured to respond.  === Configuring your webhook endpoint  When the Marqeta platform receives the ping request, it sends a `POST` request containing the following body to the URL of your webhook endpoint:  [#ping-webhook-sample] [source,json] ---- {   \"pings\": [     {       \"token\": \"marqeta\",       \"payload\": \"healthcheck\"     }   ] } ----  To indicate that it is functioning properly, your webhook endpoint must respond with a status code of `200` (see <</developer-guides/signature-verification, Signature Verification>> for a code example that identifies a ping request). The response can optionally include a link:http://www.json.org/[JSON, window=\"_blank\"]-formatted body, for example:  [#ping-webhook-sample-2] [source,json] ---- {\"my_endpoint_status\": \"alive\"} ----  The Marqeta platform then responds to its requestor by echoing, as-is, the response code and body received from your webhook endpoint.  === Using the ping facility  To ping a webhook endpoint, send a `POST` request to `/webhooks/{token}/ping` and use the `token` path parameter to specify which webhook you want to reach. Include an empty, link:http://www.json.org/[JSON, window=\"_blank\"]-formatted body in the request, that is:  [#ping-webhook-sample-3] [source,json] ---- {} ----  The following chain of actions occurs during the successful execution of a ping operation:  . The Marqeta platform receives the ping request (`POST` to `/webhooks/{token}/ping`). . The Marqeta platform sends a request to your webhook endpoint. . Your webhook endpoint responds with a status code of \"200\" and an optional body. . The Marqeta platform responds to its requestor by echoing, as-is, the response code and body it received from your webhook endpoint.  [NOTE] If the customer-hosted endpoint fails to respond within five seconds, the Marqeta platform times out the request and responds with the following message body (where `<optional message>` represents additional details you can choose to include in the response):  [#ping-webhook-sample-4] [source,json] ---- {   \"error_message\": \"Webhook operation failed \" + <optional message>,   \"error_code\": \"422600\" } ----  Failed pings are not automatically retried.
         * @summary Ping webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenPing: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('postWebhooksTokenPing', 'token', token)
            const localVarPath = `/webhooks/{token}/ping`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds or updates a webhook\'s custom HTTP headers.
         * @summary Update webhook custom headers
         * @param {string} token Unique identifier of the webhook.
         * @param {WebhookUpdateCustomHeaderRequest} [webhookUpdateCustomHeaderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksCustomHeadersToken: async (token: string, webhookUpdateCustomHeaderRequest?: WebhookUpdateCustomHeaderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putWebhooksCustomHeadersToken', 'token', token)
            const localVarPath = `/webhooks/customheaders/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(webhookUpdateCustomHeaderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a webhook.  You can also use this endpoint to disable webhooks you no longer want to receivethere is no `DELETE` method available to remove unneeded webhooks. To disable a webhook, use this endpoint to set its `active` field to `false`.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To access these values later, store them securely before making the request.  When modifying authentication credentials, update the endpoint configuration before updating your webhook subscription to avoid missing any important event notifications.  For instructions on managing your webhooks via the Developer Dashboard, see the <</developer-guides/developer-tools/#_to_disable_a_webhook, Developer Tools>> guide.
         * @summary Update webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {WebhookBaseModel} [webhookBaseModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksToken: async (token: string, webhookBaseModel?: WebhookBaseModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('putWebhooksToken', 'token', token)
            const localVarPath = `/webhooks/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication mqAppAndAccessToken required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(webhookBaseModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 */
export const WebhooksApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns an array of all webhooks.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, sorting>>, and <</core-api/sorting-and-pagination, pagination>>.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To ensure you can access these values as needed, update them on your endpoint, store them securely, and then <</core-api/webhooks#put, update the webhook subscription>>.
         * @summary List webhooks
         * @param {boolean} [active] Set to &#x60;true&#x60; to return only active webhook configurations, otherwise all webhook configurations will be returned.
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooks(active?: boolean, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponseModelListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooks(active, count, startIndex, fields, sortBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a webhook.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To ensure you can access these values as needed, update them on your endpoint, store them securely, and then <</core-api/webhooks#put, update the webhook subscription>>.
         * @summary Retrieve webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebhooksToken(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebhooksToken(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.getWebhooksToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a webhook.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To access these values later, store them securely before making the request.
         * @summary Create webhook
         * @param {WebhookRequestModel} [webhookRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooks(webhookRequestModel?: WebhookRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhooks(webhookRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resends an event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and is also returned in the response to this request.
         * @summary Resend event notification
         * @param {string} token Unique identifier of the webhook.
         * @param {PostWebhooksTokenEventtypeEventtokenEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} eventToken Unique identifier of the event for which you want to resend a notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksTokenEventtypeEventtoken(token: string, eventType: PostWebhooksTokenEventtypeEventtokenEventTypeEnum, eventToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhooksTokenEventtypeEventtoken(token, eventType, eventToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhooksTokenEventtypeEventtoken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pings your webhook endpoint.  Send a ping request to your webhook endpoint to validate credentials and connectivity. Your webhook endpoint must be configured to respond.  === Configuring your webhook endpoint  When the Marqeta platform receives the ping request, it sends a `POST` request containing the following body to the URL of your webhook endpoint:  [#ping-webhook-sample] [source,json] ---- {   \"pings\": [     {       \"token\": \"marqeta\",       \"payload\": \"healthcheck\"     }   ] } ----  To indicate that it is functioning properly, your webhook endpoint must respond with a status code of `200` (see <</developer-guides/signature-verification, Signature Verification>> for a code example that identifies a ping request). The response can optionally include a link:http://www.json.org/[JSON, window=\"_blank\"]-formatted body, for example:  [#ping-webhook-sample-2] [source,json] ---- {\"my_endpoint_status\": \"alive\"} ----  The Marqeta platform then responds to its requestor by echoing, as-is, the response code and body received from your webhook endpoint.  === Using the ping facility  To ping a webhook endpoint, send a `POST` request to `/webhooks/{token}/ping` and use the `token` path parameter to specify which webhook you want to reach. Include an empty, link:http://www.json.org/[JSON, window=\"_blank\"]-formatted body in the request, that is:  [#ping-webhook-sample-3] [source,json] ---- {} ----  The following chain of actions occurs during the successful execution of a ping operation:  . The Marqeta platform receives the ping request (`POST` to `/webhooks/{token}/ping`). . The Marqeta platform sends a request to your webhook endpoint. . Your webhook endpoint responds with a status code of \"200\" and an optional body. . The Marqeta platform responds to its requestor by echoing, as-is, the response code and body it received from your webhook endpoint.  [NOTE] If the customer-hosted endpoint fails to respond within five seconds, the Marqeta platform times out the request and responds with the following message body (where `<optional message>` represents additional details you can choose to include in the response):  [#ping-webhook-sample-4] [source,json] ---- {   \"error_message\": \"Webhook operation failed \" + <optional message>,   \"error_code\": \"422600\" } ----  Failed pings are not automatically retried.
         * @summary Ping webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWebhooksTokenPing(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookPingModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWebhooksTokenPing(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.postWebhooksTokenPing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds or updates a webhook\'s custom HTTP headers.
         * @summary Update webhook custom headers
         * @param {string} token Unique identifier of the webhook.
         * @param {WebhookUpdateCustomHeaderRequest} [webhookUpdateCustomHeaderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWebhooksCustomHeadersToken(token: string, webhookUpdateCustomHeaderRequest?: WebhookUpdateCustomHeaderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWebhooksCustomHeadersToken(token, webhookUpdateCustomHeaderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.putWebhooksCustomHeadersToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a webhook.  You can also use this endpoint to disable webhooks you no longer want to receivethere is no `DELETE` method available to remove unneeded webhooks. To disable a webhook, use this endpoint to set its `active` field to `false`.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To access these values later, store them securely before making the request.  When modifying authentication credentials, update the endpoint configuration before updating your webhook subscription to avoid missing any important event notifications.  For instructions on managing your webhooks via the Developer Dashboard, see the <</developer-guides/developer-tools/#_to_disable_a_webhook, Developer Tools>> guide.
         * @summary Update webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {WebhookBaseModel} [webhookBaseModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putWebhooksToken(token: string, webhookBaseModel?: WebhookBaseModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putWebhooksToken(token, webhookBaseModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.putWebhooksToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Returns an array of all webhooks.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, sorting>>, and <</core-api/sorting-and-pagination, pagination>>.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To ensure you can access these values as needed, update them on your endpoint, store them securely, and then <</core-api/webhooks#put, update the webhook subscription>>.
         * @summary List webhooks
         * @param {boolean} [active] Set to &#x60;true&#x60; to return only active webhook configurations, otherwise all webhook configurations will be returned.
         * @param {number} [count] Number of resources to retrieve.
         * @param {number} [startIndex] Sort order index of the first resource in the returned array.
         * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
         * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(active?: boolean, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookResponseModelListResponse> {
            return localVarFp.getWebhooks(active, count, startIndex, fields, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a webhook.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To ensure you can access these values as needed, update them on your endpoint, store them securely, and then <</core-api/webhooks#put, update the webhook subscription>>.
         * @summary Retrieve webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooksToken(token: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookResponseModel> {
            return localVarFp.getWebhooksToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a webhook.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To access these values later, store them securely before making the request.
         * @summary Create webhook
         * @param {WebhookRequestModel} [webhookRequestModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooks(webhookRequestModel?: WebhookRequestModel, options?: RawAxiosRequestConfig): AxiosPromise<WebhookResponseModel> {
            return localVarFp.postWebhooks(webhookRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Resends an event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and is also returned in the response to this request.
         * @summary Resend event notification
         * @param {string} token Unique identifier of the webhook.
         * @param {PostWebhooksTokenEventtypeEventtokenEventTypeEnum} eventType Specifies the type of event you want to resend.
         * @param {string} eventToken Unique identifier of the event for which you want to resend a notification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenEventtypeEventtoken(token: string, eventType: PostWebhooksTokenEventtypeEventtokenEventTypeEnum, eventToken: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWebhooksTokenEventtypeEventtoken(token, eventType, eventToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Pings your webhook endpoint.  Send a ping request to your webhook endpoint to validate credentials and connectivity. Your webhook endpoint must be configured to respond.  === Configuring your webhook endpoint  When the Marqeta platform receives the ping request, it sends a `POST` request containing the following body to the URL of your webhook endpoint:  [#ping-webhook-sample] [source,json] ---- {   \"pings\": [     {       \"token\": \"marqeta\",       \"payload\": \"healthcheck\"     }   ] } ----  To indicate that it is functioning properly, your webhook endpoint must respond with a status code of `200` (see <</developer-guides/signature-verification, Signature Verification>> for a code example that identifies a ping request). The response can optionally include a link:http://www.json.org/[JSON, window=\"_blank\"]-formatted body, for example:  [#ping-webhook-sample-2] [source,json] ---- {\"my_endpoint_status\": \"alive\"} ----  The Marqeta platform then responds to its requestor by echoing, as-is, the response code and body received from your webhook endpoint.  === Using the ping facility  To ping a webhook endpoint, send a `POST` request to `/webhooks/{token}/ping` and use the `token` path parameter to specify which webhook you want to reach. Include an empty, link:http://www.json.org/[JSON, window=\"_blank\"]-formatted body in the request, that is:  [#ping-webhook-sample-3] [source,json] ---- {} ----  The following chain of actions occurs during the successful execution of a ping operation:  . The Marqeta platform receives the ping request (`POST` to `/webhooks/{token}/ping`). . The Marqeta platform sends a request to your webhook endpoint. . Your webhook endpoint responds with a status code of \"200\" and an optional body. . The Marqeta platform responds to its requestor by echoing, as-is, the response code and body it received from your webhook endpoint.  [NOTE] If the customer-hosted endpoint fails to respond within five seconds, the Marqeta platform times out the request and responds with the following message body (where `<optional message>` represents additional details you can choose to include in the response):  [#ping-webhook-sample-4] [source,json] ---- {   \"error_message\": \"Webhook operation failed \" + <optional message>,   \"error_code\": \"422600\" } ----  Failed pings are not automatically retried.
         * @summary Ping webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWebhooksTokenPing(token: string, options?: RawAxiosRequestConfig): AxiosPromise<WebhookPingModel> {
            return localVarFp.postWebhooksTokenPing(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds or updates a webhook\'s custom HTTP headers.
         * @summary Update webhook custom headers
         * @param {string} token Unique identifier of the webhook.
         * @param {WebhookUpdateCustomHeaderRequest} [webhookUpdateCustomHeaderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksCustomHeadersToken(token: string, webhookUpdateCustomHeaderRequest?: WebhookUpdateCustomHeaderRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookResponseModel> {
            return localVarFp.putWebhooksCustomHeadersToken(token, webhookUpdateCustomHeaderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a webhook.  You can also use this endpoint to disable webhooks you no longer want to receivethere is no `DELETE` method available to remove unneeded webhooks. To disable a webhook, use this endpoint to set its `active` field to `false`.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To access these values later, store them securely before making the request.  When modifying authentication credentials, update the endpoint configuration before updating your webhook subscription to avoid missing any important event notifications.  For instructions on managing your webhooks via the Developer Dashboard, see the <</developer-guides/developer-tools/#_to_disable_a_webhook, Developer Tools>> guide.
         * @summary Update webhook
         * @param {string} token Unique identifier of the webhook.
         * @param {WebhookBaseModel} [webhookBaseModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putWebhooksToken(token: string, webhookBaseModel?: WebhookBaseModel, options?: RawAxiosRequestConfig): AxiosPromise<WebhookResponseModel> {
            return localVarFp.putWebhooksToken(token, webhookBaseModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Returns an array of all webhooks.  This endpoint supports <</core-api/field-filtering, field filtering>>, <</core-api/sorting-and-pagination, sorting>>, and <</core-api/sorting-and-pagination, pagination>>.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To ensure you can access these values as needed, update them on your endpoint, store them securely, and then <</core-api/webhooks#put, update the webhook subscription>>.
     * @summary List webhooks
     * @param {boolean} [active] Set to &#x60;true&#x60; to return only active webhook configurations, otherwise all webhook configurations will be returned.
     * @param {number} [count] Number of resources to retrieve.
     * @param {number} [startIndex] Sort order index of the first resource in the returned array.
     * @param {string} [fields] Comma-delimited list of fields to return (&#x60;field_1,field_2&#x60;, and so on). Leave blank to return all fields.
     * @param {string} [sortBy] Field on which to sort. Use any field in the resource model, or one of the system fields &#x60;lastModifiedTime&#x60; or &#x60;createdTime&#x60;. Prefix the field name with a hyphen (&#x60;-&#x60;) to sort in descending order. Omit the hyphen to sort in ascending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWebhooks(active?: boolean, count?: number, startIndex?: number, fields?: string, sortBy?: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooks(active, count, startIndex, fields, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a webhook.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To ensure you can access these values as needed, update them on your endpoint, store them securely, and then <</core-api/webhooks#put, update the webhook subscription>>.
     * @summary Retrieve webhook
     * @param {string} token Unique identifier of the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWebhooksToken(token: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).getWebhooksToken(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a webhook.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To access these values later, store them securely before making the request.
     * @summary Create webhook
     * @param {WebhookRequestModel} [webhookRequestModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postWebhooks(webhookRequestModel?: WebhookRequestModel, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhooks(webhookRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resends an event notification to your webhook endpoint.  Although you send this request as a `POST`, all parameters are passed in the URL and the body is empty. The event notification is resent to your webhook endpoint and is also returned in the response to this request.
     * @summary Resend event notification
     * @param {string} token Unique identifier of the webhook.
     * @param {PostWebhooksTokenEventtypeEventtokenEventTypeEnum} eventType Specifies the type of event you want to resend.
     * @param {string} eventToken Unique identifier of the event for which you want to resend a notification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postWebhooksTokenEventtypeEventtoken(token: string, eventType: PostWebhooksTokenEventtypeEventtokenEventTypeEnum, eventToken: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhooksTokenEventtypeEventtoken(token, eventType, eventToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pings your webhook endpoint.  Send a ping request to your webhook endpoint to validate credentials and connectivity. Your webhook endpoint must be configured to respond.  === Configuring your webhook endpoint  When the Marqeta platform receives the ping request, it sends a `POST` request containing the following body to the URL of your webhook endpoint:  [#ping-webhook-sample] [source,json] ---- {   \"pings\": [     {       \"token\": \"marqeta\",       \"payload\": \"healthcheck\"     }   ] } ----  To indicate that it is functioning properly, your webhook endpoint must respond with a status code of `200` (see <</developer-guides/signature-verification, Signature Verification>> for a code example that identifies a ping request). The response can optionally include a link:http://www.json.org/[JSON, window=\"_blank\"]-formatted body, for example:  [#ping-webhook-sample-2] [source,json] ---- {\"my_endpoint_status\": \"alive\"} ----  The Marqeta platform then responds to its requestor by echoing, as-is, the response code and body received from your webhook endpoint.  === Using the ping facility  To ping a webhook endpoint, send a `POST` request to `/webhooks/{token}/ping` and use the `token` path parameter to specify which webhook you want to reach. Include an empty, link:http://www.json.org/[JSON, window=\"_blank\"]-formatted body in the request, that is:  [#ping-webhook-sample-3] [source,json] ---- {} ----  The following chain of actions occurs during the successful execution of a ping operation:  . The Marqeta platform receives the ping request (`POST` to `/webhooks/{token}/ping`). . The Marqeta platform sends a request to your webhook endpoint. . Your webhook endpoint responds with a status code of \"200\" and an optional body. . The Marqeta platform responds to its requestor by echoing, as-is, the response code and body it received from your webhook endpoint.  [NOTE] If the customer-hosted endpoint fails to respond within five seconds, the Marqeta platform times out the request and responds with the following message body (where `<optional message>` represents additional details you can choose to include in the response):  [#ping-webhook-sample-4] [source,json] ---- {   \"error_message\": \"Webhook operation failed \" + <optional message>,   \"error_code\": \"422600\" } ----  Failed pings are not automatically retried.
     * @summary Ping webhook
     * @param {string} token Unique identifier of the webhook.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public postWebhooksTokenPing(token: string, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).postWebhooksTokenPing(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds or updates a webhook\'s custom HTTP headers.
     * @summary Update webhook custom headers
     * @param {string} token Unique identifier of the webhook.
     * @param {WebhookUpdateCustomHeaderRequest} [webhookUpdateCustomHeaderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putWebhooksCustomHeadersToken(token: string, webhookUpdateCustomHeaderRequest?: WebhookUpdateCustomHeaderRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).putWebhooksCustomHeadersToken(token, webhookUpdateCustomHeaderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a webhook.  You can also use this endpoint to disable webhooks you no longer want to receivethere is no `DELETE` method available to remove unneeded webhooks. To disable a webhook, use this endpoint to set its `active` field to `false`.  [NOTE] As shown in the example, `config.secret`, `config.basic_auth_username`, and `config.basic_auth_password` are masked in responses to this and all other requests.  To access these values later, store them securely before making the request.  When modifying authentication credentials, update the endpoint configuration before updating your webhook subscription to avoid missing any important event notifications.  For instructions on managing your webhooks via the Developer Dashboard, see the <</developer-guides/developer-tools/#_to_disable_a_webhook, Developer Tools>> guide.
     * @summary Update webhook
     * @param {string} token Unique identifier of the webhook.
     * @param {WebhookBaseModel} [webhookBaseModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public putWebhooksToken(token: string, webhookBaseModel?: WebhookBaseModel, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).putWebhooksToken(token, webhookBaseModel, options).then((request) => request(this.axios, this.basePath));
    }
}

export const PostWebhooksTokenEventtypeEventtokenEventTypeEnum = {
    Chargebacktransition: 'chargebacktransition',
    Digitalwallettokentransition: 'digitalwallettokentransition',
    Cardtransition: 'cardtransition',
    Usertransition: 'usertransition',
    Businesstransition: 'businesstransition',
    Transaction: 'transaction',
    Threedstransition: 'threedstransition'
} as const;
export type PostWebhooksTokenEventtypeEventtokenEventTypeEnum = typeof PostWebhooksTokenEventtypeEventtokenEventTypeEnum[keyof typeof PostWebhooksTokenEventtypeEventtokenEventTypeEnum];


